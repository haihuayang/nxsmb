/* header auto-generated by pidl */
#ifndef _PIDL_HEADER_dcerpc
#define _PIDL_HEADER_dcerpc
#include "include/librpc/ndr_smb.hxx"

#include "include/librpc/misc.hxx"

namespace idl {
extern const uint8_t DCERPC_SEC_VT_MAGIC[8];

#ifndef _HEADER_dcerpc
#define _HEADER_dcerpc

struct dcerpc_ctx_list {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint16 context_id;
	ndr_syntax_id abstract_syntax;
	std::vector<ndr_syntax_id> transfer_syntaxes;
} ;

template <> struct x_ndr_traits_t<dcerpc_ctx_list> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};

struct dcerpc_bind {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint16 max_xmit_frag;
	uint16 max_recv_frag;
	uint32 assoc_group_id;
	std::vector<dcerpc_ctx_list> ctx_list;
	DATA_BLOB auth_info;/* [flag(LIBNDR_FLAG_REMAINING)] */
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_bind> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};

const uint8 DCERPC_REQUEST_LENGTH = 24;

struct dcerpc_empty {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
} ;

template <> struct x_ndr_traits_t<dcerpc_empty> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


union dcerpc_object
{
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	GUID object;/* [case(LIBNDR_FLAG_OBJECT_PRESENT)] */
	dcerpc_empty empty;/* [default] */
} /* [nodiscriminant] */;

template <> struct x_ndr_traits_t<dcerpc_object> {
	using ndr_type = x_ndr_type_union;
};


struct dcerpc_request {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 alloc_hint;
	uint16 context_id;
	uint16 opnum;
	dcerpc_object object;/* [switch_is(NDR_DCERPC_REQUEST_OBJECT_PRESENT)] */
	DATA_BLOB stub_and_verifier;/* [flag(LIBNDR_FLAG_REMAINING)] */
} ;

template <> struct x_ndr_traits_t<dcerpc_request> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};

enum dcerpc_bind_ack_result : uint16 {
	DCERPC_BIND_ACK_RESULT_ACCEPTANCE=0,
	DCERPC_BIND_ACK_RESULT_USER_REJECTION=1,
	DCERPC_BIND_ACK_RESULT_PROVIDER_REJECTION=2,
	DCERPC_BIND_ACK_RESULT_NEGOTIATE_ACK=3,
}/* [enum16bit] */;

template <> struct x_ndr_traits_t<dcerpc_bind_ack_result> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 4> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<dcerpc_bind_ack_result>(const dcerpc_bind_ack_result &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint16(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<dcerpc_bind_ack_result>(dcerpc_bind_ack_result &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_bind_ack_result(v);
	return __bpos;
}

const int DCERPC_BIND_PROVIDER_REJECT = DCERPC_BIND_ACK_RESULT_PROVIDER_REJECTION;

enum dcerpc_bind_ack_reason_values : uint16 {
	DCERPC_BIND_ACK_REASON_NOT_SPECIFIED=0,
	DCERPC_BIND_ACK_REASON_ABSTRACT_SYNTAX_NOT_SUPPORTED=1,
	DCERPC_BIND_ACK_REASON_TRANSFER_SYNTAXES_NOT_SUPPORTED=2,
	DCERPC_BIND_ACK_REASON_LOCAL_LIMIT_EXCEEDED=3,
}/* [enum16bit] */;

template <> struct x_ndr_traits_t<dcerpc_bind_ack_reason_values> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 4> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<dcerpc_bind_ack_reason_values>(const dcerpc_bind_ack_reason_values &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint16(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<dcerpc_bind_ack_reason_values>(dcerpc_bind_ack_reason_values &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_bind_ack_reason_values(v);
	return __bpos;
}

const int DCERPC_BIND_REASON_ASYNTAX = DCERPC_BIND_ACK_REASON_ABSTRACT_SYNTAX_NOT_SUPPORTED;

enum dcerpc_bind_time_features : uint16 {
	DCERPC_BIND_TIME_SECURITY_CONTEXT_MULTIPLEXING=0x0001,
	DCERPC_BIND_TIME_KEEP_CONNECTION_ON_ORPHAN=0x0002,
}/* [bitmap16bit] */;

template <> struct x_ndr_traits_t<dcerpc_bind_time_features> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 2> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<dcerpc_bind_time_features>(const dcerpc_bind_time_features &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint16(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<dcerpc_bind_time_features>(dcerpc_bind_time_features &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_bind_time_features(v);
	return __bpos;
}



union dcerpc_bind_ack_reason
{
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dcerpc_bind_time_features negotiate;/* [case(DCERPC_BIND_ACK_RESULT_NEGOTIATE_ACK)] */
	dcerpc_bind_ack_reason_values value;/* [default] */
} /* [nodiscriminant] */;

template <> struct x_ndr_traits_t<dcerpc_bind_ack_reason> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_union;
};


struct dcerpc_ack_ctx {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dcerpc_bind_ack_result result;
	dcerpc_bind_ack_reason reason;/* [switch_is(result)] */
	ndr_syntax_id syntax;
} ;

template <> struct x_ndr_traits_t<dcerpc_ack_ctx> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


struct dcerpc_bind_ack {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint16 max_xmit_frag;
	uint16 max_recv_frag;
	uint32 assoc_group_id;
	std::string secondary_address;
	std::vector<dcerpc_ack_ctx> ctx_list;
	DATA_BLOB auth_info;/* [flag(LIBNDR_FLAG_REMAINING)] */
} ;

template <> struct x_ndr_traits_t<dcerpc_bind_ack> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};

#if 0
enum dcerpc_bind_nak_reason : uint16 {
	DCERPC_BIND_NAK_REASON_NOT_SPECIFIED=0,
	DCERPC_BIND_NAK_REASON_TEMPORARY_CONGESTION=1,
	DCERPC_BIND_NAK_REASON_LOCAL_LIMIT_EXCEEDED=2,
	DCERPC_BIND_NAK_REASON_PROTOCOL_VERSION_NOT_SUPPORTED=4,
	DCERPC_BIND_NAK_REASON_INVALID_AUTH_TYPE=8,
	DCERPC_BIND_NAK_REASON_INVALID_CHECKSUM=9,
}/* [enum16bit, public] */;

template <> struct x_ndr_traits_t<dcerpc_bind_nak_reason> {
	using ndr_ostr_type = x_ndr_ostr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 6> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_data<dcerpc_bind_nak_reason>(const dcerpc_bind_nak_reason &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint16(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<dcerpc_bind_nak_reason>(dcerpc_bind_nak_reason &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_bind_nak_reason(v);
	return __bpos;
}

const int DECRPC_BIND_PROTOCOL_VERSION_NOT_SUPPORTED = DCERPC_BIND_NAK_REASON_PROTOCOL_VERSION_NOT_SUPPORTED;
const int DCERPC_BIND_REASON_INVALID_AUTH_TYPE = DCERPC_BIND_NAK_REASON_INVALID_AUTH_TYPE;

struct dcerpc_bind_nak_version {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint8 rpc_vers;
	uint8 rpc_vers_minor;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_bind_nak_version> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_bind_nak {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dcerpc_bind_nak_reason reject_reason;
	std::vector<dcerpc_bind_nak_version> versions;
	DATA_BLOB _pad;/* [flag(LIBNDR_FLAG_REMAINING)] */
} /* [public, nopull] */;

template <> struct x_ndr_traits_t<dcerpc_bind_nak> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};
#endif

const uint8 DCERPC_RESPONSE_LENGTH = 24;

struct dcerpc_response {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 alloc_hint;
	uint16 context_id;
	uint8 cancel_count;
	uint8 _pad;
	std::vector<uint8> stub_and_verifier;
	// DATA_BLOB _pad;/* [flag(LIBNDR_FLAG_ALIGN8)] */
	// DATA_BLOB stub_and_verifier;/* [flag(LIBNDR_FLAG_REMAINING)] */
} ;

template <> struct x_ndr_traits_t<dcerpc_response> {
	using has_buffers = std::false_type;
	using ndr_ostr_type = x_ndr_type_struct;
};

enum dcerpc_nca_status : uint32 {
	DCERPC_NCA_S_COMM_FAILURE=0x1C010001,
	DCERPC_NCA_S_OP_RNG_ERROR=0x1C010002,
	DCERPC_NCA_S_UNKNOWN_IF=0x1C010003,
	DCERPC_NCA_S_WRONG_BOOT_TIME=0x1C010006,
	DCERPC_NCA_S_YOU_CRASHED=0x1C010009,
	DCERPC_NCA_S_PROTO_ERROR=0x1C01000B,
	DCERPC_NCA_S_OUT_ARGS_TOO_BIG=0x1C010013,
	DCERPC_NCA_S_SERVER_TOO_BUSY=0x1C010014,
	DCERPC_NCA_S_FAULT_STRING_TOO_LARGE=0x1C010015,
	DCERPC_NCA_S_UNSUPPORTED_TYPE=0x1C010017,
	DCERPC_NCA_S_FAULT_INT_DIV_BY_ZERO=0x1C000001,
	DCERPC_NCA_S_FAULT_ADDR_ERROR=0x1C000002,
	DCERPC_NCA_S_FAULT_FP_DIV_BY_ZERO=0x1C000003,
	DCERPC_NCA_S_FAULT_FP_UNDERFLOW=0x1C000004,
	DCERPC_NCA_S_FAULT_FP_OVERRFLOW=0x1C000005,
	DCERPC_NCA_S_FAULT_INVALID_TAG=0x1C000006,
	DCERPC_NCA_S_FAULT_INVALID_BOUND=0x1C000007,
	DCERPC_NCA_S_FAULT_RPC_VERSION_MISMATCH=0x1C000008,
	DCERPC_NCA_S_FAULT_UNSPEC_REJECT=0x1C000009,
	DCERPC_NCA_S_FAULT_BAD_ACTID=0x1C00000A,
	DCERPC_NCA_S_FAULT_WHO_ARE_YOU_FAILED=0x1C00000B,
	DCERPC_NCA_S_FAULT_MANAGER_NOT_ENTERED=0x1C00000C,
	DCERPC_NCA_S_FAULT_CANCEL=0x1C00000D,
	DCERPC_NCA_S_FAULT_ILL_INST=0x1C00000E,
	DCERPC_NCA_S_FAULT_FP_ERROR=0x1C00000F,
	DCERPC_NCA_S_FAULT_INT_OVERFLOW=0x1C000010,
	DCERPC_NCA_S_UNUSED_1C000011=0x1C000011,
	DCERPC_NCA_S_FAULT_UNSPEC=0x1C000012,
	DCERPC_NCA_S_FAULT_REMOTE_COMM_FAILURE=0x1C000013,
	DCERPC_NCA_S_FAULT_PIPE_EMPTY=0x1C000014,
	DCERPC_NCA_S_FAULT_PIPE_CLOSED=0x1C000015,
	DCERPC_NCA_S_FAULT_PIPE_ORDER=0x1C000016,
	DCERPC_NCA_S_FAULT_PIPE_DISCIPLINE=0x1C000017,
	DCERPC_NCA_S_FAULT_PIPE_COMM_ERROR=0x1C000018,
	DCERPC_NCA_S_FAULT_PIPE_MEMORY=0x1C000019,
	DCERPC_NCA_S_FAULT_CONTEXT_MISMATCH=0x1C00001A,
	DCERPC_NCA_S_FAULT_REMOTE_NO_MEMORY=0x1C00001B,
	DCERPC_NCA_S_INVALID_PRES_CONTEXT_ID=0x1C00001C,
	DCERPC_NCA_S_UNSUPPORTED_AUTHN_LEVEL=0x1C00001D,
	DCERPC_NCA_S_UNUSED_1C00001E=0x1C00001E,
	DCERPC_NCA_S_INVALID_CHECKSUM=0x1C00001F,
	DCERPC_NCA_S_INVALID_CRC=0x1C000020,
	DCERPC_NCA_S_FAULT_USER_DEFINED=0x1C000021,
	DCERPC_NCA_S_FAULT_TX_OPEN_FAILED=0x1C000022,
	DCERPC_NCA_S_FAULT_CODESET_CONV_ERROR=0x1C000023,
	DCERPC_NCA_S_FAULT_OBJECT_NOT_FOUND=0x1C000024,
	DCERPC_NCA_S_FAULT_NO_CLIENT_STUB=0x1C000025,
	DCERPC_FAULT_ACCESS_DENIED=0x00000005,
	DCERPC_FAULT_NO_CALL_ACTIVE=0x000006bd,
	DCERPC_FAULT_CANT_PERFORM=0x000006d8,
	DCERPC_FAULT_OUT_OF_RESOURCES=0x000006d9,
	DCERPC_FAULT_BAD_STUB_DATA=0x000006f7,
	DCERPC_FAULT_SEC_PKG_ERROR=0x00000721,
}/* [v1_enum] */;

template <> struct x_ndr_traits_t<dcerpc_nca_status> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 53> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<dcerpc_nca_status>(const dcerpc_nca_status &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<dcerpc_nca_status>(dcerpc_nca_status &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_nca_status(v);
	return __bpos;
}

const int DCERPC_FAULT_OP_RNG_ERROR = DCERPC_NCA_S_OP_RNG_ERROR;
const int DCERPC_FAULT_UNK_IF = DCERPC_NCA_S_UNKNOWN_IF;
const int DCERPC_FAULT_NDR = DCERPC_FAULT_BAD_STUB_DATA;
const int DCERPC_FAULT_INVALID_TAG = DCERPC_NCA_S_FAULT_INVALID_TAG;
const int DCERPC_FAULT_CONTEXT_MISMATCH = DCERPC_NCA_S_FAULT_CONTEXT_MISMATCH;
const int DCERPC_FAULT_OTHER = 0x00000001;
const int DCERPC_FAULT_TODO = 0x00000042;

struct dcerpc_fault {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 alloc_hint;
	uint16 context_id;
	uint8 cancel_count;
	dcerpc_nca_status status;
	uint32 _pad;
	// DATA_BLOB _pad;/* [flag(LIBNDR_FLAG_REMAINING)] */
};

template <> struct x_ndr_traits_t<dcerpc_fault> {
	using has_buffers = std::false_type;
	using ndr_ostr_type = x_ndr_type_struct;
};

#if 0
enum dcerpc_AuthType : uint8 {
	DCERPC_AUTH_TYPE_NONE=0,
	DCERPC_AUTH_TYPE_KRB5_1=1,
	DCERPC_AUTH_TYPE_SPNEGO=9,
	DCERPC_AUTH_TYPE_NTLMSSP=10,
	DCERPC_AUTH_TYPE_KRB5=16,
	DCERPC_AUTH_TYPE_DPA=17,
	DCERPC_AUTH_TYPE_MSN=18,
	DCERPC_AUTH_TYPE_DIGEST=21,
	DCERPC_AUTH_TYPE_SCHANNEL=68,
	DCERPC_AUTH_TYPE_MSMQ=100,
	DCERPC_AUTH_TYPE_NCALRPC_AS_SYSTEM=200,
}/* [enum8bit] */;

template <> struct x_ndr_traits_t<dcerpc_AuthType> {
	using ndr_ostr_type = x_ndr_ostr_type_enum;
	using ndr_base_type = uint8;
	static const std::array<std::pair<uint8, const char *>, 11> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_data<dcerpc_AuthType>(const dcerpc_AuthType &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint8(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<dcerpc_AuthType>(dcerpc_AuthType &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint8_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_AuthType(v);
	return __bpos;
}


enum dcerpc_AuthLevel : uint8 {
	DCERPC_AUTH_LEVEL_NONE=1,
	DCERPC_AUTH_LEVEL_CONNECT=2,
	DCERPC_AUTH_LEVEL_CALL=3,
	DCERPC_AUTH_LEVEL_PACKET=4,
	DCERPC_AUTH_LEVEL_INTEGRITY=5,
	DCERPC_AUTH_LEVEL_PRIVACY=6,
}/* [enum8bit] */;

template <> struct x_ndr_traits_t<dcerpc_AuthLevel> {
	using ndr_ostr_type = x_ndr_ostr_type_enum;
	using ndr_base_type = uint8;
	static const std::array<std::pair<uint8, const char *>, 6> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_data<dcerpc_AuthLevel>(const dcerpc_AuthLevel &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint8(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<dcerpc_AuthLevel>(dcerpc_AuthLevel &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint8_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_AuthLevel(v);
	return __bpos;
}

const uint8 DCERPC_AUTH_LEVEL_DEFAULT = DCERPC_AUTH_LEVEL_CONNECT;

struct dcerpc_auth {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dcerpc_AuthType auth_type;
	dcerpc_AuthLevel auth_level;
	uint8 auth_pad_length;
	uint8 auth_reserved;
	uint32 auth_context_id;
	DATA_BLOB credentials;/* [flag(LIBNDR_FLAG_REMAINING)] */
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_auth> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};

const uint8 DCERPC_AUTH_TRAILER_LENGTH = 8;
const uint8 DCERPC_AUTH_PAD_ALIGNMENT = 16;

struct dcerpc_auth3 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	DATA_BLOB auth_info;/* [flag(LIBNDR_FLAG_REMAINING)] */
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_auth3> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_orphaned {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	DATA_BLOB auth_info;/* [flag(LIBNDR_FLAG_REMAINING)] */
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_orphaned> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_co_cancel {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	DATA_BLOB auth_info;/* [flag(LIBNDR_FLAG_REMAINING)] */
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_co_cancel> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_cl_cancel {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 version;
	uint32 id;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_cl_cancel> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_cancel_ack {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 version;
	uint32 id;
	boolean32 server_is_accepting;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_cancel_ack> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_fack {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 version;
	uint8 _pad1;
	uint16 window_size;
	uint32 max_tdsu;
	uint32 max_frag_size;
	uint16 serial_no;
	std::vector<uint32> selack;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_fack> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_ack {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_ack> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_ping {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_ping> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_shutdown {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_shutdown> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_working {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_working> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct RTSCookie {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	GUID Cookie;
} /* [public] */;

template <> struct x_ndr_traits_t<RTSCookie> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


enum AddressType : uint32 {
	RTS_IPV4=0,
	RTS_IPV6=1,
}/* [v1_enum, public] */;

template <> struct x_ndr_traits_t<AddressType> {
	using ndr_ostr_type = x_ndr_ostr_type_enum;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 2> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_data<AddressType>(const AddressType &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<AddressType>(AddressType &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = AddressType(v);
	return __bpos;
}


union ClientAddressType
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	ipv4address ClientAddressIPV4;/* [case(RTS_IPV4)] */
	ipv6address ClientAddressIPV6;/* [case(RTS_IPV6)] */
} /* [nodiscriminant] */;

template <> struct x_ndr_traits_t<ClientAddressType> {
	using ndr_ostr_type = x_ndr_ostr_type_union;
};


struct ClientAddress {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	AddressType AddressType;
	ClientAddressType ClientAddress;/* [switch_is(AddressType)] */
	std::array<uint8, 12> Padding;
} /* [public] */;

template <> struct x_ndr_traits_t<ClientAddress> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


enum ForwardDestination : uint32 {
	FDClient=0,
	FDInProxy=1,
	FDServer=2,
	FDOutProxy=3,
}/* [v1_enum, public] */;

template <> struct x_ndr_traits_t<ForwardDestination> {
	using ndr_ostr_type = x_ndr_ostr_type_enum;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 4> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_data<ForwardDestination>(const ForwardDestination &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<ForwardDestination>(ForwardDestination &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = ForwardDestination(v);
	return __bpos;
}


struct FlowControlAcknowledgment {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 BytesReceived;
	uint32 AvailableWindow;
	RTSCookie ChannelCookie;
} /* [public] */;

template <> struct x_ndr_traits_t<FlowControlAcknowledgment> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_ReceiveWindowSize {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 ReceiveWindowSize;/* [range(0x2000,0x40000)] */
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_ReceiveWindowSize> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_FlowControlAck {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	FlowControlAcknowledgment Ack;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_FlowControlAck> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_ConnectionTimeout {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 ConnectionTimeout;/* [range(0x1D4C0,0xDBBA00)] */
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_ConnectionTimeout> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_Cookie {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	RTSCookie Cookie;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_Cookie> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_ChannelLifetime {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 ChannelLifetime;/* [range(0x20000,0x80000000)] */
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_ChannelLifetime> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_ClientKeepalive {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 ClientKeepalive;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_ClientKeepalive> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_Version {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 Version;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_Version> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_Empty {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_Empty> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_Padding {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<uint8> Padding;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_Padding> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_NegativeANCE {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_NegativeANCE> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_ANCE {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_ANCE> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_ClientAddress {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	ClientAddress ClientAddress;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_ClientAddress> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_AssociationGroupId {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	RTSCookie AssociationGroupId;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_AssociationGroupId> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_Destination {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	ForwardDestination ForwardDestination;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_Destination> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_rts_cmd_PingTrafficSentNotify {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 PingTrafficSent;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd_PingTrafficSentNotify> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


union dcerpc_rts_cmds
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dcerpc_rts_cmd_ReceiveWindowSize ReceiveWindowSize;/* [case(0x0)] */
	dcerpc_rts_cmd_FlowControlAck FlowControlAck;/* [case(0x1)] */
	dcerpc_rts_cmd_ConnectionTimeout ConnectionTimeout;/* [case(0x2)] */
	dcerpc_rts_cmd_Cookie Cookie;/* [case(0x3)] */
	dcerpc_rts_cmd_ChannelLifetime ChannelLifetime;/* [case(0x4)] */
	dcerpc_rts_cmd_ClientKeepalive ClientKeepalive;/* [case(0x5)] */
	dcerpc_rts_cmd_Version Version;/* [case(0x6)] */
	dcerpc_rts_cmd_Empty Empty;/* [case(0x7)] */
	dcerpc_rts_cmd_Padding Padding;/* [case(0x8)] */
	dcerpc_rts_cmd_NegativeANCE NegativeANCE;/* [case(0x9)] */
	dcerpc_rts_cmd_ANCE ANCE;/* [case(0xA)] */
	dcerpc_rts_cmd_ClientAddress ClientAddress;/* [case(0xB)] */
	dcerpc_rts_cmd_AssociationGroupId AssociationGroupId;/* [case(0xC)] */
	dcerpc_rts_cmd_Destination Destination;/* [case(0xD)] */
	dcerpc_rts_cmd_PingTrafficSentNotify PingTrafficSentNotify;/* [case(0xE)] */
} /* [nodiscriminant] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmds> {
	using ndr_ostr_type = x_ndr_ostr_type_union;
};


struct dcerpc_rts_cmd {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 CommandType;
	dcerpc_rts_cmds Command;/* [switch_is(CommandType)] */
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_cmd> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


enum dcerpc_rts_flags : uint16 {
	RTS_FLAG_NONE=0x0000,
	RTS_FLAG_PING=0x0001,
	RTS_FLAG_OTHER_CMD=0x0002,
	RTS_FLAG_RECYCLE_CHANNEL=0x0004,
	RTS_FLAG_IN_CHANNEL=0x0008,
	RTS_FLAG_OUT_CHANNEL=0x0010,
	RTS_FLAG_EOF=0x0020,
	RTS_FLAG_ECHO=0x0040,
}/* [bitmap16bit, public] */;

template <> struct x_ndr_traits_t<dcerpc_rts_flags> {
	using ndr_ostr_type = x_ndr_ostr_type_bitmap;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 8> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_data<dcerpc_rts_flags>(const dcerpc_rts_flags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint16(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<dcerpc_rts_flags>(dcerpc_rts_flags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_rts_flags(v);
	return __bpos;
}



struct dcerpc_rts {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dcerpc_rts_flags Flags;
	std::vector<dcerpc_rts_cmd> Commands;
} /* [public] */;

template <> struct x_ndr_traits_t<dcerpc_rts> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};
#endif

enum dcerpc_pkt_type : uint8 {
	DCERPC_PKT_REQUEST=0,
	DCERPC_PKT_PING=1,
	DCERPC_PKT_RESPONSE=2,
	DCERPC_PKT_FAULT=3,
	DCERPC_PKT_WORKING=4,
	DCERPC_PKT_NOCALL=5,
	DCERPC_PKT_REJECT=6,
	DCERPC_PKT_ACK=7,
	DCERPC_PKT_CL_CANCEL=8,
	DCERPC_PKT_FACK=9,
	DCERPC_PKT_CANCEL_ACK=10,
	DCERPC_PKT_BIND=11,
	DCERPC_PKT_BIND_ACK=12,
	DCERPC_PKT_BIND_NAK=13,
	DCERPC_PKT_ALTER=14,
	DCERPC_PKT_ALTER_RESP=15,
	DCERPC_PKT_AUTH3=16,
	DCERPC_PKT_SHUTDOWN=17,
	DCERPC_PKT_CO_CANCEL=18,
	DCERPC_PKT_ORPHANED=19,
	DCERPC_PKT_RTS=20,
}/* [enum8bit] */;

template <> struct x_ndr_traits_t<dcerpc_pkt_type> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint8;
	static const std::array<std::pair<uint8, const char *>, 21> value_name_map;
};
#if 0
template <> inline x_ndr_off_t x_ndr_data<dcerpc_pkt_type>(const dcerpc_pkt_type &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint8(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<dcerpc_pkt_type>(dcerpc_pkt_type &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint8_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_pkt_type(v);
	return __bpos;
}


union dcerpc_payload
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dcerpc_payload() { }
	~dcerpc_payload() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const dcerpc_payload &__other);
	void __uninit(x_ndr_switch_t __level);
	dcerpc_request request;/* [case(DCERPC_PKT_REQUEST)] */
	dcerpc_ping ping;/* [case(DCERPC_PKT_PING)] */
	dcerpc_response response;/* [case(DCERPC_PKT_RESPONSE)] */
	dcerpc_fault fault;/* [case(DCERPC_PKT_FAULT)] */
	dcerpc_working working;/* [case(DCERPC_PKT_WORKING)] */
	dcerpc_fack nocall;/* [case(DCERPC_PKT_NOCALL)] */
	dcerpc_fault reject;/* [case(DCERPC_PKT_REJECT)] */
	dcerpc_ack ack;/* [case(DCERPC_PKT_ACK)] */
	dcerpc_cl_cancel cl_cancel;/* [case(DCERPC_PKT_CL_CANCEL)] */
	dcerpc_fack fack;/* [case(DCERPC_PKT_FACK)] */
	dcerpc_cancel_ack cancel_ack;/* [case(DCERPC_PKT_CANCEL_ACK)] */
	dcerpc_bind bind;/* [case(DCERPC_PKT_BIND)] */
	dcerpc_bind_ack bind_ack;/* [case(DCERPC_PKT_BIND_ACK)] */
	dcerpc_bind_nak bind_nak;/* [case(DCERPC_PKT_BIND_NAK)] */
	dcerpc_bind alter;/* [case(DCERPC_PKT_ALTER)] */
	dcerpc_bind_ack alter_resp;/* [case(DCERPC_PKT_ALTER_RESP)] */
	dcerpc_shutdown shutdown;/* [case(DCERPC_PKT_SHUTDOWN)] */
	dcerpc_co_cancel co_cancel;/* [case(DCERPC_PKT_CO_CANCEL)] */
	dcerpc_orphaned orphaned;/* [case(DCERPC_PKT_ORPHANED)] */
	dcerpc_auth3 auth3;/* [case(DCERPC_PKT_AUTH3)] */
	dcerpc_rts rts;/* [case(DCERPC_PKT_RTS)] */
} /* [nodiscriminant] */;

template <> struct x_ndr_traits_t<dcerpc_payload> {
	using ndr_ostr_type = x_ndr_ostr_type_union;
};
#endif


enum dcerpc_pfc_flags : uint8 {
	DCERPC_PFC_FLAG_FIRST=0x01,
	DCERPC_PFC_FLAG_LAST=0x02,
	DCERPC_PFC_FLAG_PENDING_CANCEL_OR_HDR_SIGNING=0x04,
	DCERPC_PFC_FLAG_CONC_MPX=0x10,
	DCERPC_PFC_FLAG_DID_NOT_EXECUTE=0x20,
	DCERPC_PFC_FLAG_MAYBE=0x40,
	DCERPC_PFC_FLAG_OBJECT_UUID=0x80,
}/* [bitmap8bit] */;
#if 0
template <> struct x_ndr_traits_t<dcerpc_pfc_flags> {
	using ndr_ostr_type = x_ndr_ostr_type_bitmap;
	using ndr_base_type = uint8;
	static const std::array<std::pair<uint8, const char *>, 7> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_data<dcerpc_pfc_flags>(const dcerpc_pfc_flags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint8(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<dcerpc_pfc_flags>(dcerpc_pfc_flags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint8_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_pfc_flags(v);
	return __bpos;
}
#endif
const int DCERPC_PFC_FLAG_PENDING_CANCEL = DCERPC_PFC_FLAG_PENDING_CANCEL_OR_HDR_SIGNING;
const int DCERPC_PFC_FLAG_SUPPORT_HEADER_SIGN = DCERPC_PFC_FLAG_PENDING_CANCEL_OR_HDR_SIGNING;
const uint8 DCERPC_PFC_OFFSET = 3;
const uint8 DCERPC_DREP_OFFSET = 4;
const uint8 DCERPC_FRAG_LEN_OFFSET = 8;
const uint32 DCERPC_FRAG_MAX_SIZE = 5840;
const uint8 DCERPC_AUTH_LEN_OFFSET = 10;
const uint8 DCERPC_NCACN_PAYLOAD_OFFSET = 16;
const uint32 DCERPC_NCACN_REQUEST_DEFAULT_MAX_SIZE = 0x400000;
const uint32 DCERPC_NCACN_RESPONSE_DEFAULT_MAX_SIZE = 0xf000000;
const uint8 DCERPC_DREP_LE = 0x10;

#if 0
struct ncacn_packet {
	ncacn_packet();
	~ncacn_packet();
	ncacn_packet(const ncacn_packet& other);
	ncacn_packet &operator=(const ncacn_packet& other);
	void set_ptype(dcerpc_pkt_type v);
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint8 rpc_vers;
	uint8 rpc_vers_minor;
	dcerpc_pkt_type ptype;
	dcerpc_pfc_flags pfc_flags;
	std::array<uint8, 4> drep;
	uint16 frag_length;
	uint16 auth_length;
	uint32 call_id;
	dcerpc_payload u;/* [switch_is(ptype)] */
} /* [public] */;

template <> struct x_ndr_traits_t<ncacn_packet> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct ncadg_packet {
	ncadg_packet();
	~ncadg_packet();
	ncadg_packet(const ncadg_packet& other);
	ncadg_packet &operator=(const ncadg_packet& other);
	void set_ptype(uint8 v);
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint8 rpc_vers;
	uint8 ptype;
	uint8 pfc_flags;
	uint8 ncadg_flags;
	std::array<uint8, 3> drep;
	uint8 serial_high;
	GUID object;
	GUID iface;
	GUID activity;
	uint32 server_boot;
	uint32 iface_version;
	uint32 seq_num;
	uint16 opnum;
	uint16 ihint;
	uint16 ahint;
	uint16 len;
	uint16 fragnum;
	uint8 auth_proto;
	uint8 serial_low;
	dcerpc_payload u;/* [switch_is(ptype)] */
} /* [public] */;

template <> struct x_ndr_traits_t<ncadg_packet> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


enum dcerpc_sec_vt_command : uint16 {
	DCERPC_SEC_VT_COMMAND_ENUM=0x3FFF,
	DCERPC_SEC_VT_COMMAND_END=0x4000,
	DCERPC_SEC_VT_MUST_PROCESS=0x8000,
}/* [bitmap16bit] */;

template <> struct x_ndr_traits_t<dcerpc_sec_vt_command> {
	using ndr_ostr_type = x_ndr_ostr_type_bitmap;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 3> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_data<dcerpc_sec_vt_command>(const dcerpc_sec_vt_command &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint16(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<dcerpc_sec_vt_command>(dcerpc_sec_vt_command &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_sec_vt_command(v);
	return __bpos;
}



enum dcerpc_sec_vt_command_enum : uint16 {
	DCERPC_SEC_VT_COMMAND_BITMASK1=0x0001,
	DCERPC_SEC_VT_COMMAND_PCONTEXT=0x0002,
	DCERPC_SEC_VT_COMMAND_HEADER2=0x0003,
}/* [enum16bit] */;

template <> struct x_ndr_traits_t<dcerpc_sec_vt_command_enum> {
	using ndr_ostr_type = x_ndr_ostr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 3> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_data<dcerpc_sec_vt_command_enum>(const dcerpc_sec_vt_command_enum &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint16(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<dcerpc_sec_vt_command_enum>(dcerpc_sec_vt_command_enum &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_sec_vt_command_enum(v);
	return __bpos;
}


enum dcerpc_sec_vt_bitmask1 : uint32 {
	DCERPC_SEC_VT_CLIENT_SUPPORTS_HEADER_SIGNING=0x00000001,
}/* [bitmap32bit] */;

template <> struct x_ndr_traits_t<dcerpc_sec_vt_bitmask1> {
	using ndr_ostr_type = x_ndr_ostr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 1> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_data<dcerpc_sec_vt_bitmask1>(const dcerpc_sec_vt_bitmask1 &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_data<dcerpc_sec_vt_bitmask1>(dcerpc_sec_vt_bitmask1 &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_DATA(v, __ndr, __bpos, __epos, __flags, __level);
	__val = dcerpc_sec_vt_bitmask1(v);
	return __bpos;
}



struct dcerpc_sec_vt_pcontext {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	ndr_syntax_id abstract_syntax;
	ndr_syntax_id transfer_syntax;
} ;

template <> struct x_ndr_traits_t<dcerpc_sec_vt_pcontext> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_sec_vt_header2 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dcerpc_pkt_type ptype;
	std::array<uint8, 4> drep;
	uint32 call_id;
	uint16 context_id;
	uint16 opnum;
} ;

template <> struct x_ndr_traits_t<dcerpc_sec_vt_header2> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


union dcerpc_sec_vt_union
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dcerpc_sec_vt_union() { }
	~dcerpc_sec_vt_union() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const dcerpc_sec_vt_union &__other);
	void __uninit(x_ndr_switch_t __level);
	dcerpc_sec_vt_bitmask1 bitmask1;/* [case(DCERPC_SEC_VT_COMMAND_BITMASK1)] */
	dcerpc_sec_vt_pcontext pcontext;/* [case(DCERPC_SEC_VT_COMMAND_PCONTEXT)] */
	dcerpc_sec_vt_header2 header2;/* [case(DCERPC_SEC_VT_COMMAND_HEADER2)] */
	DATA_BLOB _unknown;/* [flag(LIBNDR_FLAG_REMAINING), default] */
} /* [nodiscriminant, switch_type(dcerpc_sec_vt_command_enum)] */;

template <> struct x_ndr_traits_t<dcerpc_sec_vt_union> {
	using ndr_ostr_type = x_ndr_ostr_type_union;
};


struct dcerpc_sec_vt {
	dcerpc_sec_vt();
	~dcerpc_sec_vt();
	dcerpc_sec_vt(const dcerpc_sec_vt& other);
	dcerpc_sec_vt &operator=(const dcerpc_sec_vt& other);
	void set_command(dcerpc_sec_vt_command v);
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dcerpc_sec_vt_command command;
	dcerpc_sec_vt_union u;/* [subcontext(2), switch_is(command&DCERPC_SEC_VT_COMMAND_ENUM), flag(LIBNDR_FLAG_SUBCONTEXT_NO_UNREAD_BYTES)] */
} ;

template <> struct x_ndr_traits_t<dcerpc_sec_vt> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};


struct dcerpc_sec_vt_count {
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint16 count;
} /* [nopush, public, nopull] */;

template <> struct x_ndr_traits_t<dcerpc_sec_vt_count> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};

const uint16 DCERPC_SEC_VT_MAX_SIZE = 1024;

struct dcerpc_sec_verification_trailer {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	DATA_BLOB _pad;/* [flag(LIBNDR_FLAG_ALIGN4)] */
	dcerpc_sec_vt_count count;
	std::vector<dcerpc_sec_vt> commands;
} /* [public, flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<dcerpc_sec_verification_trailer> {
	using ndr_ostr_type = x_ndr_ostr_type_struct;
};
#endif
#endif /* _HEADER_dcerpc */
} /* namespace idl */

#endif /* _PIDL_HEADER_dcerpc */

