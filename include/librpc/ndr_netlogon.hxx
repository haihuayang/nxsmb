/* header auto-generated by pidl */
#ifndef _PIDL_HEADER_netlogon
#define _PIDL_HEADER_netlogon
#include "include/librpc/ndr.hxx"

// #include "librpc/idl/misc.h"
#include "include/librpc/ndr_lsa.hxx"
#include "include/librpc/ndr_samr.hxx"
// #include "librpc/idl/security.h"

namespace idl {
#define netr_DeltaEnum8Bit netr_DeltaEnum

#define netr_SamDatabaseID8Bit netr_SamDatabaseID

#define ENC_CRC32 KERB_ENCTYPE_DES_CBC_CRC

#define ENC_RSA_MD5 KERB_ENCTYPE_DES_CBC_MD5

#define ENC_RC4_HMAC_MD5 KERB_ENCTYPE_RC4_HMAC_MD5

#define ENC_HMAC_SHA1_96_AES128 KERB_ENCTYPE_AES128_CTS_HMAC_SHA1_96

#define ENC_HMAC_SHA1_96_AES256 KERB_ENCTYPE_AES256_CTS_HMAC_SHA1_96

#ifndef _HEADER_netlogon
#define _HEADER_netlogon

struct netr_UasInfo {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	u16string account_name;/* [string, charset(UTF16)] */
	uint32 priv;
	uint32 auth_flags;
	uint32 logon_count;
	uint32 bad_pw_count;
	time_t last_logon;
	time_t last_logoff;
	time_t logoff_time;
	time_t kickoff_time;
	uint32 password_age;
	time_t pw_can_change;
	time_t pw_must_change;
	u16string computer;/* [string, charset(UTF16)] */
	u16string domain;/* [string, charset(UTF16)] */
	u16string script_path;/* [string, charset(UTF16)] */
	uint32 unknown;
} ;

template <> struct x_ndr_traits_t<netr_UasInfo> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_UasLogoffInfo {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 duration;
	uint16 logon_count;
} ;

template <> struct x_ndr_traits_t<netr_UasLogoffInfo> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_AcctLockStr {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	dlong lockout_duration;
	udlong reset_count;
	uint32 bad_attempt_lockout;
	uint32 dummy;
} /* [public] */;

template <> struct x_ndr_traits_t<netr_AcctLockStr> {
	using ndr_type = x_ndr_type_struct;
};


enum netr_LogonParameterControl : uint32 {
	MSV1_0_CLEARTEXT_PASSWORD_ALLOWED=0x00000002,
	MSV1_0_UPDATE_LOGON_STATISTICS=0x00000004,
	MSV1_0_RETURN_USER_PARAMETERS=0x00000008,
	MSV1_0_DONT_TRY_GUEST_ACCOUNT=0x00000010,
	MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT=0x00000020,
	MSV1_0_RETURN_PASSWORD_EXPIRY=0x00000040,
	MSV1_0_USE_CLIENT_CHALLENGE=0x00000080,
	MSV1_0_TRY_GUEST_ACCOUNT_ONLY=0x00000100,
	MSV1_0_RETURN_PROFILE_PATH=0x00000200,
	MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY=0x00000400,
	MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT=0x00000800,
	MSV1_0_DISABLE_PERSONAL_FALLBACK=0x00001000,
	MSV1_0_ALLOW_FORCE_GUEST=0x00002000,
	MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED=0x00004000,
	MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY=0x00008000,
	MSV1_0_ALLOW_MSVCHAPV2=0x00010000,
	MSV1_0_S4U2SELF=0x00020000,
	MSV1_0_CHECK_LOGONHOURS_FOR_S4U=0x00040000,
	MSV1_0_SUBAUTHENTICATION_DLL_EX=0x00100000,
}/* [bitmap32bit, public] */;

template <> struct x_ndr_traits_t<netr_LogonParameterControl> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 19> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_LogonParameterControl>(const netr_LogonParameterControl &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_LogonParameterControl>(netr_LogonParameterControl &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_LogonParameterControl(v);
	return __bpos;
}



struct netr_IdentityInfo {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	lsa_String domain_name;
	netr_LogonParameterControl parameter_control;
	uint32 logon_id_low;
	uint32 logon_id_high;
	lsa_String account_name;
	lsa_String workstation;
} ;

template <> struct x_ndr_traits_t<netr_IdentityInfo> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_PasswordInfo {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_IdentityInfo identity_info;
	samr_Password lmpassword;
	samr_Password ntpassword;
} ;

template <> struct x_ndr_traits_t<netr_PasswordInfo> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_ChallengeResponse {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<uint8> data;/* [length_is(length), size_is(length)] */
} /* [flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<netr_ChallengeResponse> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_NetworkInfo {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_IdentityInfo identity_info;
	std::array<uint8, 8> challenge;
	netr_ChallengeResponse nt;
	netr_ChallengeResponse lm;
} /* [flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<netr_NetworkInfo> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_GenericInfo {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_IdentityInfo identity_info;
	lsa_String package_name;
	std::vector<uint8> data;/* [size_is(length)] */
} /* [flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<netr_GenericInfo> {
	using ndr_type = x_ndr_type_struct;
};


enum netr_LogonInfoClass : uint16 {
	NetlogonInteractiveInformation=1,
	NetlogonNetworkInformation=2,
	NetlogonServiceInformation=3,
	NetlogonGenericInformation=4,
	NetlogonInteractiveTransitiveInformation=5,
	NetlogonNetworkTransitiveInformation=6,
	NetlogonServiceTransitiveInformation=7,
};

template <> struct x_ndr_traits_t<netr_LogonInfoClass> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 7> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_LogonInfoClass>(const netr_LogonInfoClass &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint1632(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_LogonInfoClass>(netr_LogonInfoClass &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_LogonInfoClass(v);
	return __bpos;
}


union netr_LogonLevel
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_LogonLevel() { }
	~netr_LogonLevel() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const netr_LogonLevel &__other);
	void __uninit(x_ndr_switch_t __level);
	std::shared_ptr<netr_PasswordInfo> password;/* [case(NetlogonInteractiveInformation)] */
	std::shared_ptr<netr_NetworkInfo> network;/* [case(NetlogonNetworkInformation)] */
	std::shared_ptr<netr_GenericInfo> generic;/* [case(NetlogonGenericInformation)] */
} /* [public, switch_type(netr_LogonInfoClass)] */;

template <> struct x_ndr_traits_t<netr_LogonLevel> {
	using ndr_type = x_ndr_type_union;
};


struct netr_UserSessionKey {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const {
		X_ASSERT(__level == X_NDR_SWITCH_NONE);
		return x_ndr_push_bytes(key.data(), __ndr, __bpos, __epos, 16);
	}
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) {
		X_ASSERT(__level == X_NDR_SWITCH_NONE);
		return x_ndr_pull_bytes(key.data(), __ndr, __bpos, __epos, 16);
	}
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const {
		x_ndr_ostr_bytes(key.data(), __ndr, 16);
	}
	std::array<uint8, 16> key;
} /* [public, flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<netr_UserSessionKey> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_LMSessionKey {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const {
		X_ASSERT(__level == X_NDR_SWITCH_NONE);
		return x_ndr_push_bytes(key.data(), __ndr, __bpos, __epos, 8);
	}
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) {
		X_ASSERT(__level == X_NDR_SWITCH_NONE);
		return x_ndr_pull_bytes(key.data(), __ndr, __bpos, __epos, 8);
	}
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const {
		x_ndr_ostr_bytes(key.data(), __ndr, 8);
	}
	std::array<uint8, 8> key;
} /* [public, flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<netr_LMSessionKey> {
	using ndr_type = x_ndr_type_struct;
};


enum netr_UserFlags : uint32 {
	NETLOGON_GUEST=0x00000001,
	NETLOGON_NOENCRYPTION=0x00000002,
	NETLOGON_CACHED_ACCOUNT=0x00000004,
	NETLOGON_USED_LM_PASSWORD=0x00000008,
	NETLOGON_EXTRA_SIDS=0x00000020,
	NETLOGON_SUBAUTH_SESSION_KEY=0x00000040,
	NETLOGON_SERVER_TRUST_ACCOUNT=0x00000080,
	NETLOGON_NTLMV2_ENABLED=0x00000100,
	NETLOGON_RESOURCE_GROUPS=0x00000200,
	NETLOGON_PROFILE_PATH_RETURNED=0x00000400,
	NETLOGON_GRACE_LOGON=0x01000000,
}/* [bitmap32bit, public] */;

template <> struct x_ndr_traits_t<netr_UserFlags> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 11> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_UserFlags>(const netr_UserFlags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_UserFlags>(netr_UserFlags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_UserFlags(v);
	return __bpos;
}



struct netr_SamBaseInfo {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	x_ndr_off_t ndr_buffers(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_buffers(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	NTTIME logon_time;
	NTTIME logoff_time;
	NTTIME kickoff_time;
	NTTIME last_password_change;
	NTTIME allow_password_change;
	NTTIME force_password_change;
	lsa_String account_name;
	lsa_String full_name;
	lsa_String logon_script;
	lsa_String profile_path;
	lsa_String home_directory;
	lsa_String home_drive;
	uint16 logon_count;
	uint16 bad_password_count;
	uint32 rid;
	uint32 primary_gid;
	samr_RidWithAttributeArray groups;
	netr_UserFlags user_flags;
	netr_UserSessionKey key;
	lsa_StringLarge logon_server;
	lsa_StringLarge logon_domain;
	x_ndr_unique_ptr_t<dom_sid2> domain_sid;
	netr_LMSessionKey LMSessKey;
	samr_AcctFlags acct_flags;
	uint32 sub_auth_status;
	NTTIME last_successful_logon;
	NTTIME last_failed_logon;
	uint32 failed_logon_count;
} ;

template <> struct x_ndr_traits_t<netr_SamBaseInfo> {
	using has_buffers = std::true_type;
	using ndr_type = x_ndr_type_struct;
};


struct netr_SamInfo2 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_SamBaseInfo base;
} ;

template <> struct x_ndr_traits_t<netr_SamInfo2> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_SidAttr {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	x_ndr_off_t ndr_buffers(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_buffers(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_unique_ptr_t<dom_sid2> sid;
	samr_GroupAttrs attributes;
} ;

template <> struct x_ndr_traits_t<netr_SidAttr> {
	using has_buffers = std::true_type;
	using ndr_type = x_ndr_type_struct;
};


struct netr_SamInfo3 {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	x_ndr_off_t ndr_buffers(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_buffers(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_SamBaseInfo base;
	x_ndr_vector_unique_ptr_t<netr_SidAttr> sids;/* [size_is(sidcount)] */
} /* [public] */;

template <> struct x_ndr_traits_t<netr_SamInfo3> {
	using has_buffers = std::true_type;
	using ndr_type = x_ndr_type_struct;
};

struct netr_SamInfo6 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_SamBaseInfo base;
	std::vector<netr_SidAttr> sids;/* [size_is(sidcount)] */
	lsa_String dns_domainname;
	lsa_String principle;
	std::array<uint32, 20> unknown4;
} ;

template <> struct x_ndr_traits_t<netr_SamInfo6> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_PacInfo {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<uint8> pac;/* [size_is(pac_size)] */
	lsa_String logon_domain;
	lsa_String logon_server;
	lsa_String principal_name;
	std::vector<uint8> auth;/* [size_is(auth_size)] */
	netr_UserSessionKey user_session_key;
	std::array<uint32, 10> expansionroom;
	lsa_String unknown1;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
} ;

template <> struct x_ndr_traits_t<netr_PacInfo> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_GenericInfo2 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<uint8> data;/* [size_is(length)] */
} /* [flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<netr_GenericInfo2> {
	using ndr_type = x_ndr_type_struct;
};


enum netr_ValidationInfoClass : uint16 {
	NetlogonValidationUasInfo=1,
	NetlogonValidationSamInfo=2,
	NetlogonValidationSamInfo2=3,
	NetlogonValidationGenericInfo2=5,
	NetlogonValidationSamInfo4=6,
};

template <> struct x_ndr_traits_t<netr_ValidationInfoClass> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 5> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_ValidationInfoClass>(const netr_ValidationInfoClass &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint1632(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_ValidationInfoClass>(netr_ValidationInfoClass &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_ValidationInfoClass(v);
	return __bpos;
}


union netr_Validation
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_Validation() { }
	~netr_Validation() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const netr_Validation &__other);
	void __uninit(x_ndr_switch_t __level);
	std::shared_ptr<netr_SamInfo2> sam2;/* [case(NetlogonValidationSamInfo)] */
	std::shared_ptr<netr_SamInfo3> sam3;/* [case(NetlogonValidationSamInfo2)] */
	std::shared_ptr<netr_PacInfo> pac;/* [case(4)] */
	std::shared_ptr<netr_GenericInfo2> generic;/* [case(NetlogonValidationGenericInfo2)] */
	std::shared_ptr<netr_SamInfo6> sam6;/* [case(NetlogonValidationSamInfo4)] */
} /* [public, switch_type(uint16)] */;

template <> struct x_ndr_traits_t<netr_Validation> {
	using ndr_type = x_ndr_type_union;
};


struct netr_Credential {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::array<uint8, 8> data;
} /* [public, flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<netr_Credential> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_Authenticator {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_Credential cred;
	time_t timestamp;
} /* [public] */;

template <> struct x_ndr_traits_t<netr_Authenticator> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_DELETE_USER {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	u16string account_name;/* [string, charset(UTF16)] */
	lsa_String unknown1;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
	uint32 unknown5;
	uint32 unknown6;
	uint32 unknown7;
	uint32 unknown8;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_DELETE_USER> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_USER_KEY16 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint16 length;
	uint32 flags;
	samr_Password pwd;
} ;

template <> struct x_ndr_traits_t<netr_USER_KEY16> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_PasswordHistory {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 nt_flags;
	uint32 lm_flags;
	std::vector<uint8> nt_history;
	std::vector<uint8> lm_history;
} ;

template <> struct x_ndr_traits_t<netr_PasswordHistory> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_USER_KEYS2 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_USER_KEY16 lmpassword;
	netr_USER_KEY16 ntpassword;
	netr_PasswordHistory history;
} ;

template <> struct x_ndr_traits_t<netr_USER_KEYS2> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_USER_KEY_UNION {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_USER_KEYS2 keys2;
} ;

template <> struct x_ndr_traits_t<netr_USER_KEY_UNION> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_USER_KEYS {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 version;
	netr_USER_KEY_UNION keys;
} /* [public] */;

template <> struct x_ndr_traits_t<netr_USER_KEYS> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_USER_PRIVATE_INFO {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint8 SensitiveDataFlag;
	std::vector<uint8> SensitiveData;/* [flag(LIBNDR_PRINT_ARRAY_HEX), size_is(DataLength)] */
} ;

template <> struct x_ndr_traits_t<netr_USER_PRIVATE_INFO> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_USER {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	lsa_String account_name;
	lsa_String full_name;
	uint32 rid;
	uint32 primary_gid;
	lsa_String home_directory;
	lsa_String home_drive;
	lsa_String logon_script;
	lsa_String description;
	lsa_String workstations;
	NTTIME last_logon;
	NTTIME last_logoff;
	samr_LogonHours logon_hours;
	uint16 bad_password_count;
	uint16 logon_count;
	NTTIME last_password_change;
	NTTIME acct_expiry;
	samr_AcctFlags acct_flags;
	samr_Password lmpassword;
	samr_Password ntpassword;
	uint8 nt_password_present;
	uint8 lm_password_present;
	uint8 password_expired;
	lsa_String comment;
	lsa_BinaryString parameters;
	uint16 country_code;
	uint16 code_page;
	netr_USER_PRIVATE_INFO user_private_info;
	uint32 SecurityInformation;
	sec_desc_buf sdbuf;
	lsa_String profile_path;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
	uint32 unknown5;
	uint32 unknown6;
	uint32 unknown7;
	uint32 unknown8;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_USER> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_DOMAIN {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	lsa_String domain_name;
	lsa_String oem_information;
	dlong force_logoff_time;
	uint16 min_password_length;
	uint16 password_history_length;
	dlong max_password_age;
	dlong min_password_age;
	udlong sequence_num;
	NTTIME domain_create_time;
	uint32 SecurityInformation;
	sec_desc_buf sdbuf;
	lsa_BinaryString account_lockout;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
	uint32 logon_to_chgpass;
	uint32 unknown6;
	uint32 unknown7;
	uint32 unknown8;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_DOMAIN> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_GROUP {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	lsa_String group_name;
	uint32 rid;
	uint32 attributes;
	lsa_String description;
	uint32 SecurityInformation;
	sec_desc_buf sdbuf;
	lsa_String unknown1;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
	uint32 unknown5;
	uint32 unknown6;
	uint32 unknown7;
	uint32 unknown8;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_GROUP> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_RENAME {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	lsa_String OldName;
	lsa_String NewName;
	lsa_String unknown1;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
	uint32 unknown5;
	uint32 unknown6;
	uint32 unknown7;
	uint32 unknown8;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_RENAME> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_GROUP_MEMBER {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<uint32> rids;/* [size_is(num_rids)] */
	std::vector<uint32> attribs;/* [size_is(num_rids)] */
	uint32 unknown1;
	uint32 unknown2;
	uint32 unknown3;
	uint32 unknown4;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_GROUP_MEMBER> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_ALIAS {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	lsa_String alias_name;
	uint32 rid;
	uint32 SecurityInformation;
	sec_desc_buf sdbuf;
	lsa_String description;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
	uint32 unknown5;
	uint32 unknown6;
	uint32 unknown7;
	uint32 unknown8;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_ALIAS> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_ALIAS_MEMBER {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	lsa_SidArray sids;
	uint32 unknown1;
	uint32 unknown2;
	uint32 unknown3;
	uint32 unknown4;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_ALIAS_MEMBER> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_QUOTA_LIMITS {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 pagedpoollimit;
	uint32 nonpagedpoollimit;
	uint32 minimumworkingsetsize;
	uint32 maximumworkingsetsize;
	uint32 pagefilelimit;
	NTTIME timelimit;
} ;

template <> struct x_ndr_traits_t<netr_QUOTA_LIMITS> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_POLICY {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 maxlogsize;
	NTTIME auditretentionperiod;
	uint8 auditingmode;
	uint32 maxauditeventcount;
	std::vector<uint32> eventauditoptions;/* [size_is(maxauditeventcount+1)] */
	lsa_String primary_domain_name;
	std::shared_ptr<dom_sid2> sid;
	netr_QUOTA_LIMITS quota_limits;
	udlong sequence_num;
	NTTIME db_create_time;
	uint32 SecurityInformation;
	sec_desc_buf sdbuf;
	lsa_String unknown1;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
	uint32 unknown5;
	uint32 unknown6;
	uint32 unknown7;
	uint32 unknown8;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_POLICY> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_TRUSTED_DOMAIN {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	lsa_String domain_name;
	std::vector<lsa_String> controller_names;/* [size_is(num_controllers)] */
	uint32 SecurityInformation;
	sec_desc_buf sdbuf;
	lsa_String unknown1;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
	uint32 posix_offset;
	uint32 unknown6;
	uint32 unknown7;
	uint32 unknown8;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_TRUSTED_DOMAIN> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_ACCOUNT {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 privilege_control;
	std::vector<uint32> privilege_attrib;/* [size_is(privilege_entries)] */
	std::vector<lsa_String> privilege_name;/* [size_is(privilege_entries)] */
	netr_QUOTA_LIMITS quotalimits;
	uint32 system_flags;
	uint32 SecurityInformation;
	sec_desc_buf sdbuf;
	lsa_String unknown1;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
	uint32 unknown5;
	uint32 unknown6;
	uint32 unknown7;
	uint32 unknown8;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_ACCOUNT> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_CIPHER_VALUE {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 len;
	std::vector<uint8> cipher_data;/* [length_is(len), size_is(maxlen)] */
} ;

template <> struct x_ndr_traits_t<netr_CIPHER_VALUE> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_SECRET {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_CIPHER_VALUE current_cipher;
	NTTIME current_cipher_set_time;
	netr_CIPHER_VALUE old_cipher;
	NTTIME old_cipher_set_time;
	uint32 SecurityInformation;
	sec_desc_buf sdbuf;
	lsa_String unknown1;
	lsa_String unknown2;
	lsa_String unknown3;
	lsa_String unknown4;
	uint32 unknown5;
	uint32 unknown6;
	uint32 unknown7;
	uint32 unknown8;
} ;

template <> struct x_ndr_traits_t<netr_DELTA_SECRET> {
	using ndr_type = x_ndr_type_struct;
};


enum netr_DeltaEnum : uint16 {
	NETR_DELTA_DOMAIN=1,
	NETR_DELTA_GROUP=2,
	NETR_DELTA_DELETE_GROUP=3,
	NETR_DELTA_RENAME_GROUP=4,
	NETR_DELTA_USER=5,
	NETR_DELTA_DELETE_USER=6,
	NETR_DELTA_RENAME_USER=7,
	NETR_DELTA_GROUP_MEMBER=8,
	NETR_DELTA_ALIAS=9,
	NETR_DELTA_DELETE_ALIAS=10,
	NETR_DELTA_RENAME_ALIAS=11,
	NETR_DELTA_ALIAS_MEMBER=12,
	NETR_DELTA_POLICY=13,
	NETR_DELTA_TRUSTED_DOMAIN=14,
	NETR_DELTA_DELETE_TRUST=15,
	NETR_DELTA_ACCOUNT=16,
	NETR_DELTA_DELETE_ACCOUNT=17,
	NETR_DELTA_SECRET=18,
	NETR_DELTA_DELETE_SECRET=19,
	NETR_DELTA_DELETE_GROUP2=20,
	NETR_DELTA_DELETE_USER2=21,
	NETR_DELTA_MODIFY_COUNT=22,
};

template <> struct x_ndr_traits_t<netr_DeltaEnum> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 22> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_DeltaEnum>(const netr_DeltaEnum &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint1632(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_DeltaEnum>(netr_DeltaEnum &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_DeltaEnum(v);
	return __bpos;
}


union netr_DELTA_UNION
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_DELTA_UNION() { }
	~netr_DELTA_UNION() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const netr_DELTA_UNION &__other);
	void __uninit(x_ndr_switch_t __level);
	std::shared_ptr<netr_DELTA_DOMAIN> domain;/* [case(NETR_DELTA_DOMAIN)] */
	std::shared_ptr<netr_DELTA_GROUP> group;/* [case(NETR_DELTA_GROUP)] */
	std::shared_ptr<netr_DELTA_RENAME> rename_group;/* [case(NETR_DELTA_RENAME_GROUP)] */
	std::shared_ptr<netr_DELTA_USER> user;/* [case(NETR_DELTA_USER)] */
	std::shared_ptr<netr_DELTA_RENAME> rename_user;/* [case(NETR_DELTA_RENAME_USER)] */
	std::shared_ptr<netr_DELTA_GROUP_MEMBER> group_member;/* [case(NETR_DELTA_GROUP_MEMBER)] */
	std::shared_ptr<netr_DELTA_ALIAS> alias;/* [case(NETR_DELTA_ALIAS)] */
	std::shared_ptr<netr_DELTA_RENAME> rename_alias;/* [case(NETR_DELTA_RENAME_ALIAS)] */
	std::shared_ptr<netr_DELTA_ALIAS_MEMBER> alias_member;/* [case(NETR_DELTA_ALIAS_MEMBER)] */
	std::shared_ptr<netr_DELTA_POLICY> policy;/* [case(NETR_DELTA_POLICY)] */
	std::shared_ptr<netr_DELTA_TRUSTED_DOMAIN> trusted_domain;/* [case(NETR_DELTA_TRUSTED_DOMAIN)] */
	std::shared_ptr<netr_DELTA_ACCOUNT> account;/* [case(NETR_DELTA_ACCOUNT)] */
	std::shared_ptr<netr_DELTA_SECRET> secret;/* [case(NETR_DELTA_SECRET)] */
	std::shared_ptr<netr_DELTA_DELETE_USER> delete_group;/* [case(NETR_DELTA_DELETE_GROUP2)] */
	std::shared_ptr<netr_DELTA_DELETE_USER> delete_user;/* [case(NETR_DELTA_DELETE_USER2)] */
	std::shared_ptr<udlong> modified_count;/* [case(NETR_DELTA_MODIFY_COUNT)] */
} /* [switch_type(netr_DeltaEnum)] */;

template <> struct x_ndr_traits_t<netr_DELTA_UNION> {
	using ndr_type = x_ndr_type_union;
};


union netr_DELTA_ID_UNION
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_DELTA_ID_UNION() { }
	~netr_DELTA_ID_UNION() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const netr_DELTA_ID_UNION &__other);
	void __uninit(x_ndr_switch_t __level);
	uint32 rid;/* [case(NETR_DELTA_DOMAIN)] */
	std::shared_ptr<dom_sid2> sid;/* [case(NETR_DELTA_POLICY)] */
	u16string name;/* [charset(UTF16), string, case(NETR_DELTA_SECRET)] */
} /* [switch_type(netr_DeltaEnum)] */;

template <> struct x_ndr_traits_t<netr_DELTA_ID_UNION> {
	using ndr_type = x_ndr_type_union;
};


struct netr_DELTA_ENUM {
	netr_DELTA_ENUM();
	~netr_DELTA_ENUM();
	netr_DELTA_ENUM(const netr_DELTA_ENUM& other);
	netr_DELTA_ENUM &operator=(const netr_DELTA_ENUM& other);
	void set_delta_type(netr_DeltaEnum v);
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_DeltaEnum delta_type;
	netr_DELTA_ID_UNION delta_id_union;/* [switch_is(delta_type)] */
	netr_DELTA_UNION delta_union;/* [switch_is(delta_type)] */
} ;

template <> struct x_ndr_traits_t<netr_DELTA_ENUM> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DELTA_ENUM_ARRAY {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<netr_DELTA_ENUM> delta_enum;/* [size_is(num_deltas)] */
} ;

template <> struct x_ndr_traits_t<netr_DELTA_ENUM_ARRAY> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_UAS_INFO_0 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::array<uint8, 16> computer_name;
	uint32 timecreated;
	uint32 serial_number;
} /* [flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<netr_UAS_INFO_0> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_AccountBuffer {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	DATA_BLOB blob;/* [flag(LIBNDR_FLAG_REMAINING)] */
} ;

template <> struct x_ndr_traits_t<netr_AccountBuffer> {
	using ndr_type = x_ndr_type_struct;
};


enum netr_InfoFlags : uint32 {
	NETLOGON_REPLICATION_NEEDED=0x00000001,
	NETLOGON_REPLICATION_IN_PROGRESS=0x00000002,
	NETLOGON_FULL_SYNC_REPLICATION=0x00000004,
	NETLOGON_REDO_NEEDED=0x00000008,
	NETLOGON_HAS_IP=0x00000010,
	NETLOGON_HAS_TIMESERV=0x00000020,
	NETLOGON_DNS_UPDATE_FAILURE=0x00000040,
	NETLOGON_VERIFY_STATUS_RETURNED=0x00000080,
}/* [bitmap32bit] */;

template <> struct x_ndr_traits_t<netr_InfoFlags> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 8> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_InfoFlags>(const netr_InfoFlags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_InfoFlags>(netr_InfoFlags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_InfoFlags(v);
	return __bpos;
}



struct netr_NETLOGON_INFO_1 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_InfoFlags flags;
	WERROR pdc_connection_status;
} ;

template <> struct x_ndr_traits_t<netr_NETLOGON_INFO_1> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_NETLOGON_INFO_2 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_InfoFlags flags;
	WERROR pdc_connection_status;
	u16string trusted_dc_name;/* [string, charset(UTF16)] */
	WERROR tc_connection_status;
} ;

template <> struct x_ndr_traits_t<netr_NETLOGON_INFO_2> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_NETLOGON_INFO_3 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_InfoFlags flags;
	uint32 logon_attempts;
	uint32 unknown1;
	uint32 unknown2;
	uint32 unknown3;
	uint32 unknown4;
	uint32 unknown5;
} ;

template <> struct x_ndr_traits_t<netr_NETLOGON_INFO_3> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_NETLOGON_INFO_4 {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	u16string trusted_dc_name;/* [string, charset(UTF16)] */
	u16string trusted_domain_name;/* [string, charset(UTF16)] */
} ;

template <> struct x_ndr_traits_t<netr_NETLOGON_INFO_4> {
	using ndr_type = x_ndr_type_struct;
};


union netr_CONTROL_QUERY_INFORMATION
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_CONTROL_QUERY_INFORMATION() { }
	~netr_CONTROL_QUERY_INFORMATION() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const netr_CONTROL_QUERY_INFORMATION &__other);
	void __uninit(x_ndr_switch_t __level);
	std::shared_ptr<netr_NETLOGON_INFO_1> info1;/* [case] */
	std::shared_ptr<netr_NETLOGON_INFO_2> info2;/* [case(2)] */
	std::shared_ptr<netr_NETLOGON_INFO_3> info3;/* [case(3)] */
	std::shared_ptr<netr_NETLOGON_INFO_4> info4;/* [case(4)] */
} /* [public] */;

template <> struct x_ndr_traits_t<netr_CONTROL_QUERY_INFORMATION> {
	using ndr_type = x_ndr_type_union;
};


enum netr_LogonControlCode : uint32 {
	NETLOGON_CONTROL_QUERY=0x00000001,
	NETLOGON_CONTROL_REPLICATE=0x00000002,
	NETLOGON_CONTROL_SYNCHRONIZE=0x00000003,
	NETLOGON_CONTROL_PDC_REPLICATE=0x00000004,
	NETLOGON_CONTROL_REDISCOVER=0x00000005,
	NETLOGON_CONTROL_TC_QUERY=0x00000006,
	NETLOGON_CONTROL_TRANSPORT_NOTIFY=0x00000007,
	NETLOGON_CONTROL_FIND_USER=0x00000008,
	NETLOGON_CONTROL_CHANGE_PASSWORD=0x00000009,
	NETLOGON_CONTROL_TC_VERIFY=0x0000000A,
	NETLOGON_CONTROL_FORCE_DNS_REG=0x0000000B,
	NETLOGON_CONTROL_QUERY_DNS_REG=0x0000000C,
	NETLOGON_CONTROL_BACKUP_CHANGE_LOG=0x0000FFFC,
	NETLOGON_CONTROL_TRUNCATE_LOG=0x0000FFFD,
	NETLOGON_CONTROL_SET_DBFLAG=0x0000FFFE,
	NETLOGON_CONTROL_BREAKPOINT=0x0000FFFF,
}/* [v1_enum, public] */;

template <> struct x_ndr_traits_t<netr_LogonControlCode> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 16> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_LogonControlCode>(const netr_LogonControlCode &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_LogonControlCode>(netr_LogonControlCode &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_LogonControlCode(v);
	return __bpos;
}


union netr_CONTROL_DATA_INFORMATION
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_CONTROL_DATA_INFORMATION() { }
	~netr_CONTROL_DATA_INFORMATION() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const netr_CONTROL_DATA_INFORMATION &__other);
	void __uninit(x_ndr_switch_t __level);
	u16string domain;/* [charset(UTF16), string, case(NETLOGON_CONTROL_REDISCOVER)] */
	u16string user;/* [charset(UTF16), string, case(NETLOGON_CONTROL_FIND_USER)] */
	uint32 debug_level;/* [case(NETLOGON_CONTROL_SET_DBFLAG)] */
} /* [public, switch_type(netr_LogonControlCode)] */;

template <> struct x_ndr_traits_t<netr_CONTROL_DATA_INFORMATION> {
	using ndr_type = x_ndr_type_union;
};


enum netr_NegotiateFlags : uint32 {
	NETLOGON_NEG_ACCOUNT_LOCKOUT=0x00000001,
	NETLOGON_NEG_PERSISTENT_SAMREPL=0x00000002,
	NETLOGON_NEG_ARCFOUR=0x00000004,
	NETLOGON_NEG_PROMOTION_COUNT=0x00000008,
	NETLOGON_NEG_CHANGELOG_BDC=0x00000010,
	NETLOGON_NEG_FULL_SYNC_REPL=0x00000020,
	NETLOGON_NEG_MULTIPLE_SIDS=0x00000040,
	NETLOGON_NEG_REDO=0x00000080,
	NETLOGON_NEG_PASSWORD_CHANGE_REFUSAL=0x00000100,
	NETLOGON_NEG_SEND_PASSWORD_INFO_PDC=0x00000200,
	NETLOGON_NEG_GENERIC_PASSTHROUGH=0x00000400,
	NETLOGON_NEG_CONCURRENT_RPC=0x00000800,
	NETLOGON_NEG_AVOID_ACCOUNT_DB_REPL=0x00001000,
	NETLOGON_NEG_AVOID_SECURITYAUTH_DB_REPL=0x00002000,
	NETLOGON_NEG_STRONG_KEYS=0x00004000,
	NETLOGON_NEG_TRANSITIVE_TRUSTS=0x00008000,
	NETLOGON_NEG_DNS_DOMAIN_TRUSTS=0x00010000,
	NETLOGON_NEG_PASSWORD_SET2=0x00020000,
	NETLOGON_NEG_GETDOMAININFO=0x00040000,
	NETLOGON_NEG_CROSS_FOREST_TRUSTS=0x00080000,
	NETLOGON_NEG_NEUTRALIZE_NT4_EMULATION=0x00100000,
	NETLOGON_NEG_RODC_PASSTHROUGH=0x00200000,
	NETLOGON_NEG_SUPPORTS_AES_SHA2=0x00400000,
	NETLOGON_NEG_SUPPORTS_AES=0x01000000,
	NETLOGON_NEG_AUTHENTICATED_RPC_LSASS=0x20000000,
	NETLOGON_NEG_AUTHENTICATED_RPC=0x40000000,
}/* [bitmap32bit, public] */;

template <> struct x_ndr_traits_t<netr_NegotiateFlags> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 26> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_NegotiateFlags>(const netr_NegotiateFlags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_NegotiateFlags>(netr_NegotiateFlags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_NegotiateFlags(v);
	return __bpos;
}


const uint32 NETLOGON_NEG_128BIT = NETLOGON_NEG_STRONG_KEYS;
const uint32 NETLOGON_NEG_SCHANNEL = NETLOGON_NEG_AUTHENTICATED_RPC;

enum SyncStateEnum : uint16 {
	SYNCSTATE_NORMAL_STATE=0,
	SYNCSTATE_DOMAIN_STATE=1,
	SYNCSTATE_GROUP_STATE=2,
	SYNCSTATE_UAS_BUILT_IN_GROUP_STATE=3,
	SYNCSTATE_USER_STATE=4,
	SYNCSTATE_GROUP_MEMBER_STATE=5,
	SYNCSTATE_ALIAS_STATE=6,
	SYNCSTATE_ALIAS_MEMBER_STATE=7,
	SYNCSTATE_SAM_DONE_STATE=8,
};

template <> struct x_ndr_traits_t<SyncStateEnum> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 9> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<SyncStateEnum>(const SyncStateEnum &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint1632(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<SyncStateEnum>(SyncStateEnum &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = SyncStateEnum(v);
	return __bpos;
}


enum netr_ChangeLogFlags : uint16 {
	NETR_CHANGELOG_IMMEDIATE_REPL_REQUIRED=0x0001,
	NETR_CHANGELOG_CHANGED_PASSWORD=0x0002,
	NETR_CHANGELOG_SID_INCLUDED=0x0004,
	NETR_CHANGELOG_NAME_INCLUDED=0x0008,
	NETR_CHANGELOG_FIRST_PROMOTION_OBJ=0x0010,
}/* [bitmap16bit] */;

template <> struct x_ndr_traits_t<netr_ChangeLogFlags> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 5> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_ChangeLogFlags>(const netr_ChangeLogFlags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint16(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_ChangeLogFlags>(netr_ChangeLogFlags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_ChangeLogFlags(v);
	return __bpos;
}



union netr_ChangeLogObject
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_ChangeLogObject() { }
	~netr_ChangeLogObject() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const netr_ChangeLogObject &__other);
	void __uninit(x_ndr_switch_t __level);
	dom_sid object_sid;/* [case(NETR_CHANGELOG_SID_INCLUDED)] */
	nstring object_name;/* [case(NETR_CHANGELOG_NAME_INCLUDED)] */
} /* [nodiscriminant] */;

template <> struct x_ndr_traits_t<netr_ChangeLogObject> {
	using ndr_type = x_ndr_type_union;
};


struct netr_ChangeLogEntry {
	netr_ChangeLogEntry();
	~netr_ChangeLogEntry();
	netr_ChangeLogEntry(const netr_ChangeLogEntry& other);
	netr_ChangeLogEntry &operator=(const netr_ChangeLogEntry& other);
	void set_flags(netr_ChangeLogFlags v);
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 serial_number1;
	uint32 serial_number2;
	uint32 object_rid;
	netr_ChangeLogFlags flags;
	netr_SamDatabaseID db_index;
	netr_DeltaEnum delta_type;
	netr_ChangeLogObject object;/* [switch_is(flags&(NETR_CHANGELOG_SID_INCLUDED|NETR_CHANGELOG_NAME_INCLUDED))] */
} /* [gensize, public] */;

template <> struct x_ndr_traits_t<netr_ChangeLogEntry> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_Blob {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<uint8> data;/* [size_is(length)] */
} ;

template <> struct x_ndr_traits_t<netr_Blob> {
	using ndr_type = x_ndr_type_struct;
};


enum netr_DsRGetDCName_flags : uint32 {
	DS_FORCE_REDISCOVERY=0x00000001,
	DS_DIRECTORY_SERVICE_REQUIRED=0x00000010,
	DS_DIRECTORY_SERVICE_PREFERRED=0x00000020,
	DS_GC_SERVER_REQUIRED=0x00000040,
	DS_PDC_REQUIRED=0x00000080,
	DS_BACKGROUND_ONLY=0x00000100,
	DS_IP_REQUIRED=0x00000200,
	DS_KDC_REQUIRED=0x00000400,
	DS_TIMESERV_REQUIRED=0x00000800,
	DS_WRITABLE_REQUIRED=0x00001000,
	DS_GOOD_TIMESERV_PREFERRED=0x00002000,
	DS_AVOID_SELF=0x00004000,
	DS_ONLY_LDAP_NEEDED=0x00008000,
	DS_IS_FLAT_NAME=0x00010000,
	DS_IS_DNS_NAME=0x00020000,
	DS_TRY_NEXTCLOSEST_SITE=0x00040000,
	DS_DIRECTORY_SERVICE_6_REQUIRED=0x00080000,
	DS_WEB_SERVICE_REQUIRED=0x00100000,
	DS_RETURN_DNS_NAME=0x40000000,
	DS_RETURN_FLAT_NAME=0x80000000,
}/* [bitmap32bit] */;

template <> struct x_ndr_traits_t<netr_DsRGetDCName_flags> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 20> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_DsRGetDCName_flags>(const netr_DsRGetDCName_flags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_DsRGetDCName_flags>(netr_DsRGetDCName_flags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_DsRGetDCName_flags(v);
	return __bpos;
}


const int DSGETDC_VALID_FLAGS = (DS_FORCE_REDISCOVERY|DS_DIRECTORY_SERVICE_REQUIRED|DS_DIRECTORY_SERVICE_PREFERRED|DS_GC_SERVER_REQUIRED|DS_PDC_REQUIRED|DS_BACKGROUND_ONLY|DS_IP_REQUIRED|DS_KDC_REQUIRED|DS_TIMESERV_REQUIRED|DS_WRITABLE_REQUIRED|DS_GOOD_TIMESERV_PREFERRED|DS_AVOID_SELF|DS_ONLY_LDAP_NEEDED|DS_IS_FLAT_NAME|DS_IS_DNS_NAME|DS_TRY_NEXTCLOSEST_SITE|DS_DIRECTORY_SERVICE_6_REQUIRED|DS_WEB_SERVICE_REQUIRED|DS_RETURN_FLAT_NAME|DS_RETURN_DNS_NAME);

enum netr_DsRGetDCNameInfo_AddressType : uint32 {
	DS_ADDRESS_TYPE_INET=1,
	DS_ADDRESS_TYPE_NETBIOS=2,
}/* [v1_enum] */;

template <> struct x_ndr_traits_t<netr_DsRGetDCNameInfo_AddressType> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 2> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_DsRGetDCNameInfo_AddressType>(const netr_DsRGetDCNameInfo_AddressType &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_DsRGetDCNameInfo_AddressType>(netr_DsRGetDCNameInfo_AddressType &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_DsRGetDCNameInfo_AddressType(v);
	return __bpos;
}


enum netr_DsR_DcFlags : uint32 {
	DS_SERVER_PDC=0x00000001,
	DS_SERVER_GC=0x00000004,
	DS_SERVER_LDAP=0x00000008,
	DS_SERVER_DS=0x00000010,
	DS_SERVER_KDC=0x00000020,
	DS_SERVER_TIMESERV=0x00000040,
	DS_SERVER_CLOSEST=0x00000080,
	DS_SERVER_WRITABLE=0x00000100,
	DS_SERVER_GOOD_TIMESERV=0x00000200,
	DS_SERVER_NDNC=0x00000400,
	DS_SERVER_SELECT_SECRET_DOMAIN_6=0x00000800,
	DS_SERVER_FULL_SECRET_DOMAIN_6=0x00001000,
	DS_SERVER_WEBSERV=0x00002000,
	DS_SERVER_DS_8=0x00004000,
	DS_DNS_CONTROLLER=0x20000000,
	DS_DNS_DOMAIN=0x40000000,
	DS_DNS_FOREST_ROOT=0x80000000,
}/* [bitmap32bit] */;

template <> struct x_ndr_traits_t<netr_DsR_DcFlags> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 17> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_DsR_DcFlags>(const netr_DsR_DcFlags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_DsR_DcFlags>(netr_DsR_DcFlags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_DsR_DcFlags(v);
	return __bpos;
}



struct netr_DsRGetDCNameInfo {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	u16string dc_unc;/* [string, charset(UTF16)] */
	u16string dc_address;/* [string, charset(UTF16)] */
	netr_DsRGetDCNameInfo_AddressType dc_address_type;
	GUID domain_guid;
	u16string domain_name;/* [string, charset(UTF16)] */
	u16string forest_name;/* [string, charset(UTF16)] */
	netr_DsR_DcFlags dc_flags;
	u16string dc_site_name;/* [string, charset(UTF16)] */
	u16string client_site_name;/* [string, charset(UTF16)] */
} /* [public] */;

template <> struct x_ndr_traits_t<netr_DsRGetDCNameInfo> {
	using ndr_type = x_ndr_type_struct;
};


union netr_Capabilities
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_NegotiateFlags server_capabilities;/* [case] */
} /* [switch_type(uint32)] */;

template <> struct x_ndr_traits_t<netr_Capabilities> {
	using ndr_type = x_ndr_type_union;
};


enum netr_TrustFlags : uint32 {
	NETR_TRUST_FLAG_IN_FOREST=0x00000001,
	NETR_TRUST_FLAG_OUTBOUND=0x00000002,
	NETR_TRUST_FLAG_TREEROOT=0x00000004,
	NETR_TRUST_FLAG_PRIMARY=0x00000008,
	NETR_TRUST_FLAG_NATIVE=0x00000010,
	NETR_TRUST_FLAG_INBOUND=0x00000020,
	NETR_TRUST_FLAG_MIT_KRB5=0x00000080,
	NETR_TRUST_FLAG_AES=0x00000100,
}/* [bitmap32bit] */;

template <> struct x_ndr_traits_t<netr_TrustFlags> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 8> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_TrustFlags>(const netr_TrustFlags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_TrustFlags>(netr_TrustFlags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_TrustFlags(v);
	return __bpos;
}



enum netr_WorkstationFlags : uint32 {
	NETR_WS_FLAG_HANDLES_INBOUND_TRUSTS=0x00000001,
	NETR_WS_FLAG_HANDLES_SPN_UPDATE=0x00000002,
}/* [bitmap32bit] */;

template <> struct x_ndr_traits_t<netr_WorkstationFlags> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 2> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_WorkstationFlags>(const netr_WorkstationFlags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_WorkstationFlags>(netr_WorkstationFlags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_WorkstationFlags(v);
	return __bpos;
}



enum netr_SuiteMask : uint16 {
	NETR_VER_SUITE_BACKOFFICE=0x0004,
	NETR_VER_SUITE_BLADE=0x0400,
	NETR_VER_SUITE_COMPUTE_SERVER=0x4000,
	NETR_VER_SUITE_DATACENTER=0x0080,
	NETR_VER_SUITE_ENTERPRISE=0x0002,
	NETR_VER_SUITE_EMBEDDEDNT=0x0040,
	NETR_VER_SUITE_PERSONAL=0x0200,
	NETR_VER_SUITE_SINGLEUSERTS=0x0100,
	NETR_VER_SUITE_SMALLBUSINESS=0x0001,
	NETR_VER_SUITE_SMALLBUSINESS_RESTRICTED=0x0020,
	NETR_VER_SUITE_STORAGE_SERVER=0x2000,
	NETR_VER_SUITE_TERMINAL=0x0010,
	NETR_VER_SUITE_WH_SERVER=0x8000,
}/* [bitmap16bit] */;

template <> struct x_ndr_traits_t<netr_SuiteMask> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 13> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_SuiteMask>(const netr_SuiteMask &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint16(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_SuiteMask>(netr_SuiteMask &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_SuiteMask(v);
	return __bpos;
}



enum netr_ProductType : uint8 {
	NETR_VER_NT_DOMAIN_CONTROLLER=0x02,
	NETR_VER_NT_SERVER=0x03,
	NETR_VER_NT_WORKSTATION=0x01,
}/* [bitmap8bit] */;

template <> struct x_ndr_traits_t<netr_ProductType> {
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint8;
	static const std::array<std::pair<uint8, const char *>, 3> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_ProductType>(const netr_ProductType &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint8(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_ProductType>(netr_ProductType &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint8_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_ProductType(v);
	return __bpos;
}



struct netr_LsaPolicyInformation {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<uint8> policy;/* [size_is(policy_size)] */
} ;

template <> struct x_ndr_traits_t<netr_LsaPolicyInformation> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_OsVersionInfoEx {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 MajorVersion;
	uint32 MinorVersion;
	uint32 BuildNumber;
	uint32 PlatformId;
	nstring CSDVersion;/* [subcontext_size(256), subcontext(0)] */
	uint16 ServicePackMajor;
	uint16 ServicePackMinor;
	netr_SuiteMask SuiteMask;
	netr_ProductType ProductType;
	uint8 Reserved;
} ;

template <> struct x_ndr_traits_t<netr_OsVersionInfoEx> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_OsVersion {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_OsVersionInfoEx os;
} ;

template <> struct x_ndr_traits_t<netr_OsVersion> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_OsVersionContainer {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::shared_ptr<netr_OsVersion> os;
} ;

template <> struct x_ndr_traits_t<netr_OsVersionContainer> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_WorkstationInformation {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_LsaPolicyInformation lsa_policy;
	u16string dns_hostname;/* [string, charset(UTF16)] */
	u16string sitename;/* [string, charset(UTF16)] */
	u16string dummy1;/* [string, charset(UTF16)] */
	u16string dummy2;/* [string, charset(UTF16)] */
	u16string dummy3;/* [string, charset(UTF16)] */
	u16string dummy4;/* [string, charset(UTF16)] */
	netr_OsVersionContainer os_version;
	lsa_String os_name;
	lsa_String dummy_string3;
	lsa_String dummy_string4;
	netr_WorkstationFlags workstation_flags;
	kerb_EncTypes supported_enc_types;
	uint32 dummy_long3;
	uint32 dummy_long4;
} ;

template <> struct x_ndr_traits_t<netr_WorkstationInformation> {
	using ndr_type = x_ndr_type_struct;
};


union netr_WorkstationInfo
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_WorkstationInfo() { }
	~netr_WorkstationInfo() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const netr_WorkstationInfo &__other);
	void __uninit(x_ndr_switch_t __level);
	std::shared_ptr<netr_WorkstationInformation> workstation_info;/* [case] */
	std::shared_ptr<netr_WorkstationInformation> lsa_policy_info;/* [case(2)] */
} ;

template <> struct x_ndr_traits_t<netr_WorkstationInfo> {
	using ndr_type = x_ndr_type_union;
};


struct netr_trust_extension {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_TrustFlags flags;
	uint32 parent_index;
	uint32 trust_type;
	uint32 trust_attributes;
} ;

template <> struct x_ndr_traits_t<netr_trust_extension> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_trust_extension_container {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint16 length;
	std::shared_ptr<netr_trust_extension> info;
} ;

template <> struct x_ndr_traits_t<netr_trust_extension_container> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_OneDomainInfo {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	lsa_StringLarge domainname;
	lsa_StringLarge dns_domainname;
	lsa_StringLarge dns_forestname;
	GUID domain_guid;
	std::shared_ptr<dom_sid2> domain_sid;
	netr_trust_extension_container trust_extension;
	lsa_StringLarge dummy_string2;
	lsa_StringLarge dummy_string3;
	lsa_StringLarge dummy_string4;
	uint32 dummy_long1;
	uint32 dummy_long2;
	uint32 dummy_long3;
	uint32 dummy_long4;
} ;

template <> struct x_ndr_traits_t<netr_OneDomainInfo> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DomainInformation {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_OneDomainInfo primary_domain;
	std::vector<netr_OneDomainInfo> trusted_domains;/* [size_is(trusted_domain_count)] */
	netr_LsaPolicyInformation lsa_policy;
	lsa_StringLarge dns_hostname;
	lsa_StringLarge dummy_string2;
	lsa_StringLarge dummy_string3;
	lsa_StringLarge dummy_string4;
	netr_WorkstationFlags workstation_flags;
	kerb_EncTypes supported_enc_types;
	uint32 dummy_long3;
	uint32 dummy_long4;
} ;

template <> struct x_ndr_traits_t<netr_DomainInformation> {
	using ndr_type = x_ndr_type_struct;
};


union netr_DomainInfo
{
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_DomainInfo() { }
	~netr_DomainInfo() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const netr_DomainInfo &__other);
	void __uninit(x_ndr_switch_t __level);
	std::shared_ptr<netr_DomainInformation> domain_info;/* [case] */
	std::shared_ptr<netr_LsaPolicyInformation> lsa_policy_info;/* [case(2)] */
} ;

template <> struct x_ndr_traits_t<netr_DomainInfo> {
	using ndr_type = x_ndr_type_union;
};

const int NETLOGON_PASSWORD_VERSION_NUMBER_PRESENT = 0x02231968;

struct NL_PASSWORD_VERSION {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 ReservedField;
	uint32 PasswordVersionNumber;
	uint32 PasswordVersionPresent;
} ;

template <> struct x_ndr_traits_t<NL_PASSWORD_VERSION> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_CryptPassword {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::array<uint8, 512> data;
	uint32 length;
} /* [flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<netr_CryptPassword> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DsRAddressToSitenamesWCtr {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<lsa_String> sitename;/* [size_is(count)] */
} ;

template <> struct x_ndr_traits_t<netr_DsRAddressToSitenamesWCtr> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DsRAddress {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<uint8> buffer;/* [size_is(size)] */
} ;

template <> struct x_ndr_traits_t<netr_DsRAddress> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DomainTrust {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	u16string netbios_name;/* [string, charset(UTF16)] */
	u16string dns_name;/* [string, charset(UTF16)] */
	netr_TrustFlags trust_flags;
	uint32 parent_index;
	lsa_TrustType trust_type;
	lsa_TrustAttributes trust_attributes;
	std::shared_ptr<dom_sid> sid;
	GUID guid;
} ;

template <> struct x_ndr_traits_t<netr_DomainTrust> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DomainTrustList {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<netr_DomainTrust> array;/* [size_is(count)] */
} ;

template <> struct x_ndr_traits_t<netr_DomainTrustList> {
	using ndr_type = x_ndr_type_struct;
};


struct netr_DsRAddressToSitenamesExWCtr {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<lsa_String> sitename;/* [size_is(count)] */
	std::vector<lsa_String> subnetname;/* [size_is(count)] */
} ;

template <> struct x_ndr_traits_t<netr_DsRAddressToSitenamesExWCtr> {
	using ndr_type = x_ndr_type_struct;
};


struct DcSitesCtr {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<lsa_String> sites;/* [unique, size_is(num_sites)] */
} ;

template <> struct x_ndr_traits_t<DcSitesCtr> {
	using ndr_type = x_ndr_type_struct;
};

const int DS_GFTI_UPDATE_TDO = 0x1;

struct netr_TrustInfo {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<uint32> data;/* [size_is(count)] */
	uint32 entry_count;
	std::vector<lsa_String> entries;/* [size_is(count)] */
} ;

template <> struct x_ndr_traits_t<netr_TrustInfo> {
	using ndr_type = x_ndr_type_struct;
};


enum netr_DnsType : uint16 {
	NlDnsLdapAtSite=22,
	NlDnsGcAtSite=25,
	NlDnsDsaCname=28,
	NlDnsKdcAtSite=30,
	NlDnsDcAtSite=32,
	NlDnsRfc1510KdcAtSite=34,
	NlDnsGenericGcAtSite=36,
};

template <> struct x_ndr_traits_t<netr_DnsType> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 7> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_DnsType>(const netr_DnsType &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint1632(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_DnsType>(netr_DnsType &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_DnsType(v);
	return __bpos;
}


enum netr_DnsDomainInfoType : uint16 {
	NlDnsInfoTypeNone=0,
	NlDnsDomainName=1,
	NlDnsDomainNameAlias=2,
	NlDnsForestName=3,
	NlDnsForestNameAlias=4,
	NlDnsNdncDomainName=5,
	NlDnsRecordName=6,
};

template <> struct x_ndr_traits_t<netr_DnsDomainInfoType> {
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 7> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<netr_DnsDomainInfoType>(const netr_DnsDomainInfoType &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint1632(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<netr_DnsDomainInfoType>(netr_DnsDomainInfoType &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = netr_DnsDomainInfoType(v);
	return __bpos;
}


struct NL_DNS_NAME_INFO {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	netr_DnsType type;
	u16string dns_domain_info;/* [string, charset(UTF16)] */
	netr_DnsDomainInfoType dns_domain_info_type;
	uint32 priority;
	uint32 weight;
	uint32 port;
	boolean32 dns_register;
	uint32 status;
} ;

template <> struct x_ndr_traits_t<NL_DNS_NAME_INFO> {
	using ndr_type = x_ndr_type_struct;
};


struct NL_DNS_NAME_INFO_ARRAY {
	x_ndr_off_t push(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t pull(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<NL_DNS_NAME_INFO> names;/* [size_is(count)] */
} /* [public] */;

template <> struct x_ndr_traits_t<NL_DNS_NAME_INFO_ARRAY> {
	using ndr_type = x_ndr_type_struct;
};

#endif /* _HEADER_netlogon */
} /* namespace idl */

#endif /* _PIDL_HEADER_netlogon */

