/*
   Unix SMB/CIFS implementation.

   routines for marshalling/unmarshalling special ntlmssp structures

   Copyright (C) Guenther Deschner 2009

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* header auto-generated by pidl */
#ifndef _PIDL_HEADER_ntlmssp
#define _PIDL_HEADER_ntlmssp
#include "include/librpc/ndr_nxsmb.hxx"

#include "include/librpc/ndr_security.hxx"

namespace idl {
#ifndef _HEADER_ntlmssp
#define _HEADER_ntlmssp

enum ntlmssp_MessageType : uint32 {
	NtLmNegotiate=0x00000001,
	NtLmChallenge=0x00000002,
	NtLmAuthenticate=0x00000003,
}/* [v1_enum] */;

template <> struct x_ndr_traits_t<ntlmssp_MessageType> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 3> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_MessageType>(const ntlmssp_MessageType &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_MessageType>(ntlmssp_MessageType &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = ntlmssp_MessageType(v);
	return __bpos;
}


enum NEGOTIATE : uint32 {
	NTLMSSP_NEGOTIATE_UNICODE=0x00000001,
	NTLMSSP_NEGOTIATE_OEM=0x00000002,
	NTLMSSP_REQUEST_TARGET=0x00000004,
	NTLMSSP_NEGOTIATE_SIGN=0x00000010,
	NTLMSSP_NEGOTIATE_SEAL=0x00000020,
	NTLMSSP_NEGOTIATE_DATAGRAM=0x00000040,
	NTLMSSP_NEGOTIATE_LM_KEY=0x00000080,
	NTLMSSP_NEGOTIATE_NETWARE=0x00000100,
	NTLMSSP_NEGOTIATE_NTLM=0x00000200,
	NTLMSSP_NEGOTIATE_NT_ONLY=0x00000400,
	NTLMSSP_ANONYMOUS=0x00000800,
	NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED=0x00001000,
	NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED=0x00002000,
	NTLMSSP_NEGOTIATE_THIS_IS_LOCAL_CALL=0x00004000,
	NTLMSSP_NEGOTIATE_ALWAYS_SIGN=0x00008000,
	NTLMSSP_TARGET_TYPE_DOMAIN=0x00010000,
	NTLMSSP_TARGET_TYPE_SERVER=0x00020000,
	NTLMSSP_TARGET_TYPE_SHARE=0x00040000,
	NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY=0x00080000,
	NTLMSSP_NEGOTIATE_IDENTIFY=0x00100000,
	NTLMSSP_REQUEST_NON_NT_SESSION_KEY=0x00400000,
	NTLMSSP_NEGOTIATE_TARGET_INFO=0x00800000,
	NTLMSSP_NEGOTIATE_VERSION=0x02000000,
	NTLMSSP_NEGOTIATE_128=0x20000000,
	NTLMSSP_NEGOTIATE_KEY_EXCH=0x40000000,
	NTLMSSP_NEGOTIATE_56=0x80000000,
}/* [bitmap32bit] */;

template <> struct x_ndr_traits_t<NEGOTIATE> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 26> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<NEGOTIATE>(const NEGOTIATE &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<NEGOTIATE>(NEGOTIATE &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = NEGOTIATE(v);
	return __bpos;
}


const int NTLMSSP_NEGOTIATE_NTLM2 = NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY;

enum ntlmssp_WindowsMajorVersion : uint8 {
	NTLMSSP_WINDOWS_MAJOR_VERSION_5=0x05,
	NTLMSSP_WINDOWS_MAJOR_VERSION_6=0x06,
	NTLMSSP_WINDOWS_MAJOR_VERSION_10=0x0A,
}/* [enum8bit] */;

template <> struct x_ndr_traits_t<ntlmssp_WindowsMajorVersion> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint8;
	static const std::array<std::pair<uint8, const char *>, 3> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_WindowsMajorVersion>(const ntlmssp_WindowsMajorVersion &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint8(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_WindowsMajorVersion>(ntlmssp_WindowsMajorVersion &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint8_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = ntlmssp_WindowsMajorVersion(v);
	return __bpos;
}


enum ntlmssp_WindowsMinorVersion : uint8 {
	NTLMSSP_WINDOWS_MINOR_VERSION_0=0x00,
	NTLMSSP_WINDOWS_MINOR_VERSION_1=0x01,
	NTLMSSP_WINDOWS_MINOR_VERSION_2=0x02,
	NTLMSSP_WINDOWS_MINOR_VERSION_3=0x03,
}/* [enum8bit] */;

template <> struct x_ndr_traits_t<ntlmssp_WindowsMinorVersion> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint8;
	static const std::array<std::pair<uint8, const char *>, 4> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_WindowsMinorVersion>(const ntlmssp_WindowsMinorVersion &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint8(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_WindowsMinorVersion>(ntlmssp_WindowsMinorVersion &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint8_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = ntlmssp_WindowsMinorVersion(v);
	return __bpos;
}


enum ntlmssp_NTLMRevisionCurrent : uint8 {
	NTLMSSP_REVISION_W2K3_RC1=0x0A,
	NTLMSSP_REVISION_W2K3=0x0F,
}/* [enum8bit] */;

template <> struct x_ndr_traits_t<ntlmssp_NTLMRevisionCurrent> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint8;
	static const std::array<std::pair<uint8, const char *>, 2> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_NTLMRevisionCurrent>(const ntlmssp_NTLMRevisionCurrent &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint8(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_NTLMRevisionCurrent>(ntlmssp_NTLMRevisionCurrent &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint8_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = ntlmssp_NTLMRevisionCurrent(v);
	return __bpos;
}


struct ntlmssp_VERSION {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	ntlmssp_WindowsMajorVersion ProductMajorVersion;
	ntlmssp_WindowsMinorVersion ProductMinorVersion;
	uint16 ProductBuild;
	std::array<uint8, 3> Reserved;
	ntlmssp_NTLMRevisionCurrent NTLMRevisionCurrent;
} /* [public] */;

template <> struct x_ndr_traits_t<ntlmssp_VERSION> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


union ntlmssp_Version
{
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	ntlmssp_VERSION version;/* [case(NTLMSSP_NEGOTIATE_VERSION)] */
} /* [nodiscriminant] */;

template <> struct x_ndr_traits_t<ntlmssp_Version> {
	using ndr_type = x_ndr_type_union;
};


struct NEGOTIATE_MESSAGE {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	x_ndr_off_t ndr_buffers(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_buffers(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	NEGOTIATE NegotiateFlags;
	x_ndr_l2s2o4_ptr_t<sstring> DomainName;/* [x_relative] */
	x_ndr_l2s2o4_ptr_t<sstring> Workstation;/* [x_relative] */
	ntlmssp_Version Version;/* [switch_is(NegotiateFlags&NTLMSSP_NEGOTIATE_VERSION)] */
} /* [public] */;

template <> struct x_ndr_traits_t<NEGOTIATE_MESSAGE> {
	using has_buffers = std::true_type;
	using ndr_type = x_ndr_type_struct;
};


enum ntlmssp_AvId : uint16 {
	MsvAvEOL=0,
	MsvAvNbComputerName=1,
	MsvAvNbDomainName=2,
	MsvAvDnsComputerName=3,
	MsvAvDnsDomainName=4,
	MsvAvDnsTreeName=5,
	MsvAvFlags=6,
	MsvAvTimestamp=7,
	MsvAvSingleHost=8,
	MsvAvTargetName=9,
	MsvChannelBindings=10,
};

template <> struct x_ndr_traits_t<ntlmssp_AvId> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_enum;
	using ndr_base_type = uint16;
	static const std::array<std::pair<uint16, const char *>, 11> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_AvId>(const ntlmssp_AvId &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint1632(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_AvId>(ntlmssp_AvId &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint16_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = ntlmssp_AvId(v);
	return __bpos;
}


struct ntlmssp_SingleHostData {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	LSAP_TOKEN_INFO_INTEGRITY token_info;
	DATA_BLOB remaining;/* [flag(LIBNDR_FLAG_REMAINING)] */
} /* [flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<ntlmssp_SingleHostData> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


enum ntlmssp_AvFlags : uint32 {
	NTLMSSP_AVFLAG_CONSTRAINTED_ACCOUNT=0x00000001,
	NTLMSSP_AVFLAG_MIC_IN_AUTHENTICATE_MESSAGE=0x00000002,
	NTLMSSP_AVFLAG_TARGET_SPN_FROM_UNTRUSTED_SOURCE=0x00000004,
}/* [bitmap32bit] */;

template <> struct x_ndr_traits_t<ntlmssp_AvFlags> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_bitmap;
	using ndr_base_type = uint32;
	static const std::array<std::pair<uint32, const char *>, 3> value_name_map;
};

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_AvFlags>(const ntlmssp_AvFlags &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	X_ASSERT(__level == X_NDR_SWITCH_NONE);
	return x_ndr_push_uint32(__val, __ndr, __bpos, __epos, __flags);
}

template <> inline x_ndr_off_t x_ndr_scalars<ntlmssp_AvFlags>(ntlmssp_AvFlags &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{
	uint32_t v;
	X_NDR_SCALARS(v, __ndr, __bpos, __epos, __flags, __level);
	__val = ntlmssp_AvFlags(v);
	return __bpos;
}



union ntlmssp_AvValue
{
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	ntlmssp_AvValue() { }
	~ntlmssp_AvValue() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const ntlmssp_AvValue &__other);
	void __uninit(x_ndr_switch_t __level);
	u16string AvNbComputerName;/* [case(MsvAvNbComputerName)] */
	u16string AvNbDomainName;/* [case(MsvAvNbDomainName)] */
	u16string AvDnsComputerName;/* [case(MsvAvDnsComputerName)] */
	u16string AvDnsDomainName;/* [case(MsvAvDnsDomainName)] */
	u16string AvDnsTreeName;/* [case(MsvAvDnsTreeName)] */
	ntlmssp_AvFlags AvFlags;/* [case(MsvAvFlags)] */
	NTTIME AvTimestamp;/* [case(MsvAvTimestamp)] */
	ntlmssp_SingleHostData AvSingleHost;/* [case(MsvAvSingleHost)] */
	u16string AvTargetName;/* [case(MsvAvTargetName)] */
	std::array<uint8, 16> ChannelBindings;/* [case(MsvChannelBindings)] */
	DATA_BLOB blob;/* [default, flag(LIBNDR_FLAG_REMAINING)] */
} /* [gensize, nodiscriminant, flag(LIBNDR_FLAG_NOALIGN)] */;

template <> struct x_ndr_traits_t<ntlmssp_AvValue> {
	using ndr_type = x_ndr_type_union;
};


struct AV_PAIR {
	AV_PAIR();
	~AV_PAIR();
	AV_PAIR(const AV_PAIR& other);
	AV_PAIR &operator=(const AV_PAIR& other);
	void set_AvId(ntlmssp_AvId v);
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	ntlmssp_AvId AvId;
	ntlmssp_AvValue Value;/* [switch_is(AvId)] */
} /* [public, flag(LIBNDR_FLAG_NOALIGN)] */;

template <> struct x_ndr_traits_t<AV_PAIR> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


struct AV_PAIR_LIST {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_vector_t<AV_PAIR> pair;
} /* [gensize, public, flag(LIBNDR_FLAG_NOALIGN)] */;

template <> struct x_ndr_traits_t<AV_PAIR_LIST> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


struct CHALLENGE_MESSAGE {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	x_ndr_off_t ndr_buffers(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_buffers(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_l2s2o4_ptr_t<gstring> TargetName;/* [x_relative, flag(x_ndr_ntlmssp_negotiated_string_flags(NegotiateFlags))] */
	NEGOTIATE NegotiateFlags;
	std::array<uint8, 8> ServerChallenge;
	std::array<uint8, 8> Reserved;/* [noprint] */
	x_ndr_l2s2o4_ptr_t<AV_PAIR_LIST> TargetInfo;/* [x_relative] */
	ntlmssp_Version Version;/* [switch_is(NegotiateFlags&NTLMSSP_NEGOTIATE_VERSION)] */
} /* [public, flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<CHALLENGE_MESSAGE> {
	using has_buffers = std::true_type;
	using ndr_type = x_ndr_type_struct;
};


struct LM_RESPONSE {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::array<uint8, 24> Response;
} /* [public, flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<LM_RESPONSE> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


struct LMv2_RESPONSE {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::array<uint8, 16> Response;
	std::array<uint8, 8> ChallengeFromClient;
} /* [public, flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<LMv2_RESPONSE> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


union ntlmssp_LM_RESPONSE
{
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	LM_RESPONSE v1;/* [case(24)] */
} /* [nodiscriminant] */;

template <> struct x_ndr_traits_t<ntlmssp_LM_RESPONSE> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_union;
};


struct NTLM_RESPONSE {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::array<uint8, 24> Response;
} /* [public, flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<NTLM_RESPONSE> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


struct NTLMv2_CLIENT_CHALLENGE {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint16 Reserved1;/* [noprint] */
	uint32 Reserved2;/* [noprint] */
	NTTIME TimeStamp;
	std::array<uint8, 8> ChallengeFromClient;
	uint32 Reserved3;/* [noprint] */
	AV_PAIR_LIST AvPairs;/* [flag(LIBNDR_FLAG_REMAINING)] */
} /* [flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<NTLMv2_CLIENT_CHALLENGE> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


struct NTLMv2_RESPONSE {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::array<uint8, 16> Response;
	NTLMv2_CLIENT_CHALLENGE Challenge;
} /* [public, flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<NTLMv2_RESPONSE> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


union ntlmssp_NTLM_RESPONSE
{
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	ntlmssp_NTLM_RESPONSE() { }
	~ntlmssp_NTLM_RESPONSE() { }
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const ntlmssp_NTLM_RESPONSE &__other);
	void __uninit(x_ndr_switch_t __level);
	NTLM_RESPONSE v1;/* [case(0x18)] */
	NTLMv2_RESPONSE v2;/* [default] */
} /* [public, nodiscriminant] */;

template <> struct x_ndr_traits_t<ntlmssp_NTLM_RESPONSE> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_union;
};

const int NTLMSSP_MIC_OFFSET = 72;
const int NTLMSSP_MIC_SIZE = 16;
#if 0
struct ntlmssp_MIC {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::vector<uint8> MIC;
} /* [flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<ntlmssp_MIC> {
	using ndr_type = x_ndr_type_struct;
};
#endif

struct AUTHENTICATE_MESSAGE {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	x_ndr_off_t ndr_buffers(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_buffers(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_l2s2o4_ptr_t<LM_RESPONSE> LmChallengeResponse;/* [x_relative] */
	x_ndr_l2s2o4_ptr_t<blob_t> NtChallengeResponse;/* [x_relative] */
	x_ndr_l2s2o4_ptr_t<gstring> DomainName;/* [x_relative, flag(x_ndr_ntlmssp_negotiated_string_flags(NegotiateFlags))] */
	x_ndr_l2s2o4_ptr_t<gstring> UserName;/* [x_relative, flag(x_ndr_ntlmssp_negotiated_string_flags(NegotiateFlags))] */
	x_ndr_l2s2o4_ptr_t<gstring> Workstation;/* [x_relative, flag(x_ndr_ntlmssp_negotiated_string_flags(NegotiateFlags))] */
	x_ndr_l2s2o4_ptr_t<blob_t> EncryptedRandomSessionKey;/* [x_relative] */
	NEGOTIATE NegotiateFlags;
	ntlmssp_Version Version;/* [switch_is(NegotiateFlags&NTLMSSP_NEGOTIATE_VERSION)] */
	// TODO ntlmssp_MIC mic;
} /* [public, flag(LIBNDR_FLAG_REMAINING)] */;

template <> struct x_ndr_traits_t<AUTHENTICATE_MESSAGE> {
	using has_buffers = std::true_type;
	using ndr_type = x_ndr_type_struct;
};

const int NTLMSSP_SIGN_VERSION = 0x01;
const int NTLMSSP_SIG_SIZE = 16;

struct NTLMSSP_MESSAGE_SIGNATURE {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	uint32 RandomPad;
	uint32 Checksum;
	uint32 SeqNum;
} /* [public] */;

template <> struct x_ndr_traits_t<NTLMSSP_MESSAGE_SIGNATURE> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};


struct NTLMSSP_MESSAGE_SIGNATURE_NTLMv2 {
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
	std::array<uint8, 8> Checksum;
	uint32 SeqNum;
} /* [public, flag(LIBNDR_PRINT_ARRAY_HEX)] */;

template <> struct x_ndr_traits_t<NTLMSSP_MESSAGE_SIGNATURE_NTLMv2> {
	using has_buffers = std::false_type;
	using ndr_type = x_ndr_type_struct;
};

#endif /* _HEADER_ntlmssp */
#endif /* _PIDL_HEADER_ntlmssp */

uint32_t x_ndr_ntlmssp_negotiated_string_flags(uint32_t negotiate_flags);

} /* namespace idl */

#if 0
_PUBLIC_ size_t ndr_ntlmssp_string_length(uint32_t negotiate_flags, const char *s);
_PUBLIC_ enum ndr_err_code ndr_push_AV_PAIR_LIST(struct ndr_push *ndr, int ndr_flags, const struct AV_PAIR_LIST *r);
_PUBLIC_ enum ndr_err_code ndr_pull_AV_PAIR_LIST(struct ndr_pull *ndr, int ndr_flags, struct AV_PAIR_LIST *r);
_PUBLIC_ void ndr_print_ntlmssp_nt_response(TALLOC_CTX *mem_ctx,
					    const DATA_BLOB *nt_response,
					    bool ntlmv2);
_PUBLIC_ void ndr_print_ntlmssp_lm_response(TALLOC_CTX *mem_ctx,
					    const DATA_BLOB *lm_response,
					    bool ntlmv2);
_PUBLIC_ void ndr_print_ntlmssp_Version(struct ndr_print *ndr, const char *name, const union ntlmssp_Version *r);

_PUBLIC_ struct AV_PAIR *ndr_ntlmssp_find_av(const struct AV_PAIR_LIST *av_list,
					     enum ntlmssp_AvId AvId);
#endif
