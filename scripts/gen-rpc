#!/usr/bin/env python3

from __future__ import print_function
import os, sys
from io import StringIO
import re, argparse, json

class OStream(object):
	def __init__(self, fp):
		self.fp = fp
	def write(self, s):
		self.fp.write(s)
	def __call__(self, s=''):
		try:
			if s[0] == '\n':
				s = s[1:]
		except:
			pass

		self.fp.write(s)
		try:
			if s[-1] == '\n':
				return
		except:
			pass
		self.fp.write('\n')

def _dbg_none(*args):
	pass

def _dbg_stderr(*args):
	print("DBG:", *args, file=sys.stderr)

DBG = _dbg_none

def warn(msg):
	print("Warning:", msg, file = sys.stderr)

def error(msg):
	print("Error:", msg, file = sys.stderr)


def tostring_properties__(data):
	if 'PROPERTIES' in data:
		ret = []
		for key, val in data['PROPERTIES'].items():
			if val != '1':
				ret.append(f'{key}({val})')
			else:
				ret.append(key)
		return '/* [' + ', '.join(ret) + '] */'
	else:
		return ''

def elem_tostring_properties(e):
	return tostring_properties__(e)

def typedef_tostring_properties(t):
	return tostring_properties__(t['DATA'])

def function_tostring_properties(t):
	return tostring_properties__(t)

def elem_get_ndr_flags(elem):
	ndr_flags = elem_get_property(elem, "flag")
	if ndr_flags is not None:
		return f'x_ndr_set_flags(__flags, {ndr_flags})'
	else:
		return '__flags'

def elem_get_pointer_type(elem, iface):
	for t in [ "unique", "relative" ]:
		try:
			v = elem["PROPERTIES"][t]
		except:
			continue
		assert v == "1"
		return t
	try:
		return iface['pointer_default']
	except:
		return "unique"

F_STRUCT = 0x1
F_UNION  = 0x2
F_FUNCTION = 0x4
know_properties = {
	'case': F_UNION,
	'default': F_UNION,
	'flag': F_STRUCT | F_UNION,
	'range': F_STRUCT | F_FUNCTION,
	'value': F_STRUCT | F_UNION,
	'charset': F_STRUCT | F_UNION | F_FUNCTION,
	'switch_is': F_STRUCT | F_FUNCTION,
	'switch_type': F_STRUCT,
	'size_is': F_STRUCT | F_FUNCTION,
	'in': F_FUNCTION, # TODO
	'out': F_FUNCTION, # TODO
	'unique': F_STRUCT | F_FUNCTION, # TODO
	'length_is': F_STRUCT | F_FUNCTION, # TODO
	'noprint': F_STRUCT | F_UNION, # TODO
	#'ignore': F_STRUCT | F_UNION, # TODO
	'x_ignored': F_STRUCT,
	'string': F_STRUCT | F_UNION | F_FUNCTION, # TODO
	'compression': F_STRUCT | F_UNION, # TODO
	'subcontext': F_STRUCT | F_UNION, # TODO rewrite
	'subcontext_size': F_STRUCT | F_UNION, # TODO rewrite
	'relative': F_STRUCT | F_UNION, # TODO rewrite
	'relative_short': F_STRUCT | F_UNION, # TODO rewrite
	'ref': F_STRUCT | F_UNION | F_FUNCTION, # TODO rewrite
	#'x_offset': F_STRUCT,
	'x_skip': F_STRUCT,
	'x_size': F_STRUCT,
	'x_ndr_size': F_STRUCT,
	#'x_with_size': F_STRUCT,
	'x_relative': F_STRUCT,
	'x_group_start': F_STRUCT,
	'x_group_end': F_STRUCT,
	'x_pull_value': F_STRUCT,
	'x_push_value': F_STRUCT,
}

def elem_check_properties(elem, t):
	if not 'PROPERTIES' in elem:
		return
	if t['TYPE'] == 'TYPEDEF':
		flag = F_STRUCT if typedef_get_realtype(t) == 'STRUCT' else F_UNION
	elif t['TYPE'] == 'FUNCTION':
		flag = F_FUNCTION
	else:
		assert False
	for name, value in elem['PROPERTIES'].items():
		try:
			flags = know_properties[name]
			if (flag & flags) == 0:
				error(f'at {elem["FILE"]}:{elem["LINE"]} Property {name} not support {flag}')
				assert False
		except KeyError:
			error(f"Unknown property {name}.")
			assert False

def elem_has_property(elem, *args):
	try:
		prop = elem['PROPERTIES']
	except:
		return False
	for arg in args:
		if arg in prop:
			return True
	return False

def get_property(t, prop, default = None):
	try:
		return t['PROPERTIES'][prop]
	except KeyError:
		return default

def elem_get_property(t, prop, default = None):
	return get_property(t, prop, default)

def typedef_get_property(t, prop, default = None):
	return get_property(t['DATA'], prop, default)

def elem_is_property_of(elem, t, *args):
	for me in typedef_get_elements(t):
		for prop in args:
			try:
				if elem["NAME"] == elem_get_property(me, prop):
					return me
			except:
				pass
	return None

def elem_is_expr_property_of(elem, t, *args):
	ename = elem["NAME"]
	for me in typedef_get_elements(t):
		for prop in args:
			value = elem_get_property(me, prop)
			if value is None:
				continue
			if any([ename == operand for operand in re.split(r'[^0-9a-zA-Z_.]+', value)]):
				return me
	return None

def elem_get_array_len(elem):
	try:
		array_len = elem['ARRAY_LEN']
		if len(array_len) == 0:
			return None
		assert len(array_len) == 1
		return array_len[0]
	except KeyError:
		return None

def elem_get_pointers(elem):
	try:
		v = elem['POINTERS']
	except KeyError:
		return 0
	if get_property(elem, 'ref'):
		assert v > 0
		v -= 1
	assert v in [0, 1, 2]
	return v

def elem_is_switch(f, union_fields):
	for uf, unions in union_fields:
		if uf["NAME"] == f["NAME"]:
			return len(unions) > 0
	else:
		return False

# TODO
def has_property(t, prop):
	v = get_property(t, prop)
	if v is None:
		return False
	assert v == '1'
	return True

def const_get_pointers(elem):
	try:
		v = elem['POINTERS']
	except KeyError:
		return 0
	assert v == 0
	return v

def typedef_has_property(t, prop):
	return has_property(t['DATA'], prop);

def typedef_get_elements(t):
	if t['TYPE'] == 'TYPEDEF':
		try:
			return t['DATA']['ELEMENTS']
		except:
			return []
	elif t['TYPE'] == 'FUNCTION':
		try:
			return t['ELEMENTS']
		except:
			return []
	else:
		assert False

def typedef_get_elem_by_name(t, name):
	for elem in typedef_get_elements(t):
		if elem['NAME'] == name:
			return elem
	return None

def typedef_get_realtype(t):
	return t['DATA']['TYPE']

known_simple_types = {
	# name, align, is_trival, has_buffers
	'EMPTY': [ 0, True, False],
	'void': [0, True, False],
	'char': [1, True, False],
	'int8': [1, True, False],
	'uint8': [1, True, False],
	'int16': [2, True, False],
	'uint16': [2, True, False],
	'int1632': [3, True, False],
	'uint1632': [3, True, False],
	'int': [4, True, False], # int32
	'int32': [4, True, False],
	'long': [4, True, False], # uint32
	'DWORD': [4, True, False],
	'WORD': [2, True, False],
	'uint32': [4, True, False],
	'mode_t': [4, True, False], # uint32
	'boolean8': [1, True, False],
	'boolean32': [4, True, False], # uint32
	'int3264': [5, True, False],
	'uint3264': [5, True, False],
	'uint64': [8, True, False],
	'double': [8, True, False],
	'pointer': [8, True, False],
	'dlong': [4, True, False],
	'udlong': [4, True, False],
	'udlongr': [4, True, False],
	'hyper': [4, True, False],
	'NTSTATUS': [4, True, False],
	'NTTIME': [4, True, False],
	'time_t': [4, True, False],
	'ipv4address': [4, True, False],
	'ipv6address': [4, True, False], #16?
	'WERROR': [4, True, False],
	'DATA_BLOB': [4, False, False],
        'u16string': [2, False, False],
        'u8string': [1, False, False],
}

alias_types = {
	# alias, type_name, traits_type, align
        'NTTIME_hyper': ['NTTIME', 'ndr_traits_NTTIME_hyper', 8],
	'dom_sid2': [ 'dom_sid', 'ndr_traits_dom_sid2', None],
	'u16string_remain': [ 'u16string', 'ndr_traits_u16string_remain', 1],
	'nstring': [ 'u16string', 'ndr_traits_nstring', 2],
	'astring': [ 'u8string', 'ndr_traits_astring', 1],
}

def find_type(idl, tname):
	for o in idl:
		if o['TYPE'] != "INTERFACE":
			continue
		for t in o['DATA']:
			if t['TYPE'] == "TYPEDEF" and t['NAME'] == tname:
				return t
	return None

def find_type_idl_tbl(idl_tbl, tname):
	for _, idl in idl_tbl.items():
		t = find_type(idl, tname)
		if t is not None:
			return t
	return None

def elem_get_base_type(t):
	ret = t['TYPE']
	try:
		ret, _, _ = alias_types[ret]
	except: pass
	return ret

def get_array_len(elem):
	try:
		array_len = elem['ARRAY_LEN']
		if len(array_len) == 0:
			return None
		assert len(array_len) == 1
		return array_len[0]
	except KeyError:
		return None

def elem_is_array_len_of(elem, st):
	for elem2 in typedef_get_elements(st):
		array_len = get_array_len(elem2)
		if elem['NAME'] == array_len:
			return elem2
	return None

def elem_get_case_str(elem):
	case_value = get_property(elem, 'case')
	if case_value is not None:
		return f'case {case_value}'
	else:
		assert has_property(elem, 'default')
		return 'default'

# samba/pidl/lib/Parse/Pidl/NDR.pm align_type
def elem_get_info(elem, idl_tbl):
	def get_info_1(elem):
		ndr_traits, align, is_trivial, has_buffers = None, None, None, None
		if elem_get_pointers(elem):
			# this is a hack for NDR64
			# the NDR layer translates this into
			# an alignment of 4 for NDR and 8 for NDR64
			align = 5
			has_buffers = True
			is_trivial = False

		array_len = get_array_len(elem)
		if array_len is not None:
			try:
				int(array_len)
			except ValueError:
				is_trivial = False

		base_type = elem['TYPE']
		try:
			base_type, ndr_traits, align_ = alias_types[base_type]
			if align is None:
				align = align_
		except KeyError: pass

		try:
			align_, is_trivial_, has_buffers_ = known_simple_types[base_type]
			if align is None:
				align = align_
			if has_buffers is None:
				has_buffers = has_buffers_
			if is_trivial is None:
				is_trivial = is_trivial_
			return 'PRIMARY', None, base_type, ndr_traits, align, is_trivial, has_buffers
		except KeyError: pass

		et = find_type_idl_tbl(idl_tbl, base_type)
		if et is None:
			raise NotFound(elem, base_type)

		data_type, align_, is_trivial_, has_buffers_ = get_info_typedef(et)
		if align is None:
			align = align_
		if has_buffers is None:
			has_buffers = has_buffers_
		if is_trivial is None:
			is_trivial = is_trivial_
		return data_type, et, base_type, ndr_traits, align, is_trivial, has_buffers
		
	def get_info_typedef(t):
		assert t["TYPE"] == "TYPEDEF"
		try:
			return t['my_info']
		except: pass

		ret = get_info_typedef_1(t)
		DBG(f'get_info_typedef({t["NAME"]}) = {ret}')
		t['my_info'] = ret
		return  ret
	
	def get_info_typedef_1(t):
		realtype = typedef_get_realtype(t)

		if realtype == "ENUM":
			_, ftype = map_enum_type(t)
			return [realtype, *known_simple_types[ftype]]
		elif realtype == "BITMAP":
			_, ftype = map_bitmap_type(t)
			return [realtype, *known_simple_types[ftype]]

		assert realtype in [ "STRUCT", "UNION" ]
		align, is_trivial, has_buffers = 1, True, False
		for elem in typedef_get_elements(t):
			_, _, _, _, align_, is_trivial_, has_buffers_ = get_info_1(elem)
			if align < align_:
				align = align_
			if not is_trivial_:
				is_trivial = False
			if has_buffers_:
				has_buffers = True
		return realtype, align, is_trivial, has_buffers

	class NotFound(Exception):
		def __init__(self, elem, base_type):
			self.elem, self.base_type = elem, base_type
	try:
		return get_info_1(elem)
	except NotFound as e:
		error(f'''Cannot find type "{e.base_type}" for "{e.elem["NAME"]}" at {e.elem['FILE']}:{e.elem['LINE']}''')
		raise

def normalize_stmt(s):
	if s is None:
		return []
	elif isinstance(s, str):
		return [ s ]
	else:
		return s
def append_stmts(orig_stmts, new_stmts):
	if orig_stmts is None:
		ret = []
	else:
		ret = orig_stmts[:]
	if new_stmts is not None:
		if isinstance(new_stmts, str):
			ret.append(new_stmts)
		else:
			ret += new_stmts
	return ret

class FieldBase(object):
	def __init__(self, json_elem, idl_tbl):
		self.data_type, self.typedef, self.base_type, self.ndr_traits, self.alignment, self.is_trivial, self.has_buffers = elem_get_info(json_elem, idl_tbl)
		#DBG(f'data_type={self.data_type}, base_type={self.base_type}, ndr_traits={self.ndr_traits}, alignment={self.alignment}, is_trivial={self.is_trivial}, has_buffers={self.has_buffers}')
		self.json_elem = json_elem
		self.name = json_elem['NAME']

		self.subcontext_size = None
		self.subcontext_level = self.get_property("subcontext")
		if self.subcontext_level is not None:
			self.subcontext_level = int(self.subcontext_level, 0)
			if self.subcontext_level == 0:
				self.subcontext_size = self.get_property("subcontext_size")
				assert self.subcontext_size is not None
				# TODO assert elem_get_pointers(self.json_elem)
			elif self.subcontext_level == 0xFFFFFC01:
				self.has_buffers_in_subwrapper, self.has_buffers = self.has_buffers, False
				assert not elem_get_pointers(self.json_elem)
			else:
				assert False
		self.x_ndr_sizes = []
		self.nontrivial_unions = []

	def declare(self):
		return self.declare__()
	def scalars(self, func):
		ndr_arg, bpos_arg, epos_arg, flags_arg = '__ndr', '__bpos', '__epos', '__flags'
		ret = []
		new_epos_arg = epos_arg
		if self.x_ndr_sizes and not self.has_buffers:
			if func == 'PUSH':
				ret.append(f'x_ndr_off_t __pos_{self.name} = {bpos_arg};')
			else:
				new_epos_arg = f'__epos_{self.name}';
				ret.append(f'x_ndr_off_t __epos_{self.name} = {epos_arg};')
				for ns in self.x_ndr_sizes:
					ret.append(f'__epos_{self.name} = X_NDR_CHECK_POS({bpos_arg} + __tmp_{ns.name}, {bpos_arg}, __epos_{self.name});')

		if self.subcontext_level == 0xFFFFFC01:
			ret.append(f'X_NDR_SUBWRAPPER_START_{func}({self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {flags_arg});')
			ret += normalize_stmt(self.scalars__(func, f'__subndr_{self.name}',
						f'__bpos_{self.name}', f'__epos_{self.name}', f'__flags_{self.name}'))
			if self.has_buffers_in_subwrapper:
				ret += normalize_stmt(self.buffers__(func, f'__subndr_{self.name}',
						f'__bpos_{self.name}', f'__epos_{self.name}', f'__flags_{self.name}'))
			ret.append(f'X_NDR_SUBWRAPPER_END_{func}({self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {flags_arg});')
				
		else:
			ret += normalize_stmt(self.scalars__(func, ndr_arg, bpos_arg, new_epos_arg, flags_arg))

		if self.x_ndr_sizes and not self.has_buffers:
			if func == 'PUSH':
				for ns in self.x_ndr_sizes:
					ret.append(f'X_NDR_SCALARS_SIMPLE({ns.get_ndr_traits()}, (__bpos - __pos_{self.name}), {ndr_arg}, __pos_{ns.name}, {epos_arg}, {ns.get_ndr_flags()}, X_NDR_SWITCH_NONE);')
		return ret
	def buffers(self, func):
		ndr_arg, bpos_arg, epos_arg, flags_arg = '__ndr', '__bpos', '__epos', '__flags'
		# TODO SizeIs, LengthIs may require this
		ret = []
		if not self.has_buffers:
			return ret

		if isinstance(self, FieldRelativePtr) or isinstance(self, FieldRelativeVector):
			ret.append(f'ndr_traits_at_t<ndr_traits_t<uint32>> __at_{self.name}{{ndr_traits_t<uint32>(), {ndr_arg}.load_pos(),{self.get_ndr_flags()}}};')
			#x_ndr_off_t __relptr_pos_{self.name} = {ndr_arg}.load_pos();')

		new_epos_arg = epos_arg
		new_ndr_arg = ndr_arg
		if self.x_ndr_sizes and func == 'PUSH':
			ret.append(f'x_ndr_off_t __pos_{self.name} = {bpos_arg};')
		if self.x_ndr_sizes and func == 'PULL':
			ret.append(f'x_ndr_off_t __epos_{self.name} = {epos_arg};')
			new_epos_arg = f'__epos_{self.name}';

		for ns in self.x_ndr_sizes:
			ret.append(f'x_ndr_off_t __pos_{ns.name} = {ndr_arg}.load_pos();')
			if func == 'PULL':
				ret.append(f'{ns.base_type} __tmp_{ns.name};')
				ret.append(f'X_NDR_SCALARS_SIMPLE({ns.get_ndr_traits()}, __tmp_{ns.name}, {ndr_arg}, __pos_{ns.name}, {epos_arg}, {ns.get_ndr_flags()}, X_NDR_SWITCH_NONE);')
				ret.append(f'__epos_{self.name} = X_NDR_CHECK_POS({bpos_arg} + __tmp_{ns.name}, {bpos_arg}, __epos_{self.name});')
		if self.subcontext_level == 0:
			if func == 'PUSH':
				ret.append(f'X_NDR_DO_ALIGN({ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags(flags_arg)});')
				ret.append(f'x_ndr_off_t __bpos_{self.name} = {bpos_arg};')
			else:
				ret.append(f'X_NDR_DO_ALIGN({ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags(flags_arg)});')
				ret.append(f'{self.subcontext_size.base_type} __tmp_{self.subcontext_size.name};')
				ret.append(f'X_NDR_SCALARS_SIMPLE({self.subcontext_size.get_ndr_traits()}, __tmp_{self.subcontext_size.name}, {ndr_arg}, __pos_{self.subcontext_size.name}, {epos_arg}, {self.subcontext_size.get_ndr_flags()}, X_NDR_SWITCH_NONE);')
				ret.append(f'x_ndr_off_t __epos_{self.name} = X_NDR_CHECK_POS({bpos_arg} + __tmp_{self.subcontext_size.name}, {bpos_arg}, {epos_arg});')
				new_epos_arg = f'__epos_{self.name}';

		if False and self.subcontext_size: # TODO other subcontext level
			if func == 'PUSH':
				ret.append(f'X_NDR_DO_ALIGN({ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags(flags_arg)});')
				ret.append(f'x_ndr_push_t __subndr_{self.name}({ndr_arg}.buff, {bpos_arg});')	
				ret.append(f'x_ndr_off_t __bpos_{self.name} = {bpos_arg};')
			else:
				ret.append(f'X_NDR_DO_ALIGN({ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags(flags_arg)});')
				ret.append(f'x_ndr_pull_t __subndr_{self.name}({ndr_arg}.buff, {bpos_arg});')	
				ret.append(f'{self.subcontext_size.base_type} __tmp_{self.subcontext_size.name};')
				ret.append(f'X_NDR_SCALARS_SIMPLE({self.subcontext_size.get_ndr_traits()}, __tmp_{self.subcontext_size.name}, {ndr_arg}, __pos_{self.subcontext_size.name}, {epos_arg}, {self.subcontext_size.get_ndr_flags()}, X_NDR_SWITCH_NONE);')
				ret.append(f'x_ndr_off_t __epos_{self.name} = X_NDR_CHECK_POS({bpos_arg} + __tmp_{self.subcontext_size.name}, {bpos_arg}, {epos_arg});')
				new_epos_arg = f'__epos_{self.name}';
			new_ndr_arg = f'__subndr_{self.name}'

		ret += normalize_stmt(self.buffers__(func, new_ndr_arg, bpos_arg, new_epos_arg, flags_arg))

		if self.subcontext_level == 0:
			if func == 'PUSH':
				ret.append(f'X_NDR_SCALARS_SIMPLE({self.subcontext_size.get_ndr_traits()}, ({bpos_arg} - __bpos_{self.name}), {ndr_arg}, __pos_{self.subcontext_size.name}, {epos_arg}, {self.subcontext_size.get_ndr_flags()}, X_NDR_SWITCH_NONE);')
			ret.append(f'X_NDR_DO_ALIGN({ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags(flags_arg)});')

		if False and self.subcontext_size: # TODO other subcontext level
			if func == 'PUSH':
				ret.append(f'X_NDR_SCALARS_SIMPLE({self.subcontext_size.get_ndr_traits()}, ({bpos_arg} - __bpos_{self.name}), {ndr_arg}, __pos_{self.subcontext_size.name}, {epos_arg}, {self.subcontext_size.get_ndr_flags()}, X_NDR_SWITCH_NONE);')
			ret.append(f'X_NDR_DO_ALIGN({ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags(flags_arg)});')

		if func == 'PUSH':
			for ns in self.x_ndr_sizes:
				ret.append(f'X_NDR_SCALARS_SIMPLE({ns.get_ndr_traits()}, (__bpos - __pos_{self.name}), {ndr_arg}, __pos_{ns.name}, {epos_arg}, {ns.get_ndr_flags()}, X_NDR_SWITCH_NONE);')

		return ret
	def ostr(self):
		return normalize_stmt(self.ostr__())
	def get_property(self, prop, default = None):
		return get_property(self.json_elem, prop, default)
	def get_ndr_traits(self):
		if self.ndr_traits:
			return self.ndr_traits
		else:
			return f'ndr_traits_t<{self.base_type}>'
	def get_switch_is(self):
		switch_is = self.get_property('switch_is')
		if switch_is is None:
			return 'X_NDR_SWITCH_NONE'
		else:
			ro = re.compile('[A-Za-z_][A-Za-z0-9_]*')
			pos, comps = 0, []
			while True:
				m = ro.search(switch_is, pos)
				if not m:
					break
				start, end = m.span()
				if start != pos:
					comps.append(switch_is[pos:start])
				op_name = switch_is[start:end]
				for f in self.fields:
					if f.name == op_name:
						comps.append('__val.')
						break
				comps.append(op_name)
				pos = end
			comps.append(switch_is[pos:])
			return ''.join(comps)
	def get_ndr_flags(self, flag_arg = '__flags'):
		flag = self.get_property('flag')
		if flag is None:
			return flag_arg
		else:
			return f'x_ndr_set_flags({flag_arg}, {flag})'
	def get_properties_string(self):
		return elem_tostring_properties(self.json_elem)

class FieldDerived(FieldBase):
	def declare__(self):
		return f'/* {self.base_type} {self.name}; */'
	def ostr__(self):
		return None

class FieldSimple(FieldBase):
	def __init__(self, json_elem, idl_tbl):
		super().__init__(json_elem, idl_tbl)
	
	def declare__(self):
		return f'{self.base_type} {self.name};'

	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'

	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_BUFFERS_SIMPLE({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'

	def ostr__(self):
		return f'X_NDR_OSTR_SIMPLE({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldXSize(FieldDerived):
	def __init__(self, json_elem, idl_tbl):
		super().__init__(json_elem, idl_tbl)
		assert self.base_type in [ 'uint8', 'uint16', 'uint32' ]
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_XSIZE_{func}({self.base_type}, {self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()});'

class FieldValue(FieldDerived):
	def __init__(self, json_elem, idl_tbl, value, array_len):
		super().__init__(json_elem, idl_tbl)
		assert self.data_type in ['ENUM', 'BITMAP' ] or self.base_type in [ 'uint8', 'uint16', 'uint32' ]
		self.value, self.array_len = value, array_len
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		if self.array_len is not None:
			ctype = f'std::array<{self.base_type}, {self.array_len}>'
			return f'X_NDR_SCALARS_ARRAY_VALUE({self.get_ndr_traits()}, ({ctype}{{{self.value}}}), {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
		else:
			ctype = self.base_type
			return f'X_NDR_SCALARS_VALUE({self.get_ndr_traits()}, ({ctype}{{{self.value}}}), {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldVectorLen(FieldDerived):
	def __init__(self, json_elem, idl_tbl, vector_name):
		super().__init__(json_elem, idl_tbl)
		assert self.base_type in [ 'uint8', 'uint16', 'uint32' ]
		self.vector_name = vector_name
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_VECTOR_LEN_{func}({self.base_type}, {self.name}, {self.vector_name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()});'

class FieldXNdrSize(FieldDerived):
	def __init__(self, json_elem, idl_tbl, ndr_size_elem):
		super().__init__(json_elem, idl_tbl)
		self.ndr_size_elem = ndr_size_elem
		assert self.get_property('switch_is') is None
	def set_size_field(self, field):
		self.ndr_size_field = field
		self.has_buffers = field.has_buffers
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		if self.ndr_size_field.has_buffers:
			return f'X_NDR_SAVE_POS({self.base_type}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()});'
		elif func == 'PUSH':
			return [ f'x_ndr_off_t __pos_{self.name} = {bpos_arg};',
				f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, {self.base_type}(), {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, X_NDR_SWITCH_NONE);' ]
		else:
			return [ f'{self.base_type} __tmp_{self.name};',
				f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, __tmp_{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, X_NDR_SWITCH_NONE);' ]
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		assert self.has_buffers
		return f'x_ndr_off_t __pos_{self.name} = {ndr_arg}.load_pos();'

class FieldSubctxSize(FieldDerived):
	def __init__(self, json_elem, idl_tbl, subcontext_size_of):
		super().__init__(json_elem, idl_tbl)
		self.subcontext_size_of = subcontext_size_of
		assert self.get_property('switch_is') is None
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		if self.has_buffers:
			return f'X_NDR_SAVE_POS({self.base_type}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()});'
		else:
			assert False, 'TODO'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		assert self.has_buffers
		return f'x_ndr_off_t __pos_{self.name} = {ndr_arg}.load_pos();'

class FieldArray(FieldBase):
	def __init__(self, json_elem, idl_tbl, array_size):
		super().__init__(json_elem, idl_tbl)
		self.array_size = array_size
	def declare__(self):
		return f'std::array<{self.base_type}, {self.array_size}> {self.name};'
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SCALARS_ARRAY({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def ostr__(self):
		return f'X_NDR_OSTR_ARRAY({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldVector(FieldBase):
	def __init__(self, json_elem, idl_tbl, array_len_elem):
		super().__init__(json_elem, idl_tbl)
		self.array_len_elem = array_len_elem
	def declare__(self):
		return f'std::vector<{self.base_type}> {self.name};'
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SCALARS_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_BUFFERS_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def ostr__(self):
		return f'X_NDR_OSTR_VECTOR({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldSizeIs(FieldDerived):
	def __init__(self, json_elem, idl_tbl, size_is_of):
		super().__init__(json_elem, idl_tbl)
		assert self.base_type in [ 'uint8', 'uint16', 'uint32', 'uint3264' ]
		assert self.get_property('switch_is') is None
		self.size_is_of = size_is_of
		self.has_buffers = True
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SAVE_POS({self.base_type}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		assert self.has_buffers
		ret = [ f'ndr_traits_at_t<ndr_traits_t<{self.base_type}>> __at_{self.name}{{ndr_traits_t<{self.base_type}>(), {ndr_arg}.load_pos(), {self.get_ndr_flags()}}};' ]
		if self.order > self.size_is_of.order:
			ret.append(f'X_NDR_SIZE_AT(__at_{self.name}, {ndr_arg}, __val.{self.size_is_of.name}, {epos_arg});')
		return ret
		'''
		return f'ndr_traits_at_t<ndr_traits_t<{self.base_type}>> __at_{self.name}{{ndr_traits_t<{self.base_type}>(), {ndr_arg}.load_pos(), {self.get_ndr_flags()}}};'
		if func == 'PUSH':
			ret = [ f'{self.base_type} __tmp_{self.name} = vector_ptr_get_size(__val.{self.size_is_of.name});' ]
		else:
			ret = [ f'{self.base_type} __tmp_{self.name};' ]
		ret.append(f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, __tmp_{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, X_NDR_SWITCH_NONE);')
		return ret
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_BUFFERS_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
		'''

FieldLengthIs = FieldSizeIs

class FieldString(FieldBase):
	def __init__(self, json_elem, idl_tbl, string_type):
		super().__init__(json_elem, idl_tbl)
		self.string_type = string_type
		if self.ndr_traits is None:
			self.ndr_traits = f'ndr_traits_t<{string_type}>'
	def declare__(self):
		return f'{self.string_type} {self.name};'
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SCALARS_STRING({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def ostr__(self):
		return f'X_NDR_OSTR_STRING({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldPtr(FieldBase):
	def __init__(self, json_elem, idl_tbl):
		super().__init__(json_elem, idl_tbl)
		assert self.has_buffers or self.in_subcontext
	
	def declare__(self):
		return f'std::shared_ptr<{self.base_type}> {self.name};'

	def ostr__(self):
		return f'X_NDR_OSTR_PTR({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldRelativePtr(FieldPtr):
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SAVE_POS(uint32, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_BUFFERS_RELATIVE_PTR__0({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()}, __at_{self.name});'

class FieldRelativeVector(FieldPtr):
	def __init__(self, json_elem, idl_tbl, pointers, size_is, length_is):
		super().__init__(json_elem, idl_tbl)
		self.pointers, self.size_is, self.length_is = pointers, size_is, length_is
	def declare__(self):
		base_type = self.base_type
		for _ in range(self.pointers - 1):
			base_type = f'std::shared_ptr<{base_type}>'
		return f'std::shared_ptr<std::vector<{base_type}>> {self.name}; /* FieldRelativeVector */'
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SAVE_POS(uint32, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		ret = [f'X_NDR_BUFFERS_RELATIVE_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()}, __at_{self.name}, {"true" if self.length_is else "false"});' ]
		if self.order > self.size_is.order:
			ret.append(f'X_NDR_SIZE_AT(__at_{self.size_is.name}, {ndr_arg}, __val.{self.name}, {epos_arg});')
		if self.length_is and self.order > self.length_is.order:
			ret.append(f'X_NDR_SIZE_AT(__at_{self.length_is.name}, {ndr_arg}, __val.{self.name}, {epos_arg});')
		return ret
	def ostr__(self):
		return f'x_ndr_ostr_ptr_vector({self.get_ndr_traits()}{{}}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'
		#return f'X_NDR_OSTR_PTR_VECTOR({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldUniquePtr(FieldPtr):
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SCALARS_UNIQUE_PTR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_BUFFERS_UNIQUE_PTR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldUniqueVector(FieldPtr):
	def __init__(self, json_elem, idl_tbl, pointers, size_is, length_is):
		super().__init__(json_elem, idl_tbl)
		self.pointers, self.size_is, self.length_is = pointers, size_is, length_is
	def declare__(self):
		base_type = self.base_type
		for _ in range(self.pointers - 1):
			base_type = f'std::shared_ptr<{base_type}>'
		return f'std::shared_ptr<std::vector<{base_type}>> {self.name}; /* FieldUniqueVector */'
	def get_ndr_traits(self):
		assert self.ndr_traits is None, 'TODO'

		ndr_traits = super().get_ndr_traits()
		base_type = self.base_type
		for _ in range(self.pointers - 1):
			ndr_traits = f'ndr_traits_unique_ptr_t<{base_type}, {ndr_traits}>'
			base_type = f'std::shared_ptr<{base_type}>'
		return ndr_traits
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_VERIFY(({bpos_arg}), x_ndr_scalars_unique_vector(__val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()}));'
		#return f'X_NDR_SCALARS_UNIQUE_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		ret = [ f'X_NDR_VERIFY(({bpos_arg}), x_ndr_buffers_unique_vector({self.get_ndr_traits()}{{}}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()}, {"true" if self.length_is else "false"}));' ]
		#ret = [ f'X_NDR_BUFFERS_UNIQUE_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()}, {"true" if self.length_is else "false"});' ]
		if self.order > self.size_is.order:
			ret.append(f'X_NDR_SIZE_AT(__at_{self.size_is.name}, {ndr_arg}, __val.{self.name}, {epos_arg});')
		if self.length_is and self.order > self.length_is.order:
			ret.append(f'X_NDR_SIZE_AT(__at_{self.length_is.name}, {ndr_arg}, __val.{self.name}, {epos_arg});')
		return ret
	def ostr__(self):
		return f'x_ndr_ostr_ptr_vector({self.get_ndr_traits()}{{}}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'
		#return f'X_NDR_OSTR_PTR_VECTOR({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldUniqueString(FieldPtr):
	def __init__(self, json_elem, idl_tbl, string_type):
		super().__init__(json_elem, idl_tbl)
		self.string_type = string_type
		if self.ndr_traits is None:
			self.ndr_traits = f'ndr_traits_t<{string_type}>'
	def declare__(self):
		return f'std::shared_ptr<{self.string_type}> {self.name};'
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SCALARS_UNIQUE_STRING({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_BUFFERS_UNIQUE_STRING({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def ostr__(self):
		return f'X_NDR_OSTR_STRING_PTR({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldRelativeString(FieldPtr):
	def __init__(self, json_elem, idl_tbl, string_type):
		super().__init__(json_elem, idl_tbl)
		self.string_type = string_type
		if self.ndr_traits is None:
			self.ndr_traits = f'ndr_traits_t<{string_type}>'
	def declare__(self):
		return f'std::shared_ptr<{self.string_type}> {self.name};'
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SCALARS_RELATIVE_STRING({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_BUFFERS_RELATIVE_STRING({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def ostr__(self):
		return f'X_NDR_OSTR_STRING_PTR({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'


def make_field(elem, t, iface, idl_tbl):
	elem_check_properties(elem, t)
	pointer_type = elem_get_pointer_type(elem, iface)
	array_len_name = elem_get_array_len(elem)
	pointers = elem_get_pointers(elem)

	if elem_has_property(elem, 'x_size'):
		assert pointers == 0
		return FieldXSize(elem, idl_tbl)

	master_elem = elem_is_property_of(elem, t, 'subcontext_size')
	if master_elem:
		# TODO assert elem_get_pointers(master_elem)
		return FieldSubctxSize(elem, idl_tbl, master_elem['NAME'])

	value = elem_get_property(elem, 'value')
	if value:
		assert pointers == 0
		if array_len_name:
			array_len_name = int(array_len_name)
		return FieldValue(elem, idl_tbl, value, array_len_name)

	ndr_size_elem = elem_get_property(elem, 'x_ndr_size')
	if ndr_size_elem:
		assert pointers == 0
		return FieldXNdrSize(elem, idl_tbl, ndr_size_elem)

	array_len_of_elem = elem_is_array_len_of(elem, t)
	if array_len_of_elem:
		assert pointers == 0
		return FieldVectorLen(elem, idl_tbl, array_len_of_elem['NAME'])

	size_is_of = elem_is_expr_property_of(elem, t, "size_is")
	if size_is_of:
		assert pointers == 0
		return FieldSizeIs(elem, idl_tbl, size_is_of['NAME'])

	length_is_of = elem_is_expr_property_of(elem, t, "length_is")
	if length_is_of:
		assert pointers == 0
		return FieldLengthIs(elem, idl_tbl, length_is_of['NAME'])

	charset = elem_get_property(elem, "charset")
	if charset == "UTF16":
		assert elem['TYPE'] == 'uint16'
		string_type = "std::u16string"
	elif charset == "DOS":
		assert elem['TYPE'] == 'uint8'
		string_type = "std::string"
	else:
		assert charset is None
	if charset and pointers == 0:
		return FieldString(elem, idl_tbl, string_type)
	elif charset and pointers > 0:
		assert pointers == 1
		if pointer_type == "relative":
			return FieldRelativeString(elem, idl_tbl, string_type)
		elif pointer_type == "unique":
			return FieldUniqueString(elem, idl_tbl, string_type)
		else:
			assert False

	if array_len_name is not None:
		assert pointers == 0
		try:
			array_len = int(array_len_name)
			return FieldArray(elem, idl_tbl, array_len)
		except:
			return FieldVector(elem, idl_tbl, array_len_name)

	if pointers == 0:
		return FieldSimple(elem, idl_tbl)

	assert pointer_type in [ "relative", "unique" ]
	size_is = elem_get_property(elem, "size_is")
	length_is = elem_get_property(elem, "length_is")
	assert not length_is or size_is

	if pointer_type == "relative":
		assert pointers == 1
		if size_is or length_is:
			return FieldRelativeVector(elem, idl_tbl, pointers, size_is, length_is)
		else:
			return FieldRelativePtr(elem, idl_tbl)
	elif pointer_type == "unique":
		if size_is or length_is:
			return FieldUniqueVector(elem, idl_tbl, pointers, size_is, length_is)
		else:
			assert pointers == 1
			return FieldUniquePtr(elem, idl_tbl)
	assert False

def make_fields(t, iface, idl_tbl):
	fields = [ make_field(e, t, iface, idl_tbl) for e in typedef_get_elements(t) ]
	for order, field in enumerate(fields):
		field.order, field.fields = order, fields
		if isinstance(field, FieldXNdrSize):
			for f in fields:
				if f.name == field.ndr_size_elem:
					f.x_ndr_sizes.append(field)
					field.ndr_size_field = f
					break
			else:
				assert False, f'Cannot find x_ndr_size {field.size_elem_name}'
		elif isinstance(field, FieldUniqueVector) or isinstance(field, FieldRelativeVector):
			for f in fields:
				if f.name == field.size_is:
					f.size_is_of = field
					field.size_is = f
				if f.name == field.length_is: # length_is and size_is can be same field
					f.size_is_of = field
					field.length_is = f
			#assert field.size_is is None or isinstance(field.size_is, FieldSizeIs)
			#assert field.length_is is None or isinstance(field.length_is, FieldSizeIs)
		elif isinstance(field, FieldSubctxSize):
			for f in fields:
				if f.name == field.subcontext_size_of:
					field.subcontext_size_of = f
					field.has_buffers = f.has_buffers
					f.subcontext_size = field
					break
			else:
				assert False
		if field.data_type == 'UNION' and not field.is_trivial:
			switch_is = field.get_property('switch_is')
			switch_is = switch_is.split('&')[0] # TODO
			for f in fields:
				if f.name == switch_is:
					f.nontrivial_unions.append(field)
					break
			else:
				assert False
				
	return fields

def output_header_element(out, field):
	out(f'''
	{field.declare()}{field.get_properties_string()}
''')

def output_header_STRUCT(out, t, iface, idl, idl_tbl):
	fields = make_fields(t, iface, idl_tbl)
	tname = t["NAME"]

	has_buffers, has_nontrivial_unions, all_nontrivial_unions_are_ptr = False, False, True
	for field in fields:
		if field.has_buffers:
			has_buffers = True
		if field.nontrivial_unions:
			has_nontrivial_unions = True
			for nf in field.nontrivial_unions:
				if not isinstance(nf, FieldPtr):
					all_nontrivial_unions_are_ptr = False

	out(f'''

struct {tname} {{
''')
	if any([len(f.nontrivial_unions) > 0 for f in fields]):
		out(f'''
	{tname}();
	~{tname}();
	{tname}({tname}&& other){" = default" if all_nontrivial_unions_are_ptr else ""};
	{tname}(const {tname}& other){" = default" if all_nontrivial_unions_are_ptr else ""};
	{tname} &operator=(const {tname}& other) = delete;
	{tname} &operator=({tname}&& other) = delete;
''')
		for switch_field in fields:
			if len(switch_field.nontrivial_unions) == 0:
				continue
			# TODO if elem_has_property(switch_field, 'value'):
			#	continue
			out(f'''
	void set_{switch_field.name}({switch_field.base_type} v);
''')

	for field in fields:
		output_header_element(out, field)
	out(f'''
}} {typedef_tostring_properties(t)};

template <> struct ndr_traits_t<{tname}> {{
	using ndr_base_type = {tname};
	using has_buffers = std::{"true" if has_buffers else "false"}_type;
	using ndr_data_type = x_ndr_type_struct;

	x_ndr_off_t scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	if has_buffers:
		out(f'''
	x_ndr_off_t buffers(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t buffers({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	out(f'''
	void ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};


''')

def get_first_case(typedef):
	for elem in typedef_get_elements(typedef):
		case = get_property(elem, "case")
		if case is not None:
			return case, elem
	
def output_struct_functions(idl, tname, fields, out):
	def union_field_iter(union_fields):
		for uf in union_fields:
			switch_is = uf.get_property("switch_is")
			yield uf, switch_is, isinstance(uf, FieldPtr)
	
	has_buffers, has_nontrivial_unions, all_nontrivial_unions_are_ptr = False, False, True
	for field in fields:
		if field.has_buffers:
			has_buffers = True
		if field.nontrivial_unions:
			has_nontrivial_unions = True
			for nf in field.nontrivial_unions:
				if not isinstance(nf, FieldPtr):
					all_nontrivial_unions_are_ptr = False

	for field in fields:
		if len(field.nontrivial_unions) == 0:
			continue
		out(f'''
void {tname}::set_{field.name}({field.base_type} v)
{{''')
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_uninit({uf.name}, x_ndr_switch_t({switch_is}));''')
		out(f'''
	{field.name} = v;''')
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}));''')
		out(f'''
}}

{tname}::{tname}()''')
	sep = ':'
	for field in fields:
		if len(field.nontrivial_unions) == 0:
			continue
		first_case, _ = get_first_case(field.nontrivial_unions[0].typedef)
		out(f'''
	{sep} {field.name}(({field.base_type}){first_case})''')
		sep = ','
	out('{')
	for field in fields:
		if len(field.nontrivial_unions) == 0:
			continue
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}));''')
	out(f'''
}}

{tname}::~{tname}()
{{''')
	for field in fields:
		if len(field.nontrivial_unions) == 0:
			continue
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_uninit({uf.name}, x_ndr_switch_t({switch_is}));''')
	out(f'''
}}

#if 0
TODO
{tname} &{tname}::operator=(const {tname} &other)
{{''')
	for field in fields:
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_uninit({uf.name}, x_ndr_switch_t({switch_is}));''')
		if not isinstance(field, FieldDerived) and (field.data_type != "UNION" or field.is_trivial):
			out(f'''
	{field.name} = other.{field.name};''')
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}), other.{uf.name});''')
	out(f'''
	return *this;
}}
#endif
''')
	if not all_nontrivial_unions_are_ptr:
		out(f'''
{tname}::{tname}({tname} &&other)''')
		sep = ':'
		for field in fields:
			if not isinstance(field, FieldDerived) and (field.data_type != "UNION" or field.is_trivial):
				out(f'''	{sep} {field.name}(other.{field.name})''')
				sep = ','
		out('{')		
		for field in fields:
			if len(field.nontrivial_unions) == 0:
				continue
			for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
				out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}), std::move(other.{uf.name}));''')
		out(f'''
}}

{tname}::{tname}(const {tname} &other)''')
		sep = ':'
		for field in fields:
			if not isinstance(field, FieldDerived) and (field.data_type != "UNION" or field.is_trivial):
				out(f'''	{sep} {field.name}(other.{field.name})''')
				sep = ','
		out('{')		
		for field in fields:
			if len(field.nontrivial_unions) == 0:
				continue
			for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
				out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}), other.{uf.name});''')
		out(f'''
}}

''')

def output_ndrcxx_struct_scalars(out, func, fields, t, iface, idl, idl_tbl):
	flag = typedef_get_property(t, 'flag')
	if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
	alignment = max([field.alignment for field in fields]) if fields else 1
	out(f'''
	X_NDR_HEADER_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);
''')
	if any([isinstance(field, FieldXSize) for field in fields]):
		out(f'''
	x_ndr_off_t __base = __bpos;
''')

	for field in fields:
		for stmt in field.scalars(func):
			out(f'''
	{stmt}''')

	if func == 'PUSH':
		for field in fields:
			if isinstance(field, FieldXSize):
				out(f'''
	X_NDR_SCALARS_SIMPLE({field.get_ndr_traits()}, (__bpos - __base), __ndr, __pos_{field.name}, __epos, {field.get_ndr_flags()}, {field.get_switch_is()});''')
	else:
		if any([isinstance(field, FieldXSize) for field in fields]):
			out(f'''
	__bpos = __epos;''')

	out(f'''
	X_NDR_TRAILER_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);''')

def find_elem_by_name(elems, name):
	for e in elems:
		if e.name == name:
			return e
	return None

def output_ndrcxx_struct_buffers(out, func, fields, t, iface, idl, idl_tbl):
	for field in fields:
		for stmt in field.buffers(func):
			out(f'''
	{stmt}''')

def output_ndrcxx_STRUCT(out, t, iface, idl, idl_tbl):
	fields = make_fields(t, iface, idl_tbl)
	tname = t["NAME"]
	has_buffers = any([field.has_buffers for field in fields])
	out(f'''

/***** Generated function for {tname} *****/

''')

	if any([len(f.nontrivial_unions) > 0 for f in fields]):
		output_struct_functions(idl, tname, fields, out)

	if not typedef_has_property(t, "nopush"):
		out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		output_ndrcxx_struct_scalars(out, 'PUSH', fields, t, iface, idl, idl_tbl)
		out(f'''
	return __bpos;
}}

''')

		if has_buffers:
			out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::buffers(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			output_ndrcxx_struct_buffers(out, 'PUSH', fields, t, iface, idl, idl_tbl)
			out(f'''
	return __bpos;
}}

''')

	if not typedef_has_property(t, "nopull"):
		out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		output_ndrcxx_struct_scalars(out, 'PULL', fields, t, iface, idl, idl_tbl)
		out(f'''
	return __bpos;
}}

''')
		if has_buffers:
			out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::buffers({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			output_ndrcxx_struct_buffers(out, 'PULL', fields, t, iface, idl, idl_tbl)
			out(f'''
	return __bpos;
}}

''')

	if not typedef_has_property(t, "noprint"):
		out(f'''
void ndr_traits_t<{tname}>::ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const
{{''')
		flag = typedef_get_property(t, 'flag')
		if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
		out(f'''
	__ndr << enter;''');
		for field in fields:
			stmts = field.ostr()
			if len(stmts): out(f'''
	__ndr << "{field.name}:";''')
			for stmt in stmts:
				out(f'''
	{stmt}''')
			if len(stmts): out(f'''
	__ndr << next;''')
		out(f'''
	__ndr << leave;
}}

''')


def output_header_UNION(out, t, iface, idl, idl_tbl):
	fields = make_fields(t, iface, idl_tbl)
	tname = t["NAME"]
	out(f'''

union {tname}
{{
''')
	if any([not field.is_trivial for field in fields]):
		out(f'''
	{tname}() {{ }}
	~{tname}() {{ }}
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, {tname} &&__other);
	void __init(x_ndr_switch_t __level, const {tname} &__other);
	void __uninit(x_ndr_switch_t __level);
''')
	# union member may has same name
	unique_fields = { }
	for field in fields:
		if field.name == '':
			continue
		try:
			prev = unique_fields[field.name]
			assert prev.base_type == field.base_type
		except KeyError:
			output_header_element(out, field)
			unique_fields[field.name] = field
	out(f'''
}} {typedef_tostring_properties(t)};

template <> struct ndr_traits_t<{tname}> {{
	using ndr_base_type = {tname};
	using has_buffers = std::{"true_type" if any([field.has_buffers for field in fields]) else "false_type"};
	using ndr_data_type = x_ndr_type_union;

	x_ndr_off_t scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	if any([field.has_buffers for field in fields]): out(f'''
	x_ndr_off_t buffers(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t buffers({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	out(f'''
	void ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};
''')

def get_case_str(field):
	case_value = field.get_property('case')
	if case_value is not None:
		return f'case {case_value}'
	else:
		assert field.get_property('default')
		return 'default'

def union_field_for_each():
	pass

def output_ndrcxx_union_scalars(out, func, fields, t, iface, idl, idl_tbl):
	flag = typedef_get_property(t, 'flag')
	if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
	alignment = max([f.alignment for f in fields])
	out(f'''
	X_NDR_UNION_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);
	switch (__level) {{
''')
	for field in fields:
		stmts = None
		if field.name != '':
			stmts = field.scalars(func)
		if stmts:
			out(f'''
		{get_case_str(field)}: {{''')
			for stmt in stmts:
				out(f'''
			{stmt}''')
			out(f'''
		}} break;
''')
	out('''
	}
''')

def output_ndrcxx_union_buffers(out, func, fields, t, iface, idl, idl_tbl):
	flag = typedef_get_property(t, 'flag')
	if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
	out(f'''
	switch (__level) {{
''')
	for field in fields:
		stmts = None
		if field.name != '' and field.has_buffers:
			stmts = field.buffers(func)
		if stmts:
			out(f'''
		{get_case_str(field)}: {{''')
			for stmt in stmts:
				out(f'''
			{stmt}''')
			out(f'''
		}} break;
''')
	out('''
	}
''')

def output_ndrcxx_UNION(out, t, iface, idl, idl_tbl):
	fields = make_fields(t, iface, idl_tbl)
	tname = t["NAME"]

	if any([not field.is_trivial for field in fields]):
		out(f'''

void {tname}::__init(x_ndr_switch_t __level)
{{
	switch (__level) {{''')
		for field in fields:
			if field.name != '':
				in_case_str = f' construct({field.name});'
			else:
				in_case_str = ''
			out(f'''
		{get_case_str(field)}:{in_case_str} break;''')
		out(f'''
	}}
}}

void {tname}::__init(x_ndr_switch_t __level, {tname} &&other)
{{
	switch (__level) {{''')
		for field in fields:
			if field.name != '':
				in_case_str = f' construct({field.name}, std::move(other.{field.name}));'
			else:
				in_case_str = ''
			out(f'''
		{get_case_str(field)}:{in_case_str} break;''')
		out(f'''
	}}
}}

void {tname}::__init(x_ndr_switch_t __level, const {tname} &other)
{{
	switch (__level) {{''')
		for field in fields:
			if field.name != '':
				in_case_str = f' construct({field.name}, other.{field.name});'
			else:
				in_case_str = ''
			out(f'''
		{get_case_str(field)}:{in_case_str} break;''')
		out(f'''
	}}
}}

void {tname}::__uninit(x_ndr_switch_t __level)
{{
	switch (__level) {{''')
		for field in fields:
			if field.name != '':
				in_case_str = f' destruct({field.name});'
			else:
				in_case_str = ''
			out(f'''
		{get_case_str(field)}:{in_case_str} break;''')
		out(f'''
	}}
}}
''')

	has_buffers = any([field.has_buffers for field in fields])

	if not typedef_get_property(t, "nopush"):
		out(f'''

x_ndr_off_t ndr_traits_t<{tname}>::scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		output_ndrcxx_union_scalars(out, 'PUSH', fields, t, iface, idl, idl_tbl)
		out(f'''
	return __bpos;
}}

''')
		if has_buffers:
			out(f'''

x_ndr_off_t ndr_traits_t<{tname}>::buffers(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			output_ndrcxx_union_buffers(out, 'PUSH', fields, t, iface, idl, idl_tbl)
			out(f'''
	return __bpos;
}}

''')
	if not typedef_get_property(t, "nopull"):
		out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		output_ndrcxx_union_scalars(out, 'PULL', fields, t, iface, idl, idl_tbl)
		out(f'''
	return __bpos;
}}

''')
		if has_buffers:
			out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::buffers({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			output_ndrcxx_union_buffers(out, 'PULL', fields, t, iface, idl, idl_tbl)
			out(f'''
	return __bpos;
}}

''')

	if not typedef_has_property(t, "noprint"):
		out(f'''
void ndr_traits_t<{tname}>::ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const
{{''')
		flags = typedef_get_property(t, 'flags')
		if flags is not None: out(f'''
	x_ndr_set_flags(__flags, {flags});''')
		out(f'''
	switch (__level) {{
''')
		for field in fields:
			if field.name != '':
				for stmt in field.ostr(): out(f'''
		{get_case_str(field)}: {stmt} break;''')
		out(f'''
	}}
}}

''')


def map_enum_type(t):
	assert t['DATA']['TYPE'] == "ENUM"

	# for typedef enum { } we need to check $enum->{PARENT}
	if typedef_has_property(t, "enum8bit"):
		return "uint8", "uint8"
	elif typedef_has_property(t, "enum16bit"):
		return "uint16", "uint16"
	elif typedef_has_property(t, "v1_enum"):
		return "uint32", "uint32"
	else:
		warn(f'at {t["FILE"]}:{t["LINE"]} unknown enum properties {t["DATA"].get("PROPERTIES", None)}')
		# should be uint16? TODO
		return "uint16", "uint1632"

def output_header_ENUM(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	elements = typedef_get_elements(t)
	etype, fname = map_enum_type(t)
	out(f'''

enum {tname} : {etype} {{
''')
	for elem in elements:
		out(f'''
	{elem},
''')
		#out(re.sub(r'^(.*)=(.*)$', r'\1=\2,', elem))
	out(f'''
}}{typedef_tostring_properties(t)};

X_NDR_DECLARE_TRAITS_ENUM({tname}, {etype}, {len(elements)}, x_ndr_type_enum)

''')

def output_ndrcxx_ENUM(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	etype, fname = map_enum_type(t)
	tdata = t['DATA']
	if not "ELEMENTS" in tdata:
		return
	out(f'''
const std::array<std::pair<{etype}, const char *>, {len(tdata["ELEMENTS"])}> ndr_traits_t<{tname}>::value_name_map = {{ {{
''')
	for elem in tdata["ELEMENTS"]:
		ev = elem.split('=')[0]
		out(f'''
	{{ {ev}, "{ev}" }},
''')
	out('''
} };


''')

def map_bitmap_type(t):
	assert t['DATA']['TYPE'] == "BITMAP"

	if typedef_has_property(t, "bitmap8bit"):
		return "uint8", "uint8"
	elif typedef_has_property(t, "bitmap16bit"):
		return "uint16", "uint16"
	elif typedef_has_property(t, "bitmap32bit"):
		return "uint32", "uint32"
	elif typedef_has_property(t, "bitmap64bit"):
		return "uint64", "uint64"
	else:
		warn(f'at {t["FILE"]}:{t["LINE"]} {t["NAME"]} unknown bits')
		return "uint32", "uint32"

def output_header_BITMAP(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	etype, fname = map_bitmap_type(t)
	elements = typedef_get_elements(t)
	out(f'''

enum {tname} : {etype} {{
''')
	for elem in elements:
		statement = re.sub(r'^([^ ]+) *\( *([^ ]+) *\)$', r'\1=\2,', elem)
		out(f'''
	{statement}
''')
	out(f'''
}}{typedef_tostring_properties(t)};

X_NDR_DECLARE_TRAITS_ENUM({tname}, {etype}, {len(elements)}, x_ndr_type_bitmap)

''')

def output_ndrcxx_BITMAP(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	etype, fname = map_bitmap_type(t)
	elements = typedef_get_elements(t)
	out(f'''
const std::array<std::pair<{etype}, const char *>, {len(elements)}> ndr_traits_t<{tname}>::value_name_map = {{ {{''')
	for elem in elements:
		ev = re.sub(r'^([^ ]+) *\( *([^ ]+) *\)$', r'\1', elem)
		out(f'''
	{{ {ev}, "{ev}" }},
''')
	out('''
} };


''')

def output_header_FUNCTION(out, t, iface, idl, idl_tbl):
	fields = make_fields(t, iface, idl_tbl)
	tname = t["NAME"]

	has_nontrivial_unions, all_nontrivial_unions_are_ptr = False, False
	for field in fields:
		if field.nontrivial_unions:
			has_nontrivial_unions = True
			for nf in field.nontrivial_unions:
				if not isinstance(nf, FieldPtr):
					all_nontrivial_unions_are_ptr = False

	out(f'''

struct {tname} {{
''')
	if any([len(f.nontrivial_unions) > 0 for f in fields]):
		out(f'''
	{tname}();
	~{tname}();
	{tname}(const {tname}& other) = delete;
	{tname} &operator=(const {tname}& other) = delete;
	{tname}({tname}&& other){" = default" if all_nontrivial_unions_are_ptr else ""};
	{tname} &operator=({tname}&& other) = delete;
''')
		for switch_field in fields:
			if len(switch_field.nontrivial_unions) == 0:
				continue
			# TODO if elem_has_property(switch_field, 'value'):
			#	continue
			out(f'''
	void set_{switch_field.name}({switch_field.base_type} v);
''')

	for field in fields:
		output_header_element(out, field)
	out(f'''
}} {function_tostring_properties(t)};

template <> struct ndr_requ_traits_t<{tname}> {{
	using ndr_base_type = {tname};
	using has_buffers = std::false_type;
	using ndr_data_type = x_ndr_type_struct;

	x_ndr_off_t scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	void ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};

template <> struct ndr_resp_traits_t<{tname}> {{
	using ndr_base_type = {tname};
	using has_buffers = std::false_type;
	using ndr_data_type = x_ndr_type_struct;

	x_ndr_off_t scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	void ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};


''')



def output_header_INTERFACE(out, iface, idl, idl_tbl):

	for t in iface['DATA']:
		if t['TYPE'] == 'TYPEDEF':
			realtype = typedef_get_realtype(t)
			if realtype == 'STRUCT':
				output_header_STRUCT(out, t, iface, idl, idl_tbl)
			elif realtype == 'UNION':
				output_header_UNION(out, t, iface, idl, idl_tbl)
			elif realtype == 'ENUM':
				output_header_ENUM(out, t, iface, idl, idl_tbl)
			elif realtype == 'BITMAP':
				output_header_BITMAP(out, t, iface, idl, idl_tbl)
			else:
				error(f'''Unknown typedef "{realtype}" at {t["FILE"]}:{t["LINE"]}''')
				assert False
		elif t['TYPE'] == 'CONST':
			dtype = t['DTYPE']
			assert const_get_pointers(t) == 0
			out(f'''
const {dtype}{'*' if t['POINTERS'] == 1 else ''} {t['NAME']} = {t['VALUE']};
''')
		elif t["TYPE"] in [ "FUNCTION" ]:
			output_header_FUNCTION(out, t, iface, idl, idl_tbl)
		else:
			error(f'''Unknown type "{t['TYPE']}" at {t['FILE']}:{t['LINE']}''')
			assert False


def output_ndrcxx_INTERFACE(out, iface, idl, idl_tbl):
	helper = get_property(iface, "helper")
	if helper is not None:
		out(f'''
#include {helper}
''')
	out(f'''

namespace idl {{

''')
	for t in iface['DATA']:
		if t['TYPE'] == 'TYPEDEF':
			"""
			if t['NAME'] in known_structs:
				continue
			"""
			realtype = typedef_get_realtype(t)
			if realtype == 'STRUCT':
				output_ndrcxx_STRUCT(out, t, iface, idl, idl_tbl)
			elif realtype == 'UNION':
				output_ndrcxx_UNION(out, t, iface, idl, idl_tbl)
			elif realtype == 'ENUM':
				output_ndrcxx_ENUM(out, t, iface, idl, idl_tbl)
			elif realtype == 'BITMAP':
				output_ndrcxx_BITMAP(out, t, iface, idl, idl_tbl)
			else:
				assert False
		elif t['TYPE'] in [ "FUNCTION" ]:
			pass
			# TODO output_ndrcxx_FUNCTION(out, idl, t)
		elif t['TYPE'] in [ "CONST", "FUNCTION" ]:
			pass
		else:
			assert False

	out(f'''

// }}
}}
''')

def output_header_IMPORT(out, o):
	for path in o['PATHS']:
		import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
		out(f'#include "include/librpc/{import_name}.hxx"')
	out()

def process_header(out, name, idl, idl_tbl, outdir):
	ifacename = None
	for o in idl:
		if o['TYPE'] == "INTERFACE":
			ifacename = o['NAME']
			break

	out(f'''
/* header auto-generated by gen-rpc */
#ifndef __GEN_RPC__HEADER_{ifacename}
#define __GEN_RPC__HEADER_{ifacename}
#include "include/librpc/ndr_smb.hxx"

''')

	for o in idl:
		if o['TYPE'] == "IMPORT": output_header_IMPORT(out, o)
		if o['TYPE'] == "INCLUDE": output_header_INCLUDE(out, o)

	out(f'''
namespace idl {{
''')

	for o in idl:
		#if o['TYPE'] == "CPP_QUOTE": output_header_QUOTE(out, o)
		if o['TYPE'] == "INTERFACE": output_header_INTERFACE(out, o, idl, idl_tbl)
			
	out(f'''

}} /* namespace idl */

#endif /* __GEN_RPC__HEADER_{ifacename} */

''')


def process_ndrcxx(out, name, idl, idl_tbl, outdir):
	out(f'''
/* ndr parser auto-generated by pidl */
	
#include "include/librpc/{name}.hxx"

''')

	for o in idl:
		if o['TYPE'] == "INTERFACE": output_ndrcxx_INTERFACE(out, o, idl, idl_tbl)



def process_depend(out, name, idl, idl_tbl, outdir):
	for o in idl:
		if o['TYPE'] != "IMPORT":
			continue
		for path in o['PATHS']:
			import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
			out(f'''
{outdir}/{name}.idl.hxx: {outdir}/{import_name}.json
{outdir}/{name}.idl.ndr.cxx: include/librpc/{import_name}.hxx
{outdir}/{name}.idl.ndr.o: include/librpc/ndr.hxx
{outdir}/{name}.idl.ndr.o: include/librpc/ndr_smb.hxx
''')

def load_idl_with_import(infp):
	imports = []
	idl = json.load(infp)
	for o in idl:
		if o['TYPE'] != "IMPORT":
			continue
		for path in o['PATHS']:
			import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
			imports.append(import_name)
	return idl, imports

def load_all(infp, name, path, recur):
	idl_tbl = {}
	idl, imports = load_idl_with_import(infp)
	idl_tbl[name] = idl

	while recur and imports:
		name = imports.pop()
		if name in idl_tbl:
			continue
		filename = os.path.join(path, '.'.join([name, "json"]))
		with open(filename, 'r') as fp:
			new_idl, new_imports = load_idl_with_import(fp)
			idl_tbl[name] = new_idl
			imports += new_imports
	return idl, idl_tbl

def process(infp, name, args):
	idl, idl_tbl = load_all(infp, name, args.outputdir, args.header or args.ndrcxx)

	def output(func, ext):
		if name is None:
			outfp = sys.stdout
		else:
			tmpfix = "tmp"
			filename = os.path.join(args.outputdir, '.'.join([name, ext, tmpfix]))
			outfp = open(filename, 'w')

		try:
			out = OStream(outfp)
			func(out, name, idl, idl_tbl, args.outputdir)
		except:
			if name is not None:
				outfp.close()
				os.remove(filename)
			raise
		if name is not None:
			os.rename(filename, os.path.join(args.outputdir, '.'.join([name, ext])))
	
	if args.depend: output(process_depend, 'd')
	if args.header: output(process_header, 'idl.hxx')
	if args.ndrcxx: output(process_ndrcxx, 'idl.ndr.cxx')
	if args.python: output(process_python, 'py.cxx')
			
	
def main():
	parser = argparse.ArgumentParser()
	parser.add_argument("-d", "--debug", action="store_true", help="output debug info")
	parser.add_argument("--depend", action="store_true", help="output dependency")
	parser.add_argument("--header", action="store_true", help="output header")
	parser.add_argument("--ndrcxx", action="store_true", help="output ndr")
	parser.add_argument("--python", action="store_true", help="output ndr")
	parser.add_argument("--outputdir", default=".", help="output directory")
	parser.add_argument("input", nargs='*', help="Input IDL json files")

	args = parser.parse_args()
	args.outputdir = args.outputdir.rstrip('/')
	if args.debug:
		global DBG
		print(args, file=sys.stderr)
		DBG = _dbg_stderr

	if len(args.input) == 0:
		process(sys.stdin, None, args)
	else:
		for f in args.input:
			with open(f, 'r') as fp:
				name = os.path.splitext(os.path.basename(f))[0]
				process(fp, name, args)

	return 0

if __name__ == "__main__": sys.exit(main())

