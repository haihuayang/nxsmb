#!/usr/bin/env python3

from __future__ import print_function
import os, sys
from io import StringIO
import re, argparse, json

# TODO
# [size_is(count) uint32 field[*]
# ref pointer

class OStream(object):
	def __init__(self, fp):
		self.fp = fp
	def write(self, s):
		self.fp.write(s)
	def __call__(self, s=''):
		try:
			if s[0] == '\n':
				s = s[1:]
		except:
			pass

		self.fp.write(s)
		try:
			if s[-1] == '\n':
				return
		except:
			pass
		self.fp.write('\n')

class LazyToStr(object):
	def __init__(self, func, *args):
		self.func, self.args = func, args
	def __str__(self):
		return '{0}'.format(self.func(*self.args))

def _dbg_none(*args):
	pass

def _dbg_stderr(*args):
	print("DBG:", *args, file=sys.stderr)

DBG = _dbg_none

def warn(msg):
	print("Warning:", msg, file = sys.stderr)

def error(msg):
	print("Error:", msg, file = sys.stderr)


def tostring_properties__(data):
	if 'PROPERTIES' in data:
		ret = []
		for key, val in data['PROPERTIES'].items():
			if val != '1':
				ret.append(f'{key}({val})')
			else:
				ret.append(key)
		return '/* [' + ', '.join(ret) + '] */'
	else:
		return ''

def elem_tostring_properties(e):
	return tostring_properties__(e)

def typedef_tostring_properties(t):
	return tostring_properties__(t['DATA'])

def function_tostring_properties(t):
	return tostring_properties__(t)

def elem_get_ndr_flags(elem):
	ndr_flags = elem_get_property(elem, "flag")
	if ndr_flags is not None:
		return f'x_ndr_set_flags(__flags, {ndr_flags})'
	else:
		return '__flags'

def elem_get_pointer_type(elem, iface):
	for t in [ "unique", "relative" ]:
		try:
			v = elem["PROPERTIES"][t]
		except:
			continue
		assert v == "1"
		return t
	try:
		return iface['pointer_default']
	except:
		return "unique"

F_STRUCT = 0x1
F_UNION  = 0x2
F_FUNCTION = 0x4
know_properties = {
	'case': F_UNION,
	'default': F_UNION,
	'flag': F_STRUCT | F_UNION,
	'range': F_STRUCT | F_FUNCTION,
	'value': F_STRUCT | F_UNION,
	'charset': F_STRUCT | F_UNION | F_FUNCTION,
	'switch_is': F_STRUCT | F_FUNCTION,
	'switch_type': F_STRUCT,
	'size_is': F_STRUCT | F_FUNCTION,
	'in': F_FUNCTION, # TODO
	'out': F_FUNCTION, # TODO
	'unique': F_STRUCT | F_FUNCTION, # TODO
	'length_is': F_STRUCT | F_FUNCTION, # TODO
	'noprint': F_STRUCT | F_UNION, # TODO
	#'ignore': F_STRUCT | F_UNION, # TODO
	'x_ignored': F_STRUCT,
	'string': F_STRUCT | F_UNION | F_FUNCTION, # TODO
	'compression': F_STRUCT | F_UNION, # TODO
	'subcontext': F_STRUCT | F_UNION, # TODO rewrite
	'subcontext_size': F_STRUCT | F_UNION, # TODO rewrite
	'relative': F_STRUCT | F_UNION, # TODO rewrite
	'relative_short': F_STRUCT | F_UNION, # TODO rewrite
	'ref': F_FUNCTION, # TODO rewrite
	#'x_offset': F_STRUCT,
	'x_skip': F_STRUCT,
	'x_size': F_STRUCT,
	'x_ndr_size': F_STRUCT,
	#'x_with_size': F_STRUCT,
	'x_relative': F_STRUCT,
	'x_group_start': F_STRUCT,
	'x_group_end': F_STRUCT,
	'x_pull_value': F_STRUCT,
	'x_push_value': F_STRUCT,
}

def elem_check_properties(elem, t):
	if not 'PROPERTIES' in elem:
		return
	if t['TYPE'] == 'TYPEDEF':
		flag = F_STRUCT if typedef_get_realtype(t) == 'STRUCT' else F_UNION
	elif t['TYPE'] == 'FUNCTION':
		flag = F_FUNCTION
	else:
		assert False
	for name, value in elem['PROPERTIES'].items():
		try:
			flags = know_properties[name]
			if (flag & flags) == 0:
				error(f'at {elem["FILE"]}:{elem["LINE"]} Property {name} not support {flag}')
				assert False
		except KeyError:
			error(f"Unknown property {name}.")
			assert False

def has_any_property(elem, *args):
	try:
		prop = elem['PROPERTIES']
	except:
		return False
	for arg in args:
		if arg in prop:
			return True
	return False

elem_has_property = has_any_property

def get_property(t, prop, default = None):
	try:
		return t['PROPERTIES'][prop]
	except KeyError:
		return default

def elem_get_property(t, prop, default = None):
	return get_property(t, prop, default)

def typedef_get_property(t, prop, default = None):
	return get_property(t['DATA'], prop, default)

def elem_is_property_of(elem, t, *args):
	for me in typedef_get_elements(t):
		for prop in args:
			try:
				if elem["NAME"] == elem_get_property(me, prop):
					return me
			except:
				pass
	return None

def elem_is_expr_property_of(elem, t, *args):
	ename = elem["NAME"]
	for me in typedef_get_elements(t):
		for prop in args:
			value = elem_get_property(me, prop)
			if value is None:
				continue
			if any([ename == operand for operand in re.split(r'[^0-9a-zA-Z_.]+', value)]):
				return me
	return None

def elem_get_array_len(elem):
	try:
		array_len = elem['ARRAY_LEN']
		if len(array_len) == 0:
			return None
		assert len(array_len) == 1
		return array_len[0]
	except KeyError:
		return None

def RETIRED_elem_get_pointers(elem):
	try:
		v = elem['POINTERS']
	except KeyError:
		return 0
	# TODO, we derefer when it has ref, except it has size_is or length_is
	if get_property(elem, 'ref') and not has_any_property(elem, 'size_is', 'length_is'):
		assert v > 0
		v -= 1
	assert v in [0, 1, 2]
	return v

def elem_in_function(elem):
	return has_any_property(elem, 'in', 'out')

def elem_get_pointer_info(elem, iface):
	try:
		v = elem['POINTERS']
	except KeyError:
		v = 0

	if v == 0:
		return 0, None, False

	if elem_in_function(elem):
		assert not has_any_property(elem, 'relative')
		if has_any_property(elem, 'unique'):
			assert v == 1
			return v, 'unique', False
		v -= 1
		assert v < 2
		return v, 'unique', True
	else:
		for t in [ "unique", "relative" ]:
			try:
				tv = elem["PROPERTIES"][t]
			except:
				continue
			assert tv == "1"
			break
		else:
			try:
				t = iface['pointer_default']
			except:
				t = "unique"
		assert v < 3
		return v, t, False

def elem_is_switch(f, union_fields):
	for uf, unions in union_fields:
		if uf["NAME"] == f["NAME"]:
			return len(unions) > 0
	else:
		return False

# TODO
def has_property(t, prop):
	v = get_property(t, prop)
	if v is None:
		return False
	assert v == '1'
	return True

def const_get_pointers(elem):
	try:
		v = elem['POINTERS']
	except KeyError:
		return 0
	assert v == 0
	return v

def typedef_has_property(t, prop):
	return has_property(t['DATA'], prop);

def typedef_get_elements(t):
	if t['TYPE'] == 'TYPEDEF':
		try:
			return t['DATA']['ELEMENTS']
		except:
			return []
	elif t['TYPE'] == 'FUNCTION':
		try:
			return t['ELEMENTS']
		except:
			return []
	else:
		assert False

def typedef_get_elem_by_name(t, name):
	for elem in typedef_get_elements(t):
		if elem['NAME'] == name:
			return elem
	return None

def typedef_get_realtype(t):
	return t['DATA']['TYPE']

known_simple_types = {
	# name, align, is_trival, has_buffers
	'EMPTY': [ 0, True, False],
	'void': [0, True, False],
	'char': [1, True, False],
	'int8': [1, True, False],
	'uint8': [1, True, False],
	'int16': [2, True, False],
	'uint16': [2, True, False],
	'int1632': [3, True, False],
	'uint1632': [3, True, False],
	'int': [4, True, False], # int32
	'int32': [4, True, False],
	'long': [4, True, False], # uint32
	'DWORD': [4, True, False],
	'WORD': [2, True, False],
	'uint32': [4, True, False],
	'mode_t': [4, True, False], # uint32
	'boolean8': [1, True, False],
	'boolean32': [4, True, False], # uint32
	'int3264': [5, True, False],
	'uint3264': [5, True, False],
	'uint64': [8, True, False],
	'double': [8, True, False],
	'pointer': [8, True, False],
	'dlong': [4, True, False],
	'udlong': [4, True, False],
	'udlongr': [4, True, False],
	'hyper': [4, True, False],
	'NTSTATUS': [4, True, False],
	'NTTIME': [4, True, False],
	'time_t': [4, True, False],
	'ipv4address': [4, True, False],
	'ipv6address': [4, True, False], #16?
	'WERROR': [4, True, False],
	'DATA_BLOB': [4, False, False],
        'u16string': [2, False, False],
        'u8string': [1, False, False],
}

alias_types = {
	# alias, type_name, traits_type, align
        'NTTIME_hyper': ['NTTIME', 'ndr_traits_NTTIME_hyper', 8],
	'dom_sid2': [ 'dom_sid', 'ndr_traits_dom_sid2', None],
	'u16string_remain': [ 'u16string', 'ndr_traits_u16string_remain', 1],
	'nstring': [ 'u16string', 'ndr_traits_nstring', 2],
	'astring': [ 'u8string', 'ndr_traits_astring', 1],
}

def find_type(idl, tname):
	for o in idl:
		if o['TYPE'] != "INTERFACE":
			continue
		for t in o['DATA']:
			if t['TYPE'] == "TYPEDEF" and t['NAME'] == tname:
				return t
	return None

def find_type_idl_tbl(idl_tbl, tname):
	for _, idl in idl_tbl.items():
		t = find_type(idl, tname)
		if t is not None:
			return t
	return None

def elem_get_base_type(t):
	ret = t['TYPE']
	try:
		ret, _, _ = alias_types[ret]
	except: pass
	return ret

def get_array_len(elem):
	try:
		array_len = elem['ARRAY_LEN']
		if len(array_len) == 0:
			return None
		assert len(array_len) == 1
		return array_len[0]
	except KeyError:
		return None

def elem_is_array_len_of(elem, st):
	for elem2 in typedef_get_elements(st):
		array_len = get_array_len(elem2)
		if elem['NAME'] == array_len:
			return elem2
	return None

def elem_get_case_str(elem):
	case_value = get_property(elem, 'case')
	if case_value is not None:
		return f'case {case_value}'
	else:
		assert has_property(elem, 'default')
		return 'default'

# samba/pidl/lib/Parse/Pidl/NDR.pm align_type
def elem_get_info(elem, iface, idl_tbl):
	def get_info_1(elem):
		ndr_traits, align, is_trivial, has_buffers = None, None, None, None
		pointer_count, _, _ = elem_get_pointer_info(elem, iface)
		if pointer_count:
			# this is a hack for NDR64
			# the NDR layer translates this into
			# an alignment of 4 for NDR and 8 for NDR64
			align = 5
			has_buffers = True
			is_trivial = False

		array_len = get_array_len(elem)
		if array_len is not None:
			try:
				int(array_len)
			except ValueError:
				is_trivial = False

		base_type = elem['TYPE']
		try:
			base_type, ndr_traits, align_ = alias_types[base_type]
			if align is None:
				align = align_
		except KeyError: pass

		try:
			align_, is_trivial_, has_buffers_ = known_simple_types[base_type]
			if align is None:
				align = align_
			if has_buffers is None:
				has_buffers = has_buffers_
			if is_trivial is None:
				is_trivial = is_trivial_
			return 'PRIMARY', None, base_type, ndr_traits, align, is_trivial, has_buffers
		except KeyError: pass

		et = find_type_idl_tbl(idl_tbl, base_type)
		if et is None:
			raise NotFound(elem, base_type)

		data_type, align_, is_trivial_, has_buffers_ = get_info_typedef(et)
		if align is None:
			align = align_
		if has_buffers is None:
			has_buffers = has_buffers_
		if is_trivial is None:
			is_trivial = is_trivial_
		return data_type, et, base_type, ndr_traits, align, is_trivial, has_buffers
		
	def get_info_typedef(t):
		assert t["TYPE"] == "TYPEDEF"
		try:
			return t['my_info']
		except: pass

		ret = get_info_typedef_1(t)
		DBG(f'get_info_typedef({t["NAME"]}) = {ret}')
		t['my_info'] = ret
		return  ret
	
	def get_info_typedef_1(t):
		realtype = typedef_get_realtype(t)

		if realtype == "ENUM":
			_, ftype = map_enum_type(t)
			return [realtype, *known_simple_types[ftype]]
		elif realtype == "BITMAP":
			_, ftype = map_bitmap_type(t)
			return [realtype, *known_simple_types[ftype]]

		assert realtype in [ "STRUCT", "UNION" ]
		align, is_trivial, has_buffers = 1, True, False
		for elem in typedef_get_elements(t):
			_, _, _, _, align_, is_trivial_, has_buffers_ = get_info_1(elem)
			if align < align_:
				align = align_
			if not is_trivial_:
				is_trivial = False
			if has_buffers_:
				has_buffers = True
		return realtype, align, is_trivial, has_buffers

	class NotFound(Exception):
		def __init__(self, elem, base_type):
			self.elem, self.base_type = elem, base_type
	try:
		return get_info_1(elem)
	except NotFound as e:
		error(f'''Cannot find type "{e.base_type}" for "{e.elem["NAME"]}" at {e.elem['FILE']}:{e.elem['LINE']}''')
		raise

def normalize_stmt(s):
	if s is None:
		return []
	elif isinstance(s, str):
		return [ s ]
	else:
		return s
def append_stmts(orig_stmts, new_stmts):
	if orig_stmts is None:
		ret = []
	else:
		ret = orig_stmts[:]
	if new_stmts is not None:
		if isinstance(new_stmts, str):
			ret.append(new_stmts)
		else:
			ret += new_stmts
	return ret

class FieldTypeBase(object):
	def has_buffers(self):
		raise NotImplementedError
	def dereferenced(self):
		return False
	def is_union(self):
		return False

class FieldTypeSubctxBase(FieldTypeBase):
	def __init__(self, inner):
		self.inner = inner
	def is_union(self):
		return self.inner.is_union()
	def get_ctype(self):
		return self.inner.get_ctype()
	def has_buffers(self):
		# TODO confirm
		return False
		#return self.inner.has_buffers()
	def ostr(self, order, name, ndr_flags, switch_is):
		return self.inner.ostr(order, name, ndr_flags, switch_is)
	
class FieldTypeSubctx(FieldTypeSubctxBase):
	def __init__(self, inner, level):
		super().__init__(inner)
		self.level = level
	def get_alignment(self):
		return self.inner.get_alignment()
	
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return self.inner.scalars(order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is)
	def buffers(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return ['TODO X_NDR_BUFFERS_SIMPLE({self.get_ndr_traits()}, __val.{name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
	def __str__(self):
		return 'Subctx(%d,%s)' % (self.level, self.inner)
	
class FieldTypeSubctxFFFFFC01(FieldTypeSubctxBase):
	def get_alignment(self):
		return 1
	def is_trivial(self):
		return self.inner.is_trivial()
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return ['TODO;']
	def __str__(self):
		return 'SubctxFFFFFC01(%s)' % self.inner

class FieldTypeDerived(FieldTypeBase):
	def __init__(self, json_elem, iface, idl_tbl, dereferenced):
		self.data_type, self.typedef, self.base_type, self.ndr_traits, self.alignment, self.is_trivial_, self.has_buffers_ = elem_get_info(json_elem, iface, idl_tbl)
		self.name = json_elem['NAME']
		self.json_elem = json_elem
		self.dereferenced_ = dereferenced

	def has_buffers(self):
		return False

	def get_alignment(self):
		return self.alignment

	def get_ctype(self):
		return self.base_type

	def get_ndr_traits(self):
		if self.ndr_traits:
			return self.ndr_traits
		else:
			return f'ndr_traits_t<{self.base_type}>'

	def ostr(self, order, name, ndr_flags, switch_is):
		return []

class FieldTypeSimple(FieldTypeBase):
	def __init__(self, json_elem, iface, idl_tbl, dereferenced):
		self.data_type, self.typedef, self.base_type, self.ndr_traits, self.alignment, self.is_trivial_, self.has_buffers_ = elem_get_info(json_elem, iface, idl_tbl)
		self.name = json_elem['NAME']
		self.json_elem = json_elem
		self.dereferenced_ = dereferenced
		DBG(f'FieldTypeSimple name={self.name}, data_type={self.data_type}, typedef={self.typedef}, base_type={self.base_type}, ndr_traits={self.ndr_traits}, alignment={self.alignment}, is_trivial={self.is_trivial_}, has_buffers={self.has_buffers_}')
	
	def is_union(self):
		return self.data_type == 'UNION'

	def get_ctype(self):
		return self.base_type

	def has_buffers(self):
		return self.has_buffers_

	def is_trivial(self):
		return self.is_trivial_

	def dereferenced(self):
		return self.dereferenced_

	def get_ndr_traits(self):
		if self.ndr_traits:
			return self.ndr_traits
		else:
			return f'ndr_traits_t<{self.base_type}>'

	def get_property(self, prop, default = None):
		return get_property(self.json_elem, prop, default)

	def get_ndr_flags(self, flag_arg = '__flags'):
		flag = self.get_property('flag')
		if flag is None:
			return flag_arg
		else:
			return f'x_ndr_set_flags({flag_arg}, {flag})'

	def get_alignment(self):
		return self.alignment

	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, {name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']

	def buffers(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_BUFFERS_SIMPLE({self.get_ndr_traits()}, {name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']

	def ostr(self, order, name, ndr_flags, switch_is):
		return [f'X_NDR_OSTR_SIMPLE({self.get_ndr_traits()}, {name}, __ndr, {ndr_flags}, {switch_is});']

	def __str__(self):
		return self.base_type

class FieldTypeString(FieldTypeBase):
	def __init__(self, json_elem, iface, idl_tbl, dereferenced, string_type):
		self.data_type, self.typedef, self.base_type, self.ndr_traits, self.alignment, self.is_trivial_, self.has_buffers_ = elem_get_info(json_elem, iface, idl_tbl)
		self.name = json_elem['NAME']
		self.json_elem = json_elem
		self.dereferenced_ = dereferenced

		self.string_type = string_type
		if self.ndr_traits is None:
			self.ndr_traits = f'ndr_traits_t<{string_type}>'
	def get_ctype(self):
		return f'{self.string_type}'

	def has_buffers(self):
		return False

	def get_alignment(self):
		return self.alignment

	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SCALARS_STRING({self.ndr_traits}, __val.{name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']

	def ostr(self, order, name, ndr_flags, switch_is):
		return [f'X_NDR_OSTR_STRING({self.ndr_traits}, __val.{name}, __ndr, {ndr_flags}, {switch_is});']

	def __str__(self):
		return "String(%s)" % self.base_type

class FieldTypeArray(FieldTypeBase):
	def __init__(self, inner, array_size):
		self.inner, self.array_size = inner, array_size
	def get_ndr_traits(self):
		return self.inner.get_ndr_traits()
	def has_buffers(self):
		return self.inner.has_buffers()
	def is_trivial(self):
		return self.inner.is_trivial()
	def get_ctype(self):
		return f'std::array<{self.inner.get_ctype()}, {self.array_size}>'
	def get_alignment(self):
		return self.inner.get_alignment()
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SCALARS_ARRAY({self.get_ndr_traits()}, {name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
	def buffers(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_BUFFERS_ARRAY({self.get_ndr_traits()}, {name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
	def ostr(self, order, name, ndr_flags, switch_is):
		return [f'X_NDR_OSTR_ARRAY({self.get_ndr_traits()}, {name}, __ndr, {ndr_flags}, {switch_is});']
	def __str__(self):
		return '%s[%d]' % (self.inner, self.array_size)

class FieldTypeUnboundVector(FieldTypeBase):
	def __init__(self, inner):
		self.inner = inner
	def get_ctype(self):
		return f'std::vector<{self.inner.get_ctype()}>'
	def has_buffers(self):
		return self.inner.has_buffers()
	def get_alignment(self):
		return self.inner.get_alignment()
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return ['TODO;']
		return f'X_NDR_SCALARS_VECTOR({self.get_ndr_traits()}, {self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def buffers(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		assert False, "TODO"
		return f'X_NDR_BUFFERS_VECTOR({self.get_ndr_traits()}, {self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def ostr(self, order, name, ndr_flags, switch_is):
		return [f'X_NDR_OSTR_VECTOR({self.inner.get_ndr_traits()}, {name}, __ndr, {ndr_flags}, {switch_is});']
	def __str__(self):
		return '%s[]' % self.inner

class FieldTypeVector(FieldTypeBase):
	def __init__(self, inner, array_len_elem):
		self.inner, self.array_len_elem = inner, array_len_elem
	def get_ctype(self):
		return f'std::vector<{self.inner.get_ctype()}>'
	def has_buffers(self):
		return self.inner.has_buffers()
	def get_alignment(self):
		return self.inner.get_alignment()
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		tmp_name = f'__tmp_{order}'
		ret = [f'for (auto &{tmp_name}: {name}) {{']
		for s in self.inner.scalars(order, func, tmp_name, ndr_arg, bpos_arg, epos_arg, ndr_flags, 'X_NDR_SWITCH_NONE'):
			ret.append('\t' + s)
		ret.append('}')
		return ret
	def buffers(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		tmp_name = f'__tmp_{order}'
		ret = [f'for (auto &{tmp_name}: {name}) {{']
		for s in self.inner.buffers(order, func, tmp_name, ndr_arg, bpos_arg, epos_arg, ndr_flags, 'X_NDR_SWITCH_NONE'):
			ret.append('\t' + s)
		ret.append('}')
		return ret
	def ostr(self, order, name, ndr_flags, switch_is):
		tmp_name = f'__tmp_{order}'
		ret = [f'for (auto &{tmp_name}: {name}) {{']
		for s in self.inner.ostr(order, tmp_name, ndr_flags, 'X_NDR_SWITCH_NONE'):
			ret.append('\t' + s)
		ret.append('}')
		return ret
	def __str__(self):
		return '%s[%s]' % (self.inner, self.array_len_elem)

class FieldTypeSizeIsVector(FieldTypeBase):
	def __init__(self, inner, size_is_elem):
		self.inner = inner
		self.size_is_elem = size_is_elem
	def get_ctype(self):
		return f'std::vector<{self.inner.get_ctype()}>'
	def has_buffers(self):
		return self.inner.has_buffers()
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SCALARS_SIZE_IS_VECTOR(self.inner.get_ndr_traits(), __val.{name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
	def buffers(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_BUFFERS_VECTOR({self.inner.get_ndr_traits()}, __val.{name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
	def ostr(self, order, name, ndr_flags, switch_is):
		return [f'X_NDR_OSTR_VECTOR({self.inner.get_ndr_traits()}, __val.{name}, __ndr, {ndr_flags}, {switch_is});']
	def __str__(self):
		return "SizeIsVector(%s,%s)" % (self.inner, self.size_is_elem)

class FieldTypeLengthIsVector(FieldTypeBase):
	def __init__(self, inner, size_is_elem, length_is_elem):
		self.inner = inner
		self.size_is_elem = size_is_elem
		self.length_is_elem = length_is_elem
	def get_ctype(self):
		return f'std::vector<{self.inner.get_ctype()}>'
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SCALARS_LENGTH_IS_VECTOR({self.inner.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
	def buffers(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_BUFFERS_VECTOR({self.inner.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
	def ostr(self, order, name, ndr_flags, switch_is):
		return [f'X_NDR_OSTR_VECTOR({self.inner.get_ndr_traits()}, __val.{self.name}, __ndr, {ndr_flags}, {switch_is});']
	def __str__(self):
		return "LengthIsVector(%s,%s,%s)" % (self.inner, self.size_is_elem, self.length_is_elem)

class FieldTypePtr(FieldTypeBase):
	def __init__(self, inner):
		self.inner = inner
	
	def has_buffers(self):
		return True

	def is_trivial(self):
		return False

	def get_ctype(self):
		return f'std::shared_ptr<{self.inner.get_ctype()}>'

	def get_alignment(self):
		return 5

	def ostr(self, order, name, ndr_flags, switch_is):
		return [f'X_NDR_OSTR_PTR_TODO();']
		'''
	def ostr(self, deref):
		ret = self.inner.ostr__()
		return append_stmts([f'if (!{deref}__val.{self.name}) {{',
			'	__ndr << "NULL"',
			'	return;',
			'}'], self.inner.ostr__('*' + deref))
		'''
			
class FieldTypeUniquePtr(FieldTypePtr):
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SCALARS_UNIQUE_PTR({name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def buffers(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_BUFFERS_UNIQUE_PTR(TODO self.inner.get_ndr_traits(), __val.{name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
		'''
		inner_stmts = self.inner.scalars__(func, '*' + val_name,
			ndr_arg, bpos_arg, epos_arg, flags_arg)
		if self.inner.has_buffers:
			inner_stmts = append_stmts(inner_stmts, self.inner.buffers__(func, '*' + val_name,
						ndr_arg, bpos_arg, epos_arg, flags_arg))
		return [ f'if ({val_name}) {{' ] + [ '\t' + s for s in inner_stmts ] + [
			'}',
			f'return {bpos_arg};']
		'''
	def __str__(self):
		return "Relative(%s)" % self.inner

class FieldTypeRelativePtr(FieldTypePtr):
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SAVE_POS(uint32, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def buffers(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		inner_stmt = self.inner.scalars(order, func, f'*{name}', ndr_arg, 'tmp_bpos', epos_arg, ndr_flags, switch_is);
		if self.inner.has_buffers():
			inner_stmt += self.inner.buffers(order, func, f'*{name}', ndr_arg, 'tmp_bpos', epos_arg, ndr_flags, switch_is);
		
		if func == 'PUSH':
			ret = [
			f'if ({name}) {{',
				f'\tX_NDR_DO_ALIGN({ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});',
			]
			for s in inner_stmt:
				ret.append(f'\t{s}')
			ret.append('}')
		else:
			ret = [
			f'uint32 __pos_{order} = X_NDR_LOAD_POS(uint32, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});',
			f'if (__pos_{order}) {{',
				f'\tX_NDR_CHECK_ALIGN({ndr_arg}, {ndr_flags}, __pos_{order});',
				f'\t{name} = x_ndr_allocate_ptr<{self.inner.get_ctype()}>({switch_is});' if self.inner.is_union() else f'\t{name} = x_ndr_allocate_ptr<{self.inner.get_ctype()}>();',
				f'\tx_ndr_off_t tmp_bpos = X_NDR_CHECK_POS({ndr_arg}.base + __pos_{order}, 0, {epos_arg});'
			]
			for s in inner_stmt:
				ret.append(f'\t{s}')
			ret.append(f'\t{bpos_arg} = std::max({bpos_arg},tmp_bpos);')
			ret.append('}')
		return ret
	def __str__(self):
		return "Relative(%s)" % self.inner

class FieldTypeXSize(FieldTypeDerived):
	def __init__(self, json_elem, iface, idl_tbl, dereferenced):
		super().__init__(json_elem, iface, idl_tbl, dereferenced)
		assert self.base_type in [ 'uint8', 'uint16', 'uint32' ]
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_XSIZE_{func}({self.base_type}, {order}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def scalars_post(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, (__bpos - __base), {ndr_arg}, __pos_{order}, {epos_arg}, {ndr_flags}, {switch_is});''']
	def str(self):
		return "XSize(%s)" % self.base_type

class FieldTypeValue(FieldTypeDerived):
	def __init__(self, json_elem, iface, idl_tbl, dereferenced, value, array_len):
		super().__init__(json_elem, iface, idl_tbl, dereferenced)
		assert self.data_type in ['ENUM', 'BITMAP' ] or self.base_type in [ 'uint8', 'uint16', 'uint32' ]
		self.value, self.array_len = value, array_len
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if self.array_len is not None:
			ctype = f'std::array<{self.base_type}, {self.array_len}>'
			return [f'X_NDR_SCALARS_ARRAY_VALUE({self.get_ndr_traits()}, ({ctype}{{{self.value}}}), {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
		else:
			ctype = self.base_type
			return [f'X_NDR_SCALARS_VALUE({self.get_ndr_traits()}, ({ctype}{{{self.value}}}), {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']

class FieldTypeVectorLen(FieldTypeDerived):
	def __init__(self, json_elem, iface, idl_tbl, dereferenced, vector_name):
		super().__init__(json_elem, iface, idl_tbl, dereferenced)
		assert self.base_type in [ 'uint8', 'uint16', 'uint32' ]
		self.vector_name = vector_name
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_VECTOR_LEN_{func}({self.base_type}, {self.vector_name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def __str__(self):
		return "VectorLen(%s)" % self.base_type

class FieldTypeXNdrSize(FieldTypeDerived):
	def __init__(self, json_elem, iface, idl_tbl, dereferenced):
		super().__init__(json_elem, iface, idl_tbl, dereferenced)
		#self.ndr_size_elem = ndr_size_elem
		#assert self.get_property('switch_is') is None
	def set_size_field(self, field):
		self.ndr_size_field = field
		self.has_buffers = field.has_buffers
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if func == 'PUSH':
			return [ f'x_ndr_off_t __pos_{self.name} = {bpos_arg};',
				f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, {self.base_type}(), {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, X_NDR_SWITCH_NONE);' ]
		else:
			return [ f'{self.base_type} __tmp_{self.name};',
				f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, __tmp_{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, X_NDR_SWITCH_NONE);' ]

	def __str__(self):
		return "XNdrSize(%s)" % self.base_type

class FieldTypeSubctxSize(FieldTypeDerived):
	def has_buffers(self):
		return True
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SAVE_POS({self.base_type}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def buffers(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'x_ndr_off_t __pos_{self.name} = {ndr_arg}.load_pos();']

class FieldTypeSizeIs(FieldTypeDerived):
	def scalars(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SAVE_POS({self.base_type}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		'''
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		assert self.has_buffers()
		ret = [ f'ndr_traits_at_t<ndr_traits_t<{self.base_type}>> __at_{self.name}{{ndr_traits_t<{self.base_type}>(), {ndr_arg}.load_pos(), {self.get_ndr_flags()}}};' ]
		if self.order > self.size_is_of.order:
			ret.append(f'X_NDR_SIZE_AT(__at_{self.name}, {ndr_arg}, __val.{self.size_is_of.name}, {epos_arg});')
		return ret
		return f'ndr_traits_at_t<ndr_traits_t<{self.base_type}>> __at_{self.name}{{ndr_traits_t<{self.base_type}>(), {ndr_arg}.load_pos(), {self.get_ndr_flags()}}};'
		if func == 'PUSH':
			ret = [ f'{self.base_type} __tmp_{self.name} = vector_ptr_get_size(__val.{self.size_is_of.name});' ]
		else:
			ret = [ f'{self.base_type} __tmp_{self.name};' ]
		ret.append(f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, __tmp_{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, X_NDR_SWITCH_NONE);')
		return ret
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_BUFFERS_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
		'''

FieldTypeLengthIs = FieldTypeSizeIs

class Field(object):
	def __init__(self, elem, field_type, master_field = None):
		self.elem, self.field_type, self.master_field = elem, field_type, master_field
		self.name = elem['NAME']
		self.nontrivial_unions = []
		self.x_ndr_sizes = []
	def set_sibling(self, order, fields):
		self.order, self.sibling = order, fields
		self.ndr_flags = self.get_ndr_flags()
		self.switch_is = self.get_switch_is()
	def is_type(self, t):
		return isinstance(self.field_type, t)
	def has_buffers(self):
		return self.field_type.has_buffers()
	def is_trivial(self):
		return self.field_type.is_trivial()
	def dereferenced(self):
		return self.field_type.dereferenced()
	def get_properties_string__(self):
		return elem_tostring_properties(self.elem)
	def declare(self):
		ctype = self.field_type.get_ctype()
		declare = f'{ctype} {self.name};'
		if isinstance(self.field_type, FieldTypeDerived):
			declare = f'/* {declare} */'
		properties_string = elem_tostring_properties(self.elem)
		if properties_string:
			declare = ' '.join([declare, properties_string])
		return declare;
	def get_alignment(self):
		return self.field_type.get_alignment()

	def scalars(self, func):
		ret = self.field_type.scalars(self.order, func, f'__val.{self.name}', '__ndr', '__bpos', '__epos', self.ndr_flags, self.switch_is)
		assert isinstance(ret, list)
		return ret
	def scalars_post(self, func):
		return self.field_type.scalars_post(self.order, func, f'__val.{self.name}', '__ndr', '__bpos', '__epos', self.ndr_flags, self.switch_is)
	def buffers(self, func):
		ret = self.field_type.buffers(self.order, func, f'__val.{self.name}', '__ndr', '__bpos', '__epos', self.ndr_flags, self.switch_is)
		assert isinstance(ret, list)
		return ret
	def ostr(self):
		return self.field_type.ostr(self.order, f'__val.{self.name}', self.ndr_flags, self.switch_is)

	def get_property(self, prop, default = None):
		return get_property(self.elem, prop, default)
	def get_switch_is(self):
		switch_is = self.get_property('switch_is')
		if switch_is is None:
			return 'X_NDR_SWITCH_NONE'
		else:
			ro = re.compile('[A-Za-z_][A-Za-z0-9_]*')
			pos, comps = 0, []
			while True:
				m = ro.search(switch_is, pos)
				if not m:
					break
				start, end = m.span()
				prefix = ''
				if start != pos:
					prefix = switch_is[pos:start]
				op_name = switch_is[start:end]
				for f in self.sibling:
					if f.name == op_name:
						if pos == 0 and f.dereferenced() and prefix.strip() == '*':
							prefix = ''
						#op_name = '__val.' + op_name
						comps.append('__val.')
						break
				if prefix:
					comps.append(prefix)
				comps.append(op_name)
				pos = end
			comps.append(switch_is[pos:])
			return ''.join(comps)
	def get_ndr_flags(self, flag_arg = '__flags'):
		flag = self.get_property('flag')
		if flag is None:
			return flag_arg
		else:
			return f'x_ndr_set_flags({flag_arg}, {flag})'

	def __str__(self):
		return "%d,%s,%s" % (self.order, self.name, self.field_type)

def make_field(elem, t, iface, idl_tbl, in_function):
	elem_check_properties(elem, t)
	pointer_count, pointer_type, pointer_deref = elem_get_pointer_info(elem, iface)

	DBG("make_field", elem['NAME'], pointer_count, pointer_type, pointer_deref)
	assert pointer_count < 3
	array_len_name = elem_get_array_len(elem)

	if elem_has_property(elem, 'x_size'):
		assert pointer_count == 0
		assert not pointer_deref
		return Field(elem, FieldTypeXSize(elem, iface, idl_tbl, pointer_deref))

	master_elem = elem_is_property_of(elem, t, 'subcontext_size')
	if master_elem:
		# TODO assert elem_get_pointers(master_elem)
		assert not pointer_deref
		assert pointer_count == 0
		return Field(elem, FieldTypeSubctxSize(elem, iface, idl_tbl, pointer_deref), master_elem['NAME'])

	value = elem_get_property(elem, 'value')
	if value:
		assert pointer_count == 0
		assert not pointer_deref
		if array_len_name:
			array_len_name = int(array_len_name)
		return Field(elem, FieldTypeValue(elem, iface, idl_tbl, pointer_deref, value, array_len_name))

	ndr_size_elem = elem_get_property(elem, 'x_ndr_size')
	if ndr_size_elem:
		assert pointer_count == 0
		assert not pointer_deref
		#return field(elem, FieldTypeXNdrSize(elem, idl_tbl, ndr_size_elem)
		return Field(elem, FieldTypeXNdrSize(elem, iface, idl_tbl, pointer_deref), ndr_size_elem)

	array_len_of_elem = elem_is_array_len_of(elem, t)
	if array_len_of_elem:
		assert pointer_count == 0
		assert not pointer_deref
		return Field(elem, FieldTypeVectorLen(elem, iface, idl_tbl, pointer_deref, array_len_of_elem['NAME']))

	size_is_of = elem_is_expr_property_of(elem, t, "size_is")
	if size_is_of:
		assert pointer_count == 0
		return Field(elem, FieldTypeSizeIs(elem, iface, idl_tbl, pointer_deref), size_is_of['NAME'])

	length_is_of = elem_is_expr_property_of(elem, t, "length_is")
	if length_is_of:
		assert pointer_count == 0
		return Field(elem, FieldTypeLengthIs(elem, iface, idl_tbl, pointer_deref), length_is_of['NAME'])

	charset = elem_get_property(elem, "charset")
	size_is = elem_get_property(elem, "size_is")
	length_is = elem_get_property(elem, "length_is")
	if charset == "UTF16":
		assert elem['TYPE'] == 'uint16'
		string_type = "std::u16string"
	elif charset == "DOS":
		assert elem['TYPE'] == 'uint8'
		string_type = "std::string"
	else:
		assert charset is None
	if charset:
		assert not size_is_of
		assert not length_is_of
		field_type = FieldTypeString(elem, iface, idl_tbl, pointer_deref, string_type)
		if array_len_name == '*' and pointer_count == 0:
			array_len_name = None
		# TODO string with length_is or size_is is different to vector,
		# need to manually implement nush/pull
		length_is = None
		size_is = None
	else:
		field_type = FieldTypeSimple(elem, iface, idl_tbl, pointer_deref)

	if length_is:
		assert size_is
		field_type = FieldTypeLengthIsVector(field_type, size_is, length_is)
	elif size_is:
		field_type = FieldTypeSizeIsVector(field_type, size_is)
	elif array_len_name is not None:
		assert pointer_count == 0
		try:
			array_len = int(array_len_name)
		except:
			array_len = None
		if not array_len is None:
			field_type = FieldTypeArray(field_type, array_len)
		elif array_len_name == '*' and not has_any_property(elem, "size_is", "length_is"):
			field_type = FieldTypeUnboundVector(field_type)
		else:
			field_type = FieldTypeVector(field_type, array_len_name)

	for _ in range(pointer_count):
		assert not isinstance(field_type, FieldTypeDerived)
		assert pointer_type in [ "relative", "unique" ]
		if pointer_type == "relative":
			field_type = FieldTypeRelativePtr(field_type)
		else:
			field_type = FieldTypeUniquePtr(field_type)

	subcontext = elem_get_property(elem, 'subcontext')
	if subcontext is not None:
		assert not isinstance(field_type, FieldTypeDerived)
		subcontext_level = int(subcontext, 0)
		if subcontext_level in [0, 4]:
			subcontext_size = elem_get_property(elem, "subcontext_size")
			assert subcontext_size is not None
			field_type = FieldTypeSubctx(field_type, subcontext_level)
		elif subcontext_level == 0xFFFFFC01:
			field_type = FieldTypeSubctxFFFFFC01(field_type)
		else:
			assert False
	return Field(elem, field_type)

def make_fields(t, iface, idl_tbl, is_function):
	fields = [ make_field(e, t, iface, idl_tbl, is_function) for e in typedef_get_elements(t) ]
	for order, field in enumerate(fields):
		field.set_sibling(order, fields)

		if isinstance(field.field_type, FieldTypeXNdrSize):
			for f in fields:
				if f.name == field.master_field:
					f.x_ndr_sizes.append(field)
					field.master_field = f
					break
			else:
				assert False, f'Cannot find x_ndr_size {field.size_elem_name}'
		''' TODO
		elif isinstance(field.field_type, FieldSizeIsVector):
			for f in fields:
				if f.name == field.size_is:
					f.size_is_of = field
					field.size_is = f
					break
		elif isinstance(field.field_type, FieldLengthIsVector):
			for f in fields:
				if f.name == field.size_is:
					f.size_is_of = field
					field.size_is = f
				if f.name == field.length_is: # length_is and size_is can be same field
					f.size_is_of = field
					field.length_is = f
			#assert field.size_is is None or isinstance(field.size_is, FieldSizeIs)
			#assert field.length_is is None or isinstance(field.length_is, FieldSizeIs)
		elif isinstance(field.field_type, FieldSubctxSize):
			for f in fields:
				if f.name == field.subcontext_size_of:
					field.subcontext_size_of = f
					field.has_buffers = f.has_buffers
					f.subcontext_size = field
					break
			else:
				assert False
		if field.data_type == 'UNION' and not field.is_trivial:
			switch_is = field.get_property('switch_is')
			switch_is = switch_is.split('&')[0] # TODO
			for f in fields:
				if f.name == switch_is:
					f.nontrivial_unions.append(field)
					break
			else:
				assert False
		'''

	def dbg_output_fields(fields):
		return '\n\t'.join([ str(x) for x in fields ])
			
	DBG('%s fields:\n\t%s' % (t['NAME'], LazyToStr(dbg_output_fields, fields)))
	return fields

def output_header_element(out, field):
	out(f'''
	{field.declare()}
''')

def output_header_STRUCT(out, t, iface, idl, idl_tbl):
	fields = make_fields(t, iface, idl_tbl, False)
	tname = t["NAME"]

	has_buffers, has_nontrivial_unions, all_nontrivial_unions_are_ptr = False, False, True
	for field in fields:
		if field.has_buffers():
			has_buffers = True
		if field.nontrivial_unions:
			has_nontrivial_unions = True
			for nf in field.nontrivial_unions:
				if not nf.is_type(FieldTypePtr):
					all_nontrivial_unions_are_ptr = False

	out(f'''

struct {tname} {{
''')
	if any([len(f.nontrivial_unions) > 0 for f in fields]):
		out(f'''
	{tname}();
	~{tname}();
	{tname}({tname}&& other){" = default" if all_nontrivial_unions_are_ptr else ""};
	{tname}(const {tname}& other){" = default" if all_nontrivial_unions_are_ptr else ""};
	{tname} &operator=(const {tname}& other) = delete;
	{tname} &operator=({tname}&& other) = delete;
''')
		for switch_field in fields:
			if len(switch_field.nontrivial_unions) == 0:
				continue
			# TODO if elem_has_property(switch_field, 'value'):
			#	continue
			out(f'''
	void set_{switch_field.name}({switch_field.base_type} v);
''')

	for field in fields:
		output_header_element(out, field)
	out(f'''
}} {typedef_tostring_properties(t)};

template <> struct ndr_traits_t<{tname}> {{
	using ndr_base_type = {tname};
	using has_buffers = std::{"true" if has_buffers else "false"}_type;
	using ndr_data_type = x_ndr_type_struct;

	x_ndr_off_t scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	if has_buffers:
		out(f'''
	x_ndr_off_t buffers(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t buffers({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	out(f'''
	void ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};


''')

def get_first_case(typedef):
	for elem in typedef_get_elements(typedef):
		case = get_property(elem, "case")
		if case is not None:
			return case, elem
	
def output_struct_functions(idl, tname, fields, out):
	def union_field_iter(union_fields):
		for uf in union_fields:
			switch_is = uf.get_property("switch_is")
			yield uf, switch_is, uf.is_type(FieldTypePtr)
	
	has_buffers, has_nontrivial_unions, all_nontrivial_unions_are_ptr = False, False, True
	for field in fields:
		if field.has_buffers():
			has_buffers = True
		if field.nontrivial_unions:
			has_nontrivial_unions = True
			for nf in field.nontrivial_unions:
				if not nf.is_type(FieldTypePtr):
					all_nontrivial_unions_are_ptr = False

	for field in fields:
		if len(field.nontrivial_unions) == 0:
			continue
		out(f'''
void {tname}::set_{field.name}({field.base_type} v)
{{''')
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_uninit({uf.name}, x_ndr_switch_t({switch_is}));''')
		out(f'''
	{field.name} = v;''')
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}));''')
		out(f'''
}}

{tname}::{tname}()''')
	sep = ':'
	for field in fields:
		if len(field.nontrivial_unions) == 0:
			continue
		first_case, _ = get_first_case(field.nontrivial_unions[0].typedef)
		out(f'''
	{sep} {field.name}(({field.base_type}){first_case})''')
		sep = ','
	out('{')
	for field in fields:
		if len(field.nontrivial_unions) == 0:
			continue
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}));''')
	out(f'''
}}

{tname}::~{tname}()
{{''')
	for field in fields:
		if len(field.nontrivial_unions) == 0:
			continue
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_uninit({uf.name}, x_ndr_switch_t({switch_is}));''')
	out(f'''
}}

#if 0
TODO
{tname} &{tname}::operator=(const {tname} &other)
{{''')
	for field in fields:
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_uninit({uf.name}, x_ndr_switch_t({switch_is}));''')
		if not field.is_type(FieldTypeDerived) and (field.data_type != "UNION" or field.is_trivial()):
			out(f'''
	{field.name} = other.{field.name};''')
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}), other.{uf.name});''')
	out(f'''
	return *this;
}}
#endif
''')
	if not all_nontrivial_unions_are_ptr:
		out(f'''
{tname}::{tname}({tname} &&other)''')
		sep = ':'
		for field in fields:
			if not field.is_type(FieldTypeDerived) and (field.data_type != "UNION" or field.is_trivial()):
				out(f'''	{sep} {field.name}(other.{field.name})''')
				sep = ','
		out('{')		
		for field in fields:
			if len(field.nontrivial_unions) == 0:
				continue
			for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
				out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}), std::move(other.{uf.name}));''')
		out(f'''
}}

{tname}::{tname}(const {tname} &other)''')
		sep = ':'
		for field in fields:
			if not field.is_type(FieldTypeDerived) and (field.data_type != "UNION" or field.is_trivial()):
				out(f'''	{sep} {field.name}(other.{field.name})''')
				sep = ','
		out('{')		
		for field in fields:
			if len(field.nontrivial_unions) == 0:
				continue
			for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
				out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}), other.{uf.name});''')
		out(f'''
}}

''')

def output_ndrcxx_struct_scalars(out, func, fields, t, iface, idl, idl_tbl):
	flag = typedef_get_property(t, 'flag')
	if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
	alignment = max([field.get_alignment() for field in fields]) if fields else 1
	out(f'''
	X_NDR_HEADER_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);
''')
	if any([field.is_type(FieldTypeXSize) for field in fields]):
		out(f'''
	x_ndr_off_t __base = __bpos;
''')

	for field in fields:
		for stmt in field.scalars(func):
			out(f'''
	{stmt}''')

	if func == 'PUSH':
		for field in fields:
			if field.is_type(FieldTypeXSize):
				for stmt in field.scalars_post(func):
					out(f'''
	{stmt}''')
	else:
		if any([field.is_type(FieldTypeXSize) for field in fields]):
			out(f'''
	__bpos = __epos;''')

	out(f'''
	X_NDR_TRAILER_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);''')

def find_elem_by_name(elems, name):
	for e in elems:
		if e.name == name:
			return e
	return None

def output_ndrcxx_struct_buffers(out, func, fields, t, iface, idl, idl_tbl):
	for field in fields:
		if field.has_buffers():
			for stmt in field.buffers(func):
				out(f'''
	{stmt}''')

def output_ndrcxx_STRUCT(out, t, iface, idl, idl_tbl):
	fields = make_fields(t, iface, idl_tbl, False)
	tname = t["NAME"]
	has_buffers = any([field.has_buffers() for field in fields])
	out(f'''

/***** Generated function for {tname} *****/

''')

	if any([len(f.nontrivial_unions) > 0 for f in fields]):
		output_struct_functions(idl, tname, fields, out)

	if not typedef_has_property(t, "nopush"):
		out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		output_ndrcxx_struct_scalars(out, 'PUSH', fields, t, iface, idl, idl_tbl)
		out(f'''
	return __bpos;
}}

''')

		if has_buffers:
			out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::buffers(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			output_ndrcxx_struct_buffers(out, 'PUSH', fields, t, iface, idl, idl_tbl)
			out(f'''
	return __bpos;
}}

''')

	if not typedef_has_property(t, "nopull"):
		out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		output_ndrcxx_struct_scalars(out, 'PULL', fields, t, iface, idl, idl_tbl)
		out(f'''
	return __bpos;
}}

''')
		if has_buffers:
			out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::buffers({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			output_ndrcxx_struct_buffers(out, 'PULL', fields, t, iface, idl, idl_tbl)
			out(f'''
	return __bpos;
}}

''')

	if not typedef_has_property(t, "noprint"):
		out(f'''
void ndr_traits_t<{tname}>::ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const
{{''')
		flag = typedef_get_property(t, 'flag')
		if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
		out(f'''
	__ndr << enter;''');
		for field in fields:
			stmts = field.ostr()
			if len(stmts): out(f'''
	__ndr << "{field.name}:";''')
			for stmt in stmts:
				out(f'''
	{stmt}''')
			if len(stmts): out(f'''
	__ndr << next;''')
		out(f'''
	__ndr << leave;
}}

''')


def output_header_UNION(out, t, iface, idl, idl_tbl):
	fields = make_fields(t, iface, idl_tbl, False)
	tname = t["NAME"]
	out(f'''

union {tname}
{{
''')
	if any([not field.is_trivial() for field in fields]):
		out(f'''
	{tname}() {{ }}
	~{tname}() {{ }}
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, {tname} &&__other);
	void __init(x_ndr_switch_t __level, const {tname} &__other);
	void __uninit(x_ndr_switch_t __level);
''')
	# union member may has same name
	unique_fields = { }
	for field in fields:
		if field.name == '':
			continue
		try:
			prev = unique_fields[field.name]
			# TODO should check type_object assert prev.base_type == field.base_type
		except KeyError:
			output_header_element(out, field)
			unique_fields[field.name] = field
	out(f'''
}} {typedef_tostring_properties(t)};

template <> struct ndr_traits_t<{tname}> {{
	using ndr_base_type = {tname};
	using has_buffers = std::{"true_type" if any([field.has_buffers() for field in fields]) else "false_type"};
	using ndr_data_type = x_ndr_type_union;

	x_ndr_off_t scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	if any([field.has_buffers() for field in fields]): out(f'''
	x_ndr_off_t buffers(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t buffers({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	out(f'''
	void ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};
''')

def get_case_str(field):
	case_value = field.get_property('case')
	if case_value is not None:
		return f'case {case_value}'
	else:
		assert field.get_property('default')
		return 'default'

def union_field_for_each():
	pass

def output_ndrcxx_union_scalars(out, func, fields, t, iface, idl, idl_tbl):
	flag = typedef_get_property(t, 'flag')
	if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
	alignment = max([f.get_alignment() for f in fields])
	out(f'''
	X_NDR_UNION_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);
	switch (__level) {{
''')
	for field in fields:
		stmts = None
		if field.name != '':
			stmts = field.scalars(func)
		if stmts:
			out(f'''
		{get_case_str(field)}: {{''')
			for stmt in stmts:
				out(f'''
			{stmt}''')
			out(f'''
		}} break;
''')
	out('''
	}
''')

def output_ndrcxx_union_buffers(out, func, fields, t, iface, idl, idl_tbl):
	flag = typedef_get_property(t, 'flag')
	if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
	out(f'''
	switch (__level) {{
''')
	for field in fields:
		stmts = None
		if field.name != '' and field.has_buffers():
			stmts = field.buffers(func)
		if stmts:
			out(f'''
		{get_case_str(field)}: {{''')
			for stmt in stmts:
				out(f'''
			{stmt}''')
			out(f'''
		}} break;
''')
	out('''
	}
''')

def output_ndrcxx_UNION(out, t, iface, idl, idl_tbl):
	fields = make_fields(t, iface, idl_tbl, False)
	tname = t["NAME"]

	if any([not field.is_trivial() for field in fields]):
		out(f'''

void {tname}::__init(x_ndr_switch_t __level)
{{
	switch (__level) {{''')
		for field in fields:
			if field.name != '':
				in_case_str = f' construct({field.name});'
			else:
				in_case_str = ''
			out(f'''
		{get_case_str(field)}:{in_case_str} break;''')
		out(f'''
	}}
}}

void {tname}::__init(x_ndr_switch_t __level, {tname} &&other)
{{
	switch (__level) {{''')
		for field in fields:
			if field.name != '':
				in_case_str = f' construct({field.name}, std::move(other.{field.name}));'
			else:
				in_case_str = ''
			out(f'''
		{get_case_str(field)}:{in_case_str} break;''')
		out(f'''
	}}
}}

void {tname}::__init(x_ndr_switch_t __level, const {tname} &other)
{{
	switch (__level) {{''')
		for field in fields:
			if field.name != '':
				in_case_str = f' construct({field.name}, other.{field.name});'
			else:
				in_case_str = ''
			out(f'''
		{get_case_str(field)}:{in_case_str} break;''')
		out(f'''
	}}
}}

void {tname}::__uninit(x_ndr_switch_t __level)
{{
	switch (__level) {{''')
		for field in fields:
			if field.name != '':
				in_case_str = f' destruct({field.name});'
			else:
				in_case_str = ''
			out(f'''
		{get_case_str(field)}:{in_case_str} break;''')
		out(f'''
	}}
}}
''')

	has_buffers = any([field.has_buffers() for field in fields])

	if not typedef_get_property(t, "nopush"):
		out(f'''

x_ndr_off_t ndr_traits_t<{tname}>::scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		output_ndrcxx_union_scalars(out, 'PUSH', fields, t, iface, idl, idl_tbl)
		out(f'''
	return __bpos;
}}

''')
		if has_buffers:
			out(f'''

x_ndr_off_t ndr_traits_t<{tname}>::buffers(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			output_ndrcxx_union_buffers(out, 'PUSH', fields, t, iface, idl, idl_tbl)
			out(f'''
	return __bpos;
}}

''')
	if not typedef_get_property(t, "nopull"):
		out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		output_ndrcxx_union_scalars(out, 'PULL', fields, t, iface, idl, idl_tbl)
		out(f'''
	return __bpos;
}}

''')
		if has_buffers:
			out(f'''
x_ndr_off_t ndr_traits_t<{tname}>::buffers({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			output_ndrcxx_union_buffers(out, 'PULL', fields, t, iface, idl, idl_tbl)
			out(f'''
	return __bpos;
}}

''')

	if not typedef_has_property(t, "noprint"):
		out(f'''
void ndr_traits_t<{tname}>::ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const
{{''')
		flags = typedef_get_property(t, 'flags')
		if flags is not None: out(f'''
	x_ndr_set_flags(__flags, {flags});''')
		out(f'''
	switch (__level) {{
''')
		for field in fields:
			if field.name != '':
				for stmt in field.ostr(): out(f'''
		{get_case_str(field)}: {stmt} break;''')
		out(f'''
	}}
}}

''')


def map_enum_type(t):
	assert t['DATA']['TYPE'] == "ENUM"

	# for typedef enum { } we need to check $enum->{PARENT}
	if typedef_has_property(t, "enum8bit"):
		return "uint8", "uint8"
	elif typedef_has_property(t, "enum16bit"):
		return "uint16", "uint16"
	elif typedef_has_property(t, "v1_enum"):
		return "uint32", "uint32"
	else:
		warn(f'at {t["FILE"]}:{t["LINE"]} unknown enum properties {t["DATA"].get("PROPERTIES", None)}')
		# should be uint16? TODO
		return "uint16", "uint1632"

def output_header_ENUM(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	elements = typedef_get_elements(t)
	etype, fname = map_enum_type(t)
	out(f'''

enum {tname} : {etype} {{
''')
	for elem in elements:
		out(f'''
	{elem},
''')
		#out(re.sub(r'^(.*)=(.*)$', r'\1=\2,', elem))
	out(f'''
}}{typedef_tostring_properties(t)};

X_NDR_DECLARE_TRAITS_ENUM({tname}, {etype}, {len(elements)}, x_ndr_type_enum)

''')

def output_ndrcxx_ENUM(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	etype, fname = map_enum_type(t)
	tdata = t['DATA']
	if not "ELEMENTS" in tdata:
		return
	out(f'''
const std::array<std::pair<{etype}, const char *>, {len(tdata["ELEMENTS"])}> ndr_traits_t<{tname}>::value_name_map = {{ {{
''')
	for elem in tdata["ELEMENTS"]:
		ev = elem.split('=')[0]
		out(f'''
	{{ {ev}, "{ev}" }},
''')
	out('''
} };


''')

def map_bitmap_type(t):
	assert t['DATA']['TYPE'] == "BITMAP"

	if typedef_has_property(t, "bitmap8bit"):
		return "uint8", "uint8"
	elif typedef_has_property(t, "bitmap16bit"):
		return "uint16", "uint16"
	elif typedef_has_property(t, "bitmap32bit"):
		return "uint32", "uint32"
	elif typedef_has_property(t, "bitmap64bit"):
		return "uint64", "uint64"
	else:
		warn(f'at {t["FILE"]}:{t["LINE"]} {t["NAME"]} unknown bits')
		return "uint32", "uint32"

def output_header_BITMAP(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	etype, fname = map_bitmap_type(t)
	elements = typedef_get_elements(t)
	out(f'''

enum {tname} : {etype} {{
''')
	for elem in elements:
		statement = re.sub(r'^([^ ]+) *\( *([^ ]+) *\)$', r'\1=\2,', elem)
		out(f'''
	{statement}
''')
	out(f'''
}}{typedef_tostring_properties(t)};

X_NDR_DECLARE_TRAITS_ENUM({tname}, {etype}, {len(elements)}, x_ndr_type_bitmap)

''')

def output_ndrcxx_BITMAP(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	etype, fname = map_bitmap_type(t)
	elements = typedef_get_elements(t)
	out(f'''
const std::array<std::pair<{etype}, const char *>, {len(elements)}> ndr_traits_t<{tname}>::value_name_map = {{ {{''')
	for elem in elements:
		ev = re.sub(r'^([^ ]+) *\( *([^ ]+) *\)$', r'\1', elem)
		out(f'''
	{{ {ev}, "{ev}" }},
''')
	out('''
} };


''')

def output_header_FUNCTION(out, t, iface, idl, idl_tbl):
	assert t['RETURN_TYPE'] in [ 'WERROR', 'NTSTATUS' ]

	fields = make_fields(t, iface, idl_tbl, True)
	tname = t["NAME"]

	has_nontrivial_unions, all_nontrivial_unions_are_ptr = False, False
	for field in fields:
		if field.nontrivial_unions:
			has_nontrivial_unions = True
			for nf in field.nontrivial_unions:
				if not nf.is_type(FieldTypePtr):
					all_nontrivial_unions_are_ptr = False

	out(f'''

struct {tname} {{
''')
	if any([len(f.nontrivial_unions) > 0 for f in fields]):
		out(f'''
	{tname}();
	~{tname}();
	{tname}(const {tname}& other) = delete;
	{tname} &operator=(const {tname}& other) = delete;
	{tname}({tname}&& other){" = default" if all_nontrivial_unions_are_ptr else ""};
	{tname} &operator=({tname}&& other) = delete;
''')
		for switch_field in fields:
			if len(switch_field.nontrivial_unions) == 0:
				continue
			# TODO if elem_has_property(switch_field, 'value'):
			#	continue
			out(f'''
	void set_{switch_field.name}({switch_field.base_type} v);
''')

	for field in fields:
		output_header_element(out, field)
	out(f'''
	{t['RETURN_TYPE']} __result;
}} {function_tostring_properties(t)};

template <> struct ndr_requ_traits_t<{tname}> {{
	using ndr_base_type = {tname};
	using has_buffers = std::false_type;
	using ndr_data_type = x_ndr_type_struct;

	x_ndr_off_t scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	void ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};

template <> struct ndr_resp_traits_t<{tname}> {{
	using ndr_base_type = {tname};
	using has_buffers = std::false_type;
	using ndr_data_type = x_ndr_type_struct;

	x_ndr_off_t scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	void ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};


''')

def output_ndrcxx_FUNCTION(out, t, iface, idl, idl_tbl):
	fields = make_fields(t, iface, idl_tbl, True)
	tname = t["NAME"]

	if not get_property(t, 'in_nopush'):
		out(f'''
x_ndr_off_t ndr_requ_traits_t<{tname}>::scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		for field in fields:
			if field.get_property('in'):
				for stmt in field.scalars('PUSH'):
					out(f'''
	{stmt}''')
				if field.has_buffers():
					for stmt in field.buffers('PUSH'):
						out(f'''
	{stmt}''')
		out(f'''
	return __bpos;
}}

''')
	if not get_property(t, 'out_nopush'):
		out(f'''
x_ndr_off_t ndr_resp_traits_t<{tname}>::scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		for field in fields:
			if field.get_property('out'):
				for stmt in field.scalars('PUSH'):
					out(f'''
	{stmt}''')
				for stmt in field.buffers('PUSH'):
					out(f'''
	{stmt}''')
		out(f'''
	X_NDR_SCALARS_DEFAULT(__val.__result, __ndr, __bpos, __epos, __flags, X_NDR_SWITCH_NONE);
	return __bpos;
}}

''')
	if not get_property(t, 'in_nopull'):
		out(f'''
x_ndr_off_t ndr_requ_traits_t<{tname}>::scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		for field in fields:
			if field.get_property('in'):
				for stmt in field.scalars('PULL'):
					out(f'''
	{stmt}''')
				if field.has_buffers():
					for stmt in field.buffers('PULL'):
						out(f'''
	{stmt}''')
		out(f'''
	return __bpos;
}}

''')
	if not get_property(t, 'out_nopull'):
		out(f'''
x_ndr_off_t ndr_resp_traits_t<{tname}>::scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		for field in fields:
			if field.get_property('out'):
				for stmt in field.scalars('PULL'):
					out(f'''
	{stmt}''')
				for stmt in field.buffers('PULL'):
					out(f'''
	{stmt}''')
		out(f'''
	X_NDR_SCALARS_DEFAULT(__val.__result, __ndr, __bpos, __epos, __flags, X_NDR_SWITCH_NONE);
	return __bpos;
}}

''')


def output_header_INTERFACE(out, iface, idl, idl_tbl):

	for t in iface['DATA']:
		if t['TYPE'] == 'TYPEDEF':
			realtype = typedef_get_realtype(t)
			if realtype == 'STRUCT':
				output_header_STRUCT(out, t, iface, idl, idl_tbl)
			elif realtype == 'UNION':
				output_header_UNION(out, t, iface, idl, idl_tbl)
			elif realtype == 'ENUM':
				output_header_ENUM(out, t, iface, idl, idl_tbl)
			elif realtype == 'BITMAP':
				output_header_BITMAP(out, t, iface, idl, idl_tbl)
			else:
				error(f'''Unknown typedef "{realtype}" at {t["FILE"]}:{t["LINE"]}''')
				assert False
		elif t['TYPE'] == 'CONST':
			dtype = t['DTYPE']
			assert const_get_pointers(t) == 0
			out(f'''
const {dtype}{'*' if t['POINTERS'] == 1 else ''} {t['NAME']} = {t['VALUE']};
''')
		elif t["TYPE"] in [ "FUNCTION" ]:
			output_header_FUNCTION(out, t, iface, idl, idl_tbl)
		else:
			error(f'''Unknown type "{t['TYPE']}" at {t['FILE']}:{t['LINE']}''')
			assert False


def output_ndrcxx_INTERFACE(out, iface, idl, idl_tbl):
	helper = get_property(iface, "helper")
	if helper is not None:
		out(f'''
#include {helper}
''')
	out(f'''

namespace idl {{

''')
	for t in iface['DATA']:
		if t['TYPE'] == 'TYPEDEF':
			"""
			if t['NAME'] in known_structs:
				continue
			"""
			realtype = typedef_get_realtype(t)
			if realtype == 'STRUCT':
				output_ndrcxx_STRUCT(out, t, iface, idl, idl_tbl)
			elif realtype == 'UNION':
				output_ndrcxx_UNION(out, t, iface, idl, idl_tbl)
			elif realtype == 'ENUM':
				output_ndrcxx_ENUM(out, t, iface, idl, idl_tbl)
			elif realtype == 'BITMAP':
				output_ndrcxx_BITMAP(out, t, iface, idl, idl_tbl)
			else:
				assert False
		elif t['TYPE'] in [ "FUNCTION" ]:
			output_ndrcxx_FUNCTION(out, t, iface, idl, idl_tbl)
		elif t['TYPE'] in [ "CONST", "FUNCTION" ]:
			pass
		else:
			assert False

	out(f'''

// }}
}}
''')

def output_header_IMPORT(out, o):
	for path in o['PATHS']:
		import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
		out(f'#include "include/librpc/{import_name}.hxx"')
	out()

def process_header(out, name, idl, idl_tbl, outdir):
	ifacename = None
	for o in idl:
		if o['TYPE'] == "INTERFACE":
			ifacename = o['NAME']
			break

	out(f'''
/* header auto-generated by gen-rpc */
#ifndef __GEN_RPC__HEADER_{ifacename}
#define __GEN_RPC__HEADER_{ifacename}
#include "include/librpc/ndr_smb.hxx"

''')

	for o in idl:
		if o['TYPE'] == "IMPORT": output_header_IMPORT(out, o)
		if o['TYPE'] == "INCLUDE": output_header_INCLUDE(out, o)

	out(f'''
namespace idl {{
''')

	for o in idl:
		#if o['TYPE'] == "CPP_QUOTE": output_header_QUOTE(out, o)
		if o['TYPE'] == "INTERFACE": output_header_INTERFACE(out, o, idl, idl_tbl)
			
	out(f'''

}} /* namespace idl */

#endif /* __GEN_RPC__HEADER_{ifacename} */

''')


def process_ndrcxx(out, name, idl, idl_tbl, outdir):
	out(f'''
/* ndr parser auto-generated by pidl */
	
#include "include/librpc/{name}.hxx"

''')

	for o in idl:
		if o['TYPE'] == "INTERFACE": output_ndrcxx_INTERFACE(out, o, idl, idl_tbl)



def process_depend(out, name, idl, idl_tbl, outdir):
	for o in idl:
		if o['TYPE'] != "IMPORT":
			continue
		for path in o['PATHS']:
			import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
			out(f'''
{outdir}/{name}.idl.hxx: {outdir}/{import_name}.json
{outdir}/{name}.idl.ndr.cxx: include/librpc/{import_name}.hxx
{outdir}/{name}.idl.ndr.o: include/librpc/ndr.hxx
{outdir}/{name}.idl.ndr.o: include/librpc/ndr_smb.hxx
''')

def load_idl_with_import(infp):
	imports = []
	idl = json.load(infp)
	for o in idl:
		if o['TYPE'] != "IMPORT":
			continue
		for path in o['PATHS']:
			import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
			imports.append(import_name)
	return idl, imports

def load_all(infp, name, path, recur):
	idl_tbl = {}
	idl, imports = load_idl_with_import(infp)
	idl_tbl[name] = idl

	while recur and imports:
		name = imports.pop()
		if name in idl_tbl:
			continue
		filename = os.path.join(path, '.'.join([name, "json"]))
		with open(filename, 'r') as fp:
			new_idl, new_imports = load_idl_with_import(fp)
			idl_tbl[name] = new_idl
			imports += new_imports
	return idl, idl_tbl

def process(infp, name, args):
	idl, idl_tbl = load_all(infp, name, args.outputdir, args.header or args.ndrcxx)

	def output(func, ext):
		if name is None:
			outfp = sys.stdout
		else:
			tmpfix = "tmp"
			filename = os.path.join(args.outputdir, '.'.join([name, ext, tmpfix]))
			outfp = open(filename, 'w')

		try:
			out = OStream(outfp)
			func(out, name, idl, idl_tbl, args.outputdir)
		except:
			if name is not None:
				outfp.close()
				os.remove(filename)
			raise
		if name is not None:
			os.rename(filename, os.path.join(args.outputdir, '.'.join([name, ext])))
	
	if args.depend: output(process_depend, 'd')
	if args.header: output(process_header, 'idl.hxx')
	if args.ndrcxx: output(process_ndrcxx, 'idl.ndr.cxx')
	if args.python: output(process_python, 'py.cxx')
			
	
def main():
	parser = argparse.ArgumentParser()
	parser.add_argument("-d", "--debug", action="store_true", help="output debug info")
	parser.add_argument("--depend", action="store_true", help="output dependency")
	parser.add_argument("--header", action="store_true", help="output header")
	parser.add_argument("--ndrcxx", action="store_true", help="output ndr")
	parser.add_argument("--python", action="store_true", help="output ndr")
	parser.add_argument("--outputdir", default=".", help="output directory")
	parser.add_argument("input", nargs='*', help="Input IDL json files")

	args = parser.parse_args()
	args.outputdir = args.outputdir.rstrip('/')
	if args.debug:
		global DBG
		print(args, file=sys.stderr)
		DBG = _dbg_stderr

	if len(args.input) == 0:
		process(sys.stdin, None, args)
	else:
		for f in args.input:
			with open(f, 'r') as fp:
				name = os.path.splitext(os.path.basename(f))[0]
				process(fp, name, args)

	return 0

if __name__ == "__main__": sys.exit(main())

'''
class FieldVector(FieldTypeBase):
	def __init__(self, json_elem, idl_tbl, array_len_elem):
		super().__init__(json_elem, idl_tbl)
		self.array_len_elem = array_len_elem
	def declare__(self):
		return f'std::vector<{self.base_type}> {self.name};'
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SCALARS_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_BUFFERS_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def ostr__(self):
		return f'X_NDR_OSTR_VECTOR({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'
class FieldUniqueVector(FieldTypePtr):
	def __init__(self, json_elem, idl_tbl, pointers, size_is, length_is):
		super().__init__(json_elem, idl_tbl)
		self.pointers, self.size_is, self.length_is = pointers, size_is, length_is
	def declare__(self):
		base_type = self.base_type
		for _ in range(self.pointers - 1):
			base_type = f'std::shared_ptr<{base_type}>'
		return f'std::shared_ptr<std::vector<{base_type}>> {self.name}; /* FieldUniqueVector */'
	def get_ndr_traits(self):
		assert self.ndr_traits is None, 'TODO'

		ndr_traits = super().get_ndr_traits()
		base_type = self.base_type
		for _ in range(self.pointers - 1):
			ndr_traits = f'ndr_traits_unique_ptr_t<{base_type}, {ndr_traits}>'
			base_type = f'std::shared_ptr<{base_type}>'
		return ndr_traits
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_VERIFY(({bpos_arg}), x_ndr_scalars_unique_vector(__val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()}));'
		#return f'X_NDR_SCALARS_UNIQUE_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		ret = [ f'X_NDR_VERIFY(({bpos_arg}), x_ndr_buffers_unique_vector({self.get_ndr_traits()}{{}}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()}, {"true" if self.length_is else "false"}));' ]
		#ret = [ f'X_NDR_BUFFERS_UNIQUE_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()}, {"true" if self.length_is else "false"});' ]
		if self.order > self.size_is.order:
			ret.append(f'X_NDR_SIZE_AT(__at_{self.size_is.name}, {ndr_arg}, __val.{self.name}, {epos_arg});')
		if self.length_is and self.order > self.length_is.order:
			ret.append(f'X_NDR_SIZE_AT(__at_{self.length_is.name}, {ndr_arg}, __val.{self.name}, {epos_arg});')
		return ret
	def ostr__(self):
		return f'x_ndr_ostr_ptr_vector({self.get_ndr_traits()}{{}}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'
		#return f'X_NDR_OSTR_PTR_VECTOR({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'

class FieldRelativeVector(FieldTypePtr):
	def __init__(self, json_elem, idl_tbl, pointers, size_is, length_is):
		super().__init__(json_elem, idl_tbl)
		self.pointers, self.size_is, self.length_is = pointers, size_is, length_is
	def declare__(self):
		base_type = self.base_type
		for _ in range(self.pointers - 1):
			base_type = f'std::shared_ptr<{base_type}>'
		return f'std::shared_ptr<std::vector<{base_type}>> {self.name}; /* FieldRelativeVector */'
	def scalars__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		return f'X_NDR_SAVE_POS(uint32, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()});'
	def buffers__(self, func, ndr_arg, bpos_arg, epos_arg, flags_arg):
		ret = [f'X_NDR_BUFFERS_RELATIVE_VECTOR({self.get_ndr_traits()}, __val.{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {self.get_ndr_flags()}, {self.get_switch_is()}, __at_{self.name}, {"true" if self.length_is else "false"});' ]
		if self.order > self.size_is.order:
			ret.append(f'X_NDR_SIZE_AT(__at_{self.size_is.name}, {ndr_arg}, __val.{self.name}, {epos_arg});')
		if self.length_is and self.order > self.length_is.order:
			ret.append(f'X_NDR_SIZE_AT(__at_{self.length_is.name}, {ndr_arg}, __val.{self.name}, {epos_arg});')
		return ret
	def ostr__(self):
		return f'x_ndr_ostr_ptr_vector({self.get_ndr_traits()}{{}}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'
		#return f'X_NDR_OSTR_PTR_VECTOR({self.get_ndr_traits()}, __val.{self.name}, __ndr, {self.get_ndr_flags()}, {self.get_switch_is()});'

'''

