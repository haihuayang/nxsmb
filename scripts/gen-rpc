#!/usr/bin/env python3

from __future__ import print_function
import os, sys
from io import StringIO
import re, argparse, json

class OStream(object):
	def __init__(self, fp):
		self.fp = fp
	def write(self, s):
		self.fp.write(s)
	def __call__(self, s=''):
		try:
			if s[0] == '\n':
				s = s[1:]
		except:
			pass

		self.fp.write(s)
		try:
			if s[-1] == '\n':
				return
		except:
			pass
		self.fp.write('\n')

def _dbg_none(*args):
	pass

def _dbg_stderr(*args):
	print("DBG:", *args, file=sys.stderr)

DBG = _dbg_none

def warn(msg):
	print("Warning:", msg, file = sys.stderr)

def error(msg):
	print("Error:", msg, file = sys.stderr)

F_STRUCT = 0x1
F_UNION  = 0x2
know_properties = {
	'case': F_UNION,
	'default': F_UNION,
	'flag': F_STRUCT | F_UNION,
	'range': F_STRUCT,
	'value': F_STRUCT | F_UNION,
	'charset': F_STRUCT | F_UNION,
	'switch_is': F_STRUCT,
	'switch_type': F_STRUCT,
	'size_is': F_STRUCT,
	'in': F_STRUCT, # TODO
	'unique': F_STRUCT, # TODO
	'length_is': F_STRUCT, # TODO
	'noprint': F_STRUCT | F_UNION, # TODO
	#'ignore': F_STRUCT | F_UNION, # TODO
	'x_ignored': F_STRUCT,
	'string': F_STRUCT | F_UNION, # TODO
	'compression': F_STRUCT | F_UNION, # TODO
	'subcontext': F_STRUCT | F_UNION, # TODO rewrite
	'subcontext_size': F_STRUCT | F_UNION, # TODO rewrite
	'relative': F_STRUCT | F_UNION, # TODO rewrite
	'relative_short': F_STRUCT | F_UNION, # TODO rewrite
	'ref': F_STRUCT | F_UNION, # TODO rewrite
	'x_elem_size': F_STRUCT,
	'x_length': F_STRUCT,
	#'x_offset': F_STRUCT,
	'x_skip': F_STRUCT,
	'x_size': F_STRUCT,
	#'x_with_size': F_STRUCT,
	'x_relative': F_STRUCT,
	'x_group_start': F_STRUCT,
	'x_group_end': F_STRUCT,
	'x_pull_value': F_STRUCT,
}

known_simple_types = {
	# name, align, is_trival, has_buffer
        'EMPTY': [ 0, True, False],
        'void': [0, True, False],
        'char': [1, True, False],
        'int8': [1, True, False],
        'uint8': [1, True, False],
        'int16': [2, True, False],
        'uint16': [2, True, False],
        'int1632': [3, True, False],
        'uint1632': [3, True, False],
        'int': [4, True, False], # int32
        'int32': [4, True, False],
        'long': [4, True, False], # uint32
        'DWORD': [4, True, False],
        'WORD': [2, True, False],
        'uint32': [4, True, False],
        'mode_t': [4, True, False], # uint32
        'boolean8': [1, True, False],
        'boolean32': [4, True, False], # uint32
        'int3264': [5, True, False],
        'uint3264': [5, True, False],
        'uint64': [8, True, False],
        'double': [8, True, False],
        'pointer': [8, True, False],
        'dlong': [4, True, False],
        'udlong': [4, True, False],
        'udlongr': [4, True, False],
        'hyper': [4, True, False],
#        'blob_t': [4, False],
        'DATA_BLOB': [4, False, False],
	'dom_sid0': [4, True, False],
	'dom_sid': [4, True, False],
        'u16string': [4, False, True],
        'string': [4, False, True],
        'astring': [4, False, True],
        'gstring': [4, False, True],
        'nstring': [4, False, True],
        'nstring_array': [4, False, True], #???
        'string_array': [4, False, True], #???
        'time_t': [4, True, False],
        'uid_t': [8, True, False],
        'gid_t': [8, True, False],
        'NTTIME': [4, True, False],
        'NTTIME_1sec': [4, True, False],
        'NTTIME_hyper': [8, True, False],
        'HRESULT': [4, True, False],
        'WERROR': [4, True, False],
        'NTSTATUS': [4, True, False],
        'COMRESULT': [4, False, True],
        'dns_string': [4, False, True],
        'nbt_string': [4, False, True],
        'wrepl_nbt_name': [4, False, True],
        'ipv4address': [4, True, False],
        'ipv6address': [4, True, False], #16?
        'dnsp_name': [1, False, True],
        'dnsp_string': [1, False, True],
        'utf8string': [1, False, True],
	'lsa_String': [5, False, True],
	'lsa_StringLarge': [5, False, True],
	'lsa_AsciiStringLarge': [5, False, True],
	'lsa_BinaryString': [5, False, True],
	'samr_LogonHours': [5, False, True],
	'netr_DELTA_POLICY_OPTIONS': [4, False, True],
}

def elem_check_properties(elem, flag):
	if not 'PROPERTIES' in elem:
		return
	for name, value in elem['PROPERTIES'].items():
		try:
			flags = know_properties[name]
			if (flag & flags) == 0:
				error(f'at {elem["FILE"]}:{elem["LINE"]} Property {name} not support {flag}')
				assert False
		except KeyError:
			error(f"Unknown property {name}.")
			assert False

def elem_get_property(t, prop, default = None):
	try:
		return t['PROPERTIES'][prop]
	except KeyError:
		return default

def elem_get_pointer_type(elem, iface):
	for t in [ "unique", "relative" ]:
		try:
			v = elem["PROPERTIES"][t]
		except:
			continue
		assert v == "1"
		return t
	try:
		return iface['pointer_default']
	except:
		return "unique"

def elem_has_property(elem, *args):
	try:
		prop = elem['PROPERTIES']
	except:
		return False
	for arg in args:
		if arg in prop:
			return True
	return False

def elem_get_array_len(elem):
	try:
		array_len = elem['ARRAY_LEN']
		if len(array_len) == 0:
			return None
		assert len(array_len) == 1
		return array_len[0]
	except KeyError:
		return None

def elem_get_pointers(elem):
	try:
		v = elem['POINTERS']
	except KeyError:
		return 0
	assert v in [0, 1]
	return v

def elem_is_property_of(elem, t, *args):
	for me in typedef_get_elements(t):
		for prop in args:
			try:
				if elem["NAME"] == elem_get_property(me, prop):
					return me
			except:
				pass
	return None

def elem_get_array_elem(elem, st):
	array_len = elem_get_array_len(elem)
	for elem2 in typedef_get_elements(st):
		if elem2['NAME'] == array_len:
			return elem2
	return None

def elem_get_type_name(t):
	return t["TYPE"]

def elem_get_ndr_flags(elem):
	ndr_flags = elem_get_property(elem, "flag")
	if ndr_flags is not None:
		return f'x_ndr_set_flags(__flags, {ndr_flags})'
	else:
		return '__flags'


def get_property(t, prop, default = None):
	try:
		return t['PROPERTIES'][prop]
	except KeyError:
		return default

def typedef_get_property(t, prop, default = None):
	try:
		return t['PROPERTIES'][prop]
	except KeyError:
		return default

# TODO
def has_property(t, prop):
	v = get_property(t, prop)
	if v is None:
		return False
	assert v == '1'
	return True

def typedef_has_property(t, prop):
	return has_property(t['DATA'], prop);

def typedef_get_elements(t):
	assert t['TYPE'] == 'TYPEDEF'
	try:
		return t['DATA']['ELEMENTS']
	except:
		return []

def typedef_get_realtype(t):
	return t['DATA']['TYPE']

def typedef_find_elem(t, name):
	for elem in typedef_get_elements(t):
		if elem["NAME"] == name:
			return elem
	return None

def find_type(idl, tname):
	for o in idl:
		if o['TYPE'] != "INTERFACE":
			continue
		for t in o['DATA']:
			if t['TYPE'] == "TYPEDEF" and t['NAME'] == tname:
				return t
	return None

def find_type_idl_tbl(idl_tbl, tname):
	for _, idl in idl_tbl.items():
		t = find_type(idl, tname)
		if t is not None:
			return t
	return None

def elem_has_buffers(elem, idl_tbl):
	def has_buffers_2(t):
		for elem in typedef_get_elements(t):
			has_buffers = has_buffers_1(elem)
			if has_buffers:
				return True
		return False

	def has_buffers_1(elem):
		if elem_get_pointers(elem):
			'''
			subcontext = elem_get_property(elem, "subcontext")
			if subcontext == "0xFFFFFC01":
				continue
			elif subcontext is not None:
				assert False # TODO
			'''
			return True
		et_name = elem['TYPE']
		try:
			return known_simple_types[et_name][2]
		except KeyError:
			pass
		et = find_type_idl_tbl(idl_tbl, et_name)
		assert et is not None

		if "has_buffers" in et:
			return et["has_buffers"]
		realtype = typedef_get_realtype(et)
		if realtype in [ "ENUM", "BITMAP" ]:
			return False
		elif realtype in [ "STRUCT", "UNION" ]:
			has_buffers = has_buffers_2(et)
			et["has_buffers"] = has_buffers
			return has_buffers
		else:
			assert False
	return has_buffers_1(elem)

# samba/pidl/lib/Parse/Pidl/NDR.pm align_type
def typedef_get_align(idl_tbl, typedef):
	class NotFound(Exception):
		def __init__(self, elem):
			self.elem = elem

	def get_elem_align(elem):
		#assert not has_property(elem, "subcontext"), "TODO"
		#assert not has_property(elem, "transmit_as"), "TODO"
		et_name = elem['TYPE']
		try:
			return known_simple_types[et_name][0]
		except KeyError:
			pass
		et = find_type_idl_tbl(idl_tbl, elem['TYPE'])
		if et is None:
			raise NotFound(elem)

		return get_align_1(et)

	def find_largest_alignment(elems):
		align = 1
		for elem in elems:
			if elem_get_pointers(elem):
				# this is a hack for NDR64
				# the NDR layer translates this into
				# an alignment of 4 for NDR and 8 for NDR64
				a = 5
			else:
				a = get_elem_align(elem)
			if align < a:
				align = a
		return align

	def get_align_2(t):
		assert t["TYPE"] == "TYPEDEF"
		realtype = typedef_get_realtype(t)

		if realtype in [ "STRUCT", "UNION" ]:
			elements = typedef_get_elements(t)
			return find_largest_alignment(elements) if len(elements) else 4
		elif realtype == "ENUM":
			_, ftype = map_enum_type(t)
			return known_simple_types[ftype][0]
		elif realtype == "BITMAP":
			_, ftype = map_bitmap_type(t)
			return known_simple_types[ftype][0]
		else:
			assert False
	def get_align_1(t):
		try:
			return t['x_align']
		except:
			pass
		align = get_align_2(t)
		DBG(f'get_align({t["NAME"]})={align}')
		t['x_align'] = align
		return align
	try:
		return get_align_1(typedef)
	except NotFound as e:
		error(f'''Cannot find type "{e.elem['TYPE']}" at {e.elem['FILE']}:{e.elem['LINE']}''')
		raise

def typedef_get_buffers(typedef, idl_tbl):
	realtype = typedef_get_realtype(typedef)
	if realtype in [ "STRUCT" ]:
		return [ elem for elem in typedef_get_elements(typedef) if elem_has_buffers(elem, idl_tbl) ]
	else:
		assert False

def typedef_get_nontrivial_union_fields(t, idl, idl_tbl):
	union_fields = [[elem, []] for elem in typedef_get_elements(t)]
	for uf in union_fields:
		elem = uf[0]
		et = find_type(idl, elem["TYPE"])
		if et is not None and et['DATA']["TYPE"] == "UNION" and not is_trivial(idl_tbl, et):
			#uf[1] = None
			switch_is = elem_get_property(elem, "switch_is")
			assert switch_is is not None
			switch_field = get_switch_field(switch_is)
			for switch_elem, unions in union_fields:
				if switch_elem["NAME"] == switch_field:
					break
			else:
				assert False, f'cannot find the switch field {switch_field}'
			unions.append((elem, et))
	return [(elem, unions) for elem, unions in union_fields if len(unions) > 0]

def tostring_properties__(elem):
	if 'PROPERTIES' in elem:
		ret = []
		for key, val in elem['PROPERTIES'].items():
			if val != '1':
				ret.append(f'{key}({val})')
			else:
				ret.append(key)
		return '/* [' + ', '.join(ret) + '] */'
	else:
		return ''

def elem_tostring_properties(e):
	return tostring_properties__(e)

def typedef_tostring_properties(t):
	return tostring_properties__(t['DATA'])

def elem_is_switch(f, union_fields):
	for uf, unions in union_fields:
		if uf["NAME"] == f["NAME"]:
			return len(unions) > 0
	else:
		return False


def output_header_IMPORT(o, out):
	for path in o['PATHS']:
		import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
		out(f'#include "include/librpc/{import_name}.hxx"')
	out()

def output_header_INCLUDE(o, out):
	for path in o['PATHS']:
		out(f'#include {path}')
	out()

def output_header_QUOTE(o, out):
	quote = o['DATA']
	out(re.sub('^"(.*)"$', r'\1', quote))
	out()

def output_header_element(out, elem, t, iface, x_length_types):
	et = elem_get_type_name(elem)
	array_len = elem_get_array_len(elem)
	charset = elem_get_property(elem, "charset")
	string = elem_get_property(elem, "string")
	x_length = elem_get_property(elem, "x_length")
	if elem_has_property(elem, "size_is", "length_is"):
		assert elem_get_pointers(elem) == 1
		
	if elem_is_property_of(elem, t, "size_is", "length_is"):
		return

	if charset == "UTF16" and string == "1":
		assert array_len is None
		assert elem['TYPE'] == "uint16"
		assert elem_get_pointers(elem) != 0
		et = 'u16string'
	elif array_len is not None:
		assert elem_get_pointers(elem) == 0
		assert charset is None or (charset in ["DOS", "UTF8", "UTF16", "UNIX"])
		try:
			array_len = int(array_len)
			et = f'std::array<{et}, {array_len}>'
		except:
			if False and charset is not None: # TODO
				array_elem = typedef_find_elem(t, array_len)
				value = elem_get_property(array_elem, "value")
				prop, elem_name = re.search('^(.*)\((.*)\)$', value).groups()
				assert elem_name == elem['NAME']
				if prop == 'strlen_m_term_null':
					assert elem['TYPE'] == 'uint8'
					field = f'NDR_t_DOS_strlen_m_term_null {elem["NAME"]}'
				else:
					# TODO assert prop == 'strlen_m_term_null'
					field = f"{et} {elem['NAME']}"
			elif array_len == '*':
				et = f'x_ndr_vector_t<{et}>'
			else:
				et = f'x_ndr_vector_with_count_t<{et}>'
	else:
		assert charset is None or (charset in ["DOS", "UTF8", "UTF16"])

	if elem_get_pointers(elem) == 1:
		size_is = elem_get_property(elem, "size_is")
		length_is = elem_get_property(elem, "length_is")

		if length_is is not None:
			assert len(x_length_types) == 0
			assert size_is is not None
			elem_length_is = typedef_find_elem(t, length_is)
			assert elem_length_is is not None
			elem_size_is = typedef_find_elem(t, size_is)
			assert elem_size_is is not None
			assert elem_size_is["TYPE"] == elem_length_is["TYPE"]
			et = f'x_ndr_unique_ptr_with_size_length_t<{et}, {elem_size_is["TYPE"]}>'
		elif size_is is not None:
			assert len(x_length_types) == 0
			elem_size_is = typedef_find_elem(t, size_is)
			et = f'x_ndr_array_ptr_with_size_is<{et}, {elem_size_is["TYPE"]}>'
			#et = f'x_ndr_vector_with_count_t<{et}>'
		else:
			pointer_type = elem_get_pointer_type(elem, iface)
			if len(x_length_types) > 0:
				length_types = ', ' +  ', '.join(x_length_types)
			else:
				length_types = ''
			if pointer_type == "unique":
				et = f'x_ndr_unique_ptr_t<{et}{length_types}>'
			elif pointer_type == "relative":
				et = f'x_ndr_relative_ptr_t<{et}{length_types}>'
			else:
				assert False

	if elem_get_property(elem, "subcontext") == "0xFFFFFC01":
		et = f'x_ndr_subndr_t<{et}>'

	out(f'''
	{et} {elem["NAME"]};{elem_tostring_properties(elem)}
''')

def output_header_STRUCT(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	union_fields = typedef_get_nontrivial_union_fields(t, idl, idl_tbl)
	buffers = typedef_get_buffers(t, idl_tbl)

	out(f'''

struct {tname} {{
''')
	if any([len(u) > 0 for _, u in union_fields]):
		out(f'''
	{tname}();
	~{tname}();
	{tname}(const {tname}& other);
	{tname} &operator=(const {tname}& other);
''')
		for switch_field, _ in union_fields:
			if elem_has_property(switch_field, 'value'):
				continue
			out(f'''
	void set_{switch_field["NAME"]}({gen_type_name(switch_field["TYPE"])} v);
''')

	if not typedef_has_property(t, "nopush"):
		out('''
	x_ndr_off_t ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
		if len(buffers): out('''
	x_ndr_off_t ndr_buffers(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	if not typedef_has_property(t, "nopull"):
		out('''
	x_ndr_off_t ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
''')
		if len(buffers): out('''
	x_ndr_off_t ndr_buffers(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level);
''')
	if not typedef_has_property(t, "noprint"): # TODO
		#ndr_output_type = "x_ndr_output_type_default"
		ndr_output_type = "x_ndr_output_type_struct"
		out('''
	void ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	x_length_last = None
	x_length_types = []
	for elem in typedef_get_elements(t):
		elem_check_properties(elem, F_STRUCT)
		if elem_is_property_of(elem, t, "array_len") or elem_has_property(elem, 'value', 'x_ignored', 'x_size', 'x_elem_size', 'x_group_start', 'x_group_end'):
			continue
		x_length = elem_get_property(elem, "x_length")
		if x_length is not None:
			x_length_type = elem_get_type_name(elem)
			assert x_length_type in [ 'uint16', 'uint32' ]
			if x_length_last is None:
				x_length_last = x_length
				x_length_types = [ x_length_type ]
				continue
			else:
				assert x_length_last == x_length
				assert len(x_length_types) == 1 # only allow 2
				x_length_types.append(x_length_type)
			continue

		if x_length_last is not None:
			assert x_length_last == elem["NAME"]
		
		output_header_element(out, elem, t, iface, x_length_types)
		x_length_last = None
		x_length_types = []
		
	out(f'''
}} {typedef_tostring_properties(t)};

template <> struct x_ndr_traits_t<{tname}> {{
	using has_buffers = std::{"true" if len(buffers) else "false"}_type;
	using ndr_type = x_ndr_type_struct;
''')
	out('};')


def output_ndrcxx_struct_scalars(idl_tbl, idl, t, name, func, alignment, union_fields, out):
	elems = typedef_get_elements(t)

	out(f'''
	X_NDR_HEADER_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);
	x_ndr_off_t __base = __bpos; (void)__base;
''')
	
	for eidx, elem in enumerate(elems):
		"""
		if func == 'pull':
			pull_value = get_property(elem, 'x_pull_value')
			if pull_value is not None:
				if elem_is_switch(elem, union_fields):
					out(f'''
	set_{elem["NAME"]}({pull_value});''')
				else:
					out(f'''
	{elem["NAME"]} = {pull_value};''')
				continue
				
		if elem_get_one_property(elem, 'x_relative', 'ignore'):
			continue
		"""

		ndr_flags = elem_get_ndr_flags(elem)
		elem_type, elem_name = elem["TYPE"], elem["NAME"]
		switch_is = elem_get_property(elem, 'switch_is', "X_NDR_SWITCH_NONE")
		assert isinstance(switch_is, str)

		if elem_has_property(elem, 'x_elem_size'):
			if func == 'pull': out(f'''
	{elem_type} __tmp_{elem_name};
	X_NDR_SCALARS(__tmp_{elem_name}, __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE);''')
			else: out(f'''
	x_ndr_off_t __tmp_{elem_name} = __bpos;
	X_NDR_SKIP({elem["TYPE"]}, __ndr, __bpos, __epos, {ndr_flags});''')
			continue

		me = elem_is_property_of(elem, t, 'size_is')
		if me:
			if func == 'pull': out(f'''
	{elem_type} __tmp_{elem_name};
	X_NDR_SCALARS(__tmp_{elem_name}, __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE);''')
			else: out(f'''
	{elem_type} __tmp_{elem_name} = get_size({me["NAME"]});
	X_NDR_SCALARS(__tmp_{elem_name}, __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE);''')
			continue

		if elem_get_property(elem, 'x_size') is not None:
			if func == 'pull': out(f'''
        {elem_type} {elem_name};
	X_NDR_SCALARS({elem_name}, __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE);
	__epos = X_NDR_CHECK_POS(__base + {elem_name}, __bpos, __epos);''')
			else: out(f'''
	x_ndr_off_t __tmp_{elem_name} = __bpos;
	X_NDR_SKIP({elem_type}, __ndr, __bpos, __epos, {ndr_flags});''')
			continue

		elem_size = elem_is_property_of(elem, t, "x_elem_size")
		epos = '__epos'
		if elem_size:
			if func == "pull":
				epos = f'X_NDR_CHECK_POS(__bpos + __tmp_{elem_size["NAME"]}, __bpos, __epos)'
			else: out(f'''
	x_ndr_off_t __tmp_pos_{elem_name} == __bpos;''')
		value = elem_get_property(elem, 'value')
		if value is not None:
			if func == 'push':
				out(f'''
	{field_type(elem)} {elem_name}{{{value}}};''')
			elif func == 'pull':
				out(f'''
	{field_type(elem)} {elem_name};''')
			
		if elem_get_property(elem, 'x_ignored') is not None:
			assert value is None
			out(f'''
	{field_type(elem)} {elem_name};
''')

		melem = elem_is_property_of(elem, t, "array_len")
		if melem is not None:
			prop_range = get_property(elem, "range")
			if prop_range is not None:
				prop_range = prop_range.split(',')
				assert len(prop_range) == 2
				prop_range = [ int(x, 0) for x in prop_range ]
			if func == "push":
				if prop_range:
					out(f'''
	X_NDR_CHECK_RANGE(get_size({melem_name}), {prop_range[0]}, {prop_range[1]});
''')
				out(f'''
	{elem["TYPE"]} {elem_name}(get_size({melem["NAME"]}));
	X_NDR_SCALARS({elem_name}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});
''')
			elif func == "pull":
				out(f'''
	{etname} {elem_name};
	X_NDR_SCALARS({elem_name}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});
''')
				if prop_range: out(f'''
	X_NDR_CHECK_RANGE({elem_name}, {prop_range[0]}, {prop_range[1]});
	{melem_name}.resize({elem["NAME"]});
''')
				if False: out(f'''
	{melem_name}.resize({elem["NAME"]});
''')
		elif func == "pull" and 'ARRAY_LEN' in elem:
			array_elem = elem_get_array_elem(elem, t)
			if array_elem is not None:
				out(f'''
	X_NDR_SCALARS({elem_name}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});''')
			else:
				out(f'''
	X_NDR_SCALARS({elem['NAME']}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});''')
		elif False and 'ARRAY_LEN' in elem and get_property(elem, "charset") is None:
			out(f'''
	ret += X_NDR_DO(ndr, {elem['NAME']}, {extra_flags}, {switch_is});
''')
		else:
			if func == "pull" and elem_is_switch(elem, union_fields):
				out(f'''
	X_NDR_SWITCH({etname}, {elem['NAME']}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});
''')
			else:
				elem_size_is = elem_get_property(elem, "size_is")
				if elem_size_is and func == "pull":
					out(f'''
	X_NDR_ARRAY({elem['NAME']}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is}, __tmp_{elem_size_is});''')
				else:
					out(f'''
	X_NDR_SCALARS({elem['NAME']}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});''')

		if elem_size and func == "push":
			out(f'''
	X_NDR_SCALARS({elem_size["TYPE"]}(__bpos - __tmp_pos_{elem_name}), __ndr, __bpos, __epos, {elem_get_ndr_flags(elem_size)}, X_NDR_SWITCH_NONE);''')

	out(f'''
	X_NDR_TRAILER_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);
''')

	if True:
		for idx, elem in enumerate(elems):
			if not elem_has_property(elem, 'x_size'):
				continue
			assert elem['TYPE'] in ['uint16', 'uint32']
			if func == 'push':
				out(f'''
	X_NDR_SCALARS({elem['TYPE']}(__bpos - __base), __ndr, __tmp_{idx}, __epos, {elem_get_ndr_flags(elem)}, X_NDR_SWITCH_NONE);
''')

def output_ndrcxx_struct_buffers(idl_tbl, idl, t, name, func, alignment, buffers, union_fields, out):
	for elem in buffers: out(f'''
	X_NDR_BUFFERS({elem["NAME"]}, __ndr, __bpos, __epos, __flags, X_NDR_SWITCH_NONE);
''')

def output_ndrcxx_STRUCT(idl_tbl, idl, t, out):
	ndr_name = t["NAME"]
	flag = typedef_get_property(t, 'flag')
	alignment = typedef_get_align(idl_tbl, t)
	union_fields = typedef_get_nontrivial_union_fields(t, idl, idl_tbl)
	if any([len(u) > 0 for _, u in union_fields]):
		output_struct_functions(idl, ndr_name, union_fields, out)

	buffers = typedef_get_buffers(t, idl_tbl)
	if not typedef_get_property(t, "nopush"):
		out(f'''

x_ndr_off_t {ndr_name}::ndr_scalars(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
		output_ndrcxx_struct_scalars(idl_tbl, idl, t, ndr_name, 'push', alignment, union_fields, out)
		out(f'''
	return __bpos;
}}

''')

		if len(buffers):
			out(f'''
x_ndr_off_t {ndr_name}::ndr_buffers(x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
			output_ndrcxx_struct_buffers(idl_tbl, idl, t, ndr_name, 'push', alignment, buffers, union_fields, out)
			out(f'''
	return __bpos;
}}

''')

	if not typedef_get_property(t, "nopull"):
		out(f'''

x_ndr_off_t {ndr_name}::ndr_scalars(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{{
''')
		if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
		output_ndrcxx_struct_scalars(idl_tbl, idl, t, ndr_name, 'pull', alignment, union_fields, out)
		out(f'''
	return __bpos;
}}''')
		if len(buffers):
			out(f'''
x_ndr_off_t {ndr_name}::ndr_buffers(x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level)
{{
''')
			output_ndrcxx_struct_buffers(idl_tbl, idl, t, ndr_name, 'pull', alignment, buffers, union_fields, out)
			out(f'''
	return __bpos;
}}''')

	if not typedef_has_property(t, "noprint"):
		out(f'''

void {ndr_name}::ostr(x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const
{{''')
		if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
		out(f'''
	__ndr << enter;''');
		for elem in typedef_get_elements(t):
			if elem_has_property(elem, 'x_length', 'x_elem_size', 'x_size', 'x_offset', 'value', 'x_ignored', 'noprint'):
				continue
			if elem_is_property_of(elem, t, "size_is", "length_is", "array_len"):
				continue
			ndr_flags = elem_get_ndr_flags(elem)
			switch_is = get_property(elem, 'switch_is', "X_NDR_SWITCH_NONE")
			out(f'''
	X_NDR_OSTR_NEXT({elem["NAME"]}, __ndr, {ndr_flags}, {switch_is});''')
		out(f'''
	__ndr << leave;
}}


''')

def output_ndrcxx_union_element(idl_tbl, idl, t, name, func, out):
	alignment = get_align(idl_tbl, t)
	out(f'''
	X_NDR_UNION_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);
	switch (__level) {{
''')
	for elem in typedef_get_elements(t):
		etname = gen_type_name(elem['TYPE'])
		out(f'''
		{get_case_str(elem)}: {{''')
		if elem['NAME'] != '': out(f'''
			X_NDR_SCALARS({elem['NAME']}, __ndr, __bpos, __epos, __flags, X_NDR_SWITCH_NONE);''')
		out(f'''
		}} break;
''')
	out('''
	}
''')


def output_header_INTERFACE(idl_tbl, idl, iface, out):
	out(f'''
#ifndef _HEADER_{iface["NAME"]}
#define _HEADER_{iface["NAME"]}
''')

	for t in iface['DATA']:
		if t['TYPE'] == 'TYPEDEF':
			"""
			if t['NAME'] in known_structs:
				continue
			"""
			realtype = typedef_get_realtype(t)
			if realtype == 'STRUCT':
				output_header_STRUCT(out, t, iface, idl, idl_tbl)
			elif realtype == 'UNION':
				output_header_UNION(out, t, iface, idl, idl_tbl)
			elif realtype == 'ENUM':
				output_header_ENUM(out, t, iface, idl, idl_tbl)
			elif realtype == 'BITMAP':
				output_header_BITMAP(out, t, iface, idl, idl_tbl)
			else:
				error(f'''Unknown typedef "{realtype}" at {t["FILE"]}:{t["LINE"]}''')
				assert False
		elif t['TYPE'] == 'CONST':
			dtype = gen_type_name(t['DTYPE'])
			assert const_get_pointers(t) == 0
			out(f'''
const {dtype}{'*' if t['POINTERS'] == 1 else ''} {t['NAME']} = {t['VALUE']};
''')
		elif t["TYPE"] in [ "FUNCTION" ]:
			output_header_FUNCTION(out, idl, t);
		else:
			error(f'''Unknown type "{t['TYPE']}" at {t['FILE']}:{t['LINE']}''')
			assert False

	out(f'''

#endif /* _HEADER_{iface['NAME']} */\n''')

def output_ndrcxx_INTERFACE(idl_tbl, idl, iface, out):
	helper = get_property(iface, "helper")
	if helper is not None:
		out(f'''
#include {helper}
''')
	out(f'''

namespace idl {{

// namespace {iface["NAME"]} {{
''')
	for t in iface['DATA']:
		if t['TYPE'] == 'TYPEDEF':
			"""
			if t['NAME'] in known_structs:
				continue
			"""
			realtype = typedef_get_realtype(t)
			if realtype == 'STRUCT':
				output_ndrcxx_STRUCT(idl_tbl, idl, t, out)
			elif realtype == 'UNION':
				output_ndrcxx_UNION(idl_tbl, idl, t, out)
			elif realtype == 'ENUM':
				output_ndrcxx_ENUM(idl_tbl, idl, t, out)
			elif realtype == 'BITMAP':
				output_ndrcxx_BITMAP(idl_tbl, idl, t, out)
			else:
				assert False
		elif t['TYPE'] in [ "FUNCTION" ]:
			pass
			# TODO output_ndrcxx_FUNCTION(out, idl, t)
		elif t['TYPE'] in [ "CONST", "FUNCTION" ]:
			pass
		else:
			assert False

	out(f'''

// }}
}}
''')

def process_header(idl_tbl, idl, name, out, outdir):
	ifacename = None
	for o in idl:
		if o['TYPE'] == "INTERFACE":
			ifacename = o['NAME']
			break

	out(f'''
/* header auto-generated by gen-rpc */
#ifndef __GEN_RPC__HEADER_{ifacename}
#define __GEN_RPC__HEADER_{ifacename}
#include "include/librpc/ndr_nxsmb.hxx"

''')

	for o in idl:
		if o['TYPE'] == "IMPORT": output_header_IMPORT(o, out)
		if o['TYPE'] == "INCLUDE": output_header_INCLUDE(o, out)

	out(f'''
namespace idl {{
''')

	for o in idl:
		if o['TYPE'] == "CPP_QUOTE": output_header_QUOTE(o, out)
		if o['TYPE'] == "INTERFACE": output_header_INTERFACE(idl_tbl, idl, o, out)
			
	out(f'''

}} /* namespace idl */

#endif /* __GEN_RPC__HEADER_{ifacename} */

''')


def process_ndrcxx(idl_tbl, idl, name, out, outdir):
	out(f'''
/* ndr parser auto-generated by pidl */
	
#include "include/librpc/{name}.hxx"

''')

	for o in idl:
		if o['TYPE'] == "INTERFACE": output_ndrcxx_INTERFACE(idl_tbl, idl, o, out)



def process_depend(idl_tbl, idl, name, out, outdir):
	for o in idl:
		if o['TYPE'] != "IMPORT":
			continue
		for path in o['PATHS']:
			import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
			out(f'''
{outdir}/{name}.idl.hxx: {outdir}/{import_name}.json
{outdir}/{name}.idl.ndr.cxx: include/librpc/{import_name}.hxx
{outdir}/{name}.idl.ndr.o: include/librpc/ndr.hxx
{outdir}/{name}.idl.ndr.o: include/librpc/ndr_nxsmb.hxx
''')

def load_idl_with_import(infp):
	imports = []
	idl = json.load(infp)
	for o in idl:
		if o['TYPE'] != "IMPORT":
			continue
		for path in o['PATHS']:
			import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
			imports.append(import_name)
	return idl, imports

def load_all(infp, name, path, recur):
	idl_tbl = {}
	idl, imports = load_idl_with_import(infp)
	idl_tbl[name] = idl

	while recur and imports:
		name = imports.pop()
		if name in idl_tbl:
			continue
		filename = os.path.join(path, '.'.join([name, "json"]))
		with open(filename, 'r') as fp:
			new_idl, new_imports = load_idl_with_import(fp)
			idl_tbl[name] = new_idl
			imports += new_imports
	return idl, idl_tbl

def process(infp, name, args):
	idl, idl_tbl = load_all(infp, name, args.outputdir, args.header or args.ndrcxx)

	def output(func, ext):
		if name is None:
			outfp = sys.stdout
		else:
			tmpfix = "tmp"
			filename = os.path.join(args.outputdir, '.'.join([name, ext, tmpfix]))
			outfp = open(filename, 'w')

		try:
			out = OStream(outfp)
			func(idl_tbl, idl, name, out, args.outputdir)
		except:
			if name is not None:
				outfp.close()
				os.remove(filename)
			raise
		if name is not None:
			os.rename(filename, os.path.join(args.outputdir, '.'.join([name, ext])))
	
	if args.depend: output(process_depend, 'd')
	if args.header: output(process_header, 'idl.hxx')
	if args.ndrcxx: output(process_ndrcxx, 'idl.ndr.cxx')
	if args.python: output(process_python, 'py.cxx')
			
	
def main():
	parser = argparse.ArgumentParser()
	parser.add_argument("-d", "--debug", action="store_true", help="output debug info")
	parser.add_argument("--depend", action="store_true", help="output dependency")
	parser.add_argument("--header", action="store_true", help="output header")
	parser.add_argument("--ndrcxx", action="store_true", help="output ndr")
	parser.add_argument("--python", action="store_true", help="output ndr")
	parser.add_argument("--outputdir", default=".", help="output directory")
	parser.add_argument("input", nargs='*', help="Input IDL json files")

	args = parser.parse_args()
	args.outputdir = args.outputdir.rstrip('/')
	if args.debug:
		global DBG
		print(args, file=sys.stderr)
		DBG = _dbg_stderr

	if len(args.input) == 0:
		process(sys.stdin, None, args)
	else:
		for f in args.input:
			with open(f, 'r') as fp:
				name = os.path.splitext(os.path.basename(f))[0]
				process(fp, name, args)

	return 0

if __name__ == "__main__": sys.exit(main())

