#!/usr/bin/env python3

from __future__ import print_function
import os, sys
from io import StringIO
import re, argparse, json

class OStream(object):
	def __init__(self, fp):
		self.fp = fp
	def write(self, s):
		self.fp.write(s)
	def __call__(self, s=''):
		try:
			if s[0] == '\n':
				s = s[1:]
		except:
			pass

		self.fp.write(s)
		try:
			if s[-1] == '\n':
				return
		except:
			pass
		self.fp.write('\n')

def _dbg_none(*args):
	pass

def _dbg_stderr(*args):
	print("DBG:", *args, file=sys.stderr)

DBG = _dbg_none

def warn(msg):
	print("Warning:", msg, file = sys.stderr)

def error(msg):
	print("Error:", msg, file = sys.stderr)


def tostring_properties__(data):
	if 'PROPERTIES' in data:
		ret = []
		for key, val in data['PROPERTIES'].items():
			if val != '1':
				ret.append(f'{key}({val})')
			else:
				ret.append(key)
		return '/* [' + ', '.join(ret) + '] */'
	else:
		return ''

def elem_tostring_properties(e):
	return tostring_properties__(e)

def typedef_tostring_properties(t):
	return tostring_properties__(t['DATA'])

def elem_get_type_name(t):
	return t["TYPE"]

def elem_get_ndr_flags(elem):
	ndr_flags = elem_get_property(elem, "flag")
	if ndr_flags is not None:
		return f'x_ndr_set_flags(__flags, {ndr_flags})'
	else:
		return '__flags'

def elem_get_pointer_type(elem, iface):
	for t in [ "unique", "relative" ]:
		try:
			v = elem["PROPERTIES"][t]
		except:
			continue
		assert v == "1"
		return t
	try:
		return iface['pointer_default']
	except:
		return "unique"

F_STRUCT = 0x1
F_UNION  = 0x2
know_properties = {
	'case': F_UNION,
	'default': F_UNION,
	'flag': F_STRUCT | F_UNION,
	'range': F_STRUCT,
	'value': F_STRUCT | F_UNION,
	'charset': F_STRUCT | F_UNION,
	'switch_is': F_STRUCT,
	'switch_type': F_STRUCT,
	'size_is': F_STRUCT,
	'in': F_STRUCT, # TODO
	'unique': F_STRUCT, # TODO
	'length_is': F_STRUCT, # TODO
	'noprint': F_STRUCT | F_UNION, # TODO
	#'ignore': F_STRUCT | F_UNION, # TODO
	'x_ignored': F_STRUCT,
	'string': F_STRUCT | F_UNION, # TODO
	'compression': F_STRUCT | F_UNION, # TODO
	'subcontext': F_STRUCT | F_UNION, # TODO rewrite
	'subcontext_size': F_STRUCT | F_UNION, # TODO rewrite
	'relative': F_STRUCT | F_UNION, # TODO rewrite
	'relative_short': F_STRUCT | F_UNION, # TODO rewrite
	'ref': F_STRUCT | F_UNION, # TODO rewrite
	'x_length': F_STRUCT,
	#'x_offset': F_STRUCT,
	'x_skip': F_STRUCT,
	'x_size': F_STRUCT,
	#'x_with_size': F_STRUCT,
	'x_relative': F_STRUCT,
	'x_group_start': F_STRUCT,
	'x_group_end': F_STRUCT,
	'x_pull_value': F_STRUCT,
}

def elem_check_properties(elem, flag):
	if not 'PROPERTIES' in elem:
		return
	for name, value in elem['PROPERTIES'].items():
		try:
			flags = know_properties[name]
			if (flag & flags) == 0:
				error(f'at {elem["FILE"]}:{elem["LINE"]} Property {name} not support {flag}')
				assert False
		except KeyError:
			error(f"Unknown property {name}.")
			assert False

def elem_has_property(elem, *args):
	try:
		prop = elem['PROPERTIES']
	except:
		return False
	for arg in args:
		if arg in prop:
			return True
	return False

def get_property(t, prop, default = None):
	try:
		return t['PROPERTIES'][prop]
	except KeyError:
		return default

def elem_get_property(t, prop, default = None):
	return get_property(t, prop, default)

def typedef_get_property(t, prop, default = None):
	return get_property(t['DATA'], prop, default)

def elem_is_property_of(elem, t, *args):
	for me in typedef_get_elements(t):
		for prop in args:
			try:
				if elem["NAME"] == elem_get_property(me, prop):
					return me
			except:
				pass
	return None

def elem_get_array_len(elem):
	try:
		array_len = elem['ARRAY_LEN']
		if len(array_len) == 0:
			return None
		assert len(array_len) == 1
		return array_len[0]
	except KeyError:
		return None

def elem_get_pointers(elem):
	try:
		v = elem['POINTERS']
	except KeyError:
		return 0
	assert v in [0, 1]
	return v

def elem_is_switch(f, union_fields):
	for uf, unions in union_fields:
		if uf["NAME"] == f["NAME"]:
			return len(unions) > 0
	else:
		return False

# TODO
def has_property(t, prop):
	v = get_property(t, prop)
	if v is None:
		return False
	assert v == '1'
	return True

def const_get_pointers(elem):
	try:
		v = elem['POINTERS']
	except KeyError:
		return 0
	assert v == 0
	return v

def typedef_has_property(t, prop):
	return has_property(t['DATA'], prop);

def typedef_get_elements(t):
	assert t['TYPE'] == 'TYPEDEF'
	try:
		return t['DATA']['ELEMENTS']
	except:
		return []

def typedef_get_realtype(t):
	return t['DATA']['TYPE']

known_simple_types = {
	# name, align, is_trival, has_buffer
        'EMPTY': [ 0, True, False],
        'void': [0, True, False],
        'char': [1, True, False],
        'int8': [1, True, False],
        'uint8': [1, True, False],
        'int16': [2, True, False],
        'uint16': [2, True, False],
        'int1632': [3, True, False],
        'uint1632': [3, True, False],
        'int': [4, True, False], # int32
        'int32': [4, True, False],
        'long': [4, True, False], # uint32
        'DWORD': [4, True, False],
        'WORD': [2, True, False],
        'uint32': [4, True, False],
        'mode_t': [4, True, False], # uint32
        'boolean8': [1, True, False],
        'boolean32': [4, True, False], # uint32
        'int3264': [5, True, False],
        'uint3264': [5, True, False],
        'uint64': [8, True, False],
        'double': [8, True, False],
        'pointer': [8, True, False],
        'dlong': [4, True, False],
        'udlong': [4, True, False],
        'udlongr': [4, True, False],
        'hyper': [4, True, False],
        'NTSTATUS': [4, True, False],
}

def find_type(idl, tname):
	for o in idl:
		if o['TYPE'] != "INTERFACE":
			continue
		for t in o['DATA']:
			if t['TYPE'] == "TYPEDEF" and t['NAME'] == tname:
				return t
	return None

def find_type_idl_tbl(idl_tbl, tname):
	for _, idl in idl_tbl.items():
		t = find_type(idl, tname)
		if t is not None:
			return t
	return None

def elem_has_buffers(elem, idl_tbl):
	def has_buffers_2(t):
		for elem in typedef_get_elements(t):
			has_buffers = has_buffers_1(elem)
			if has_buffers:
				return True
		return False

	def has_buffers_1(elem):
		if elem_get_pointers(elem):
			'''
			subcontext = elem_get_property(elem, "subcontext")
			if subcontext == "0xFFFFFC01":
				continue
			elif subcontext is not None:
				assert False # TODO
			'''
			return True
		et_name = elem['TYPE']
		try:
			return known_simple_types[et_name][2]
		except KeyError:
			pass
		et = find_type_idl_tbl(idl_tbl, et_name)
		assert et is not None, f"Cannot find type for {et_name}"

		if "has_buffers" in et:
			return et["has_buffers"]
		realtype = typedef_get_realtype(et)
		if realtype in [ "ENUM", "BITMAP" ]:
			return False
		elif realtype in [ "STRUCT", "UNION" ]:
			has_buffers = has_buffers_2(et)
			et["has_buffers"] = has_buffers
			return has_buffers
		else:
			assert False
	return has_buffers_1(elem)

def get_array_len(elem):
	try:
		array_len = elem['ARRAY_LEN']
		if len(array_len) == 0:
			return None
		assert len(array_len) == 1
		return array_len[0]
	except KeyError:
		return None

def elem_is_array_len_of(elem, st):
	for elem2 in typedef_get_elements(st):
		array_len = get_array_len(elem2)
		if elem['NAME'] == array_len:
			return elem2
	return None

def typedef_get_buffers(typedef, idl_tbl):
	realtype = typedef_get_realtype(typedef)
	if realtype in [ "ENUM", "BITMAP" ]:
		assert False
	elif realtype in [ "STRUCT", "UNION" ]:
		return [ elem for elem in typedef_get_elements(typedef) if elem_has_buffers(elem, idl_tbl) ]
	else:
		assert False

# samba/pidl/lib/Parse/Pidl/NDR.pm align_type
def typedef_get_align(typedef, idl_tbl):
	class NotFound(Exception):
		def __init__(self, elem):
			self.elem = elem

	def get_elem_align(elem):
		#assert not has_property(elem, "subcontext"), "TODO"
		#assert not has_property(elem, "transmit_as"), "TODO"
		et_name = elem['TYPE']
		try:
			return known_simple_types[et_name][0]
		except KeyError:
			pass
		et = find_type_idl_tbl(idl_tbl, elem['TYPE'])
		if et is None:
			raise NotFound(elem)

		return get_align_1(et)

	def find_largest_alignment(elems):
		align = 1
		for elem in elems:
			if elem_get_pointers(elem):
				# this is a hack for NDR64
				# the NDR layer translates this into
				# an alignment of 4 for NDR and 8 for NDR64
				a = 5
			else:
				a = get_elem_align(elem)
			if align < a:
				align = a
		return align

	def get_align_2(t):
		assert t["TYPE"] == "TYPEDEF"
		realtype = typedef_get_realtype(t)

		if realtype in [ "STRUCT", "UNION" ]:
			elements = typedef_get_elements(t)
			return find_largest_alignment(elements) if len(elements) else 4
		elif realtype == "ENUM":
			_, ftype = map_enum_type(t)
			return known_simple_types[ftype][0]
		elif realtype == "BITMAP":
			_, ftype = map_bitmap_type(t)
			return known_simple_types[ftype][0]
		else:
			assert False
	def get_align_1(t):
		try:
			return t['x_align']
		except:
			pass
		align = get_align_2(t)
		DBG(f'get_align({t["NAME"]})={align}')
		t['x_align'] = align
		return align
	try:
		return get_align_1(typedef)
	except NotFound as e:
		error(f'''Cannot find type "{e.elem['TYPE']}" at {e.elem['FILE']}:{e.elem['LINE']}''')
		raise

def typedef_is_trivial(idl_tbl, typedef):
	def is_trivial_2(t):
		for elem in typedef_get_elements(t):
			if elem_get_pointers(elem):
				return False
			et_name = elem['TYPE']
			try:
				if not known_simple_types[et_name][1]:
					return False
				continue
			except KeyError:
				pass
			et = find_type_idl_tbl(idl_tbl, et_name)
			assert et is not None
			trivial = is_trivial_1(et)
			if not trivial:
				return False
		return True
	def is_trivial_1(t):
		if "is_trivial" in t:
			return t["is_trivial"]
		realtype = typedef_get_realtype(t)
		if realtype in [ "ENUM", "BITMAP" ]:
			return True
		elif realtype in [ "STRUCT", "UNION" ]:
			trivial = is_trivial_2(t)
			t["is_trivial"] = trivial
			return trivial
		else:
			assert False
	return is_trivial_1(typedef)

def typedef_get_nontrivial_union_fields(t, idl, idl_tbl):
	# TODO
	return []

def elem_get_case_str(elem):
	case_value = get_property(elem, 'case')
	if case_value is not None:
		return f'case {case_value}'
	else:
		assert has_property(elem, 'default')
		return 'default'


def output_header_element(out, elem, t, iface, x_length_types):
	et = elem_get_type_name(elem)
	array_len = elem_get_array_len(elem)
	charset = elem_get_property(elem, "charset")
	string = elem_get_property(elem, "string")
	x_length = elem_get_property(elem, "x_length")
	if elem_has_property(elem, "size_is", "length_is"):
		assert elem_get_pointers(elem) == 1
		
	if elem_is_property_of(elem, t, "size_is", "length_is"):
		return

	if charset == "UTF16" and string == "1":
		assert array_len is None
		assert elem['TYPE'] == "uint16"
		assert elem_get_pointers(elem) != 0
		et = 'std::u16string'
	elif array_len is not None:
		assert elem_get_pointers(elem) == 0
		assert charset is None or (charset in ["DOS", "UTF8", "UTF16", "UNIX"])
		try:
			array_len = int(array_len)
			et = f'std::array<{et}, {array_len}>'
		except:
			if False and charset is not None: # TODO
				array_elem = typedef_find_elem(t, array_len)
				value = elem_get_property(array_elem, "value")
				prop, elem_name = re.search('^(.*)\((.*)\)$', value).groups()
				assert elem_name == elem['NAME']
				if prop == 'strlen_m_term_null':
					assert elem['TYPE'] == 'uint8'
					field = f'NDR_t_DOS_strlen_m_term_null {elem["NAME"]}'
				else:
					# TODO assert prop == 'strlen_m_term_null'
					field = f"{et} {elem['NAME']}"
			elif array_len == '*':
				et = f'x_ndr_vector_t<{et}>'
			else:
				et = f'std::vector<{et}>'
	else:
		assert charset is None or (charset in ["DOS", "UTF8", "UTF16"])

	if elem_get_pointers(elem) == 1:
		size_is = elem_get_property(elem, "size_is")
		length_is = elem_get_property(elem, "length_is")

		if length_is is not None:
			assert len(x_length_types) == 0
			assert size_is is not None
			et = f'shared_vector<{et}>'
		elif size_is is not None:
			assert len(x_length_types) == 0
			et = f'shared_vector<{et}>'
		else:
			et = f'std::shared_ptr<{et}>'

	if elem_get_property(elem, "subcontext") == "0xFFFFFC01":
		et = f'x_ndr_subndr_t<{et}>'

	out(f'''
	{et} {elem["NAME"]};{elem_tostring_properties(elem)}
''')

def output_header_STRUCT(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	union_fields = typedef_get_nontrivial_union_fields(t, idl, idl_tbl)
	buffers = typedef_get_buffers(t, idl_tbl)

	out(f'''

struct {tname} {{
''')
	if any([len(u) > 0 for _, u in union_fields]):
		out(f'''
	{tname}();
	~{tname}();
	{tname}(const {tname}& other);
	{tname} &operator=(const {tname}& other);
''')
		for switch_field, _ in union_fields:
			if elem_has_property(switch_field, 'value'):
				continue
			out(f'''
	void set_{switch_field["NAME"]}({gen_type_name(switch_field["TYPE"])} v);
''')

	x_length_last = None
	x_length_types = []
	for elem in typedef_get_elements(t):
		elem_check_properties(elem, F_STRUCT)
		if elem_is_array_len_of(elem, t) or elem_has_property(elem, 'value', 'x_ignored', 'x_size', 'x_elem_size', 'x_group_start', 'x_group_end'):
			continue
		x_length = elem_get_property(elem, "x_length")
		if x_length is not None:
			x_length_type = elem_get_type_name(elem)
			assert x_length_type in [ 'uint16', 'uint32' ]
			if x_length_last is None:
				x_length_last = x_length
				x_length_types = [ x_length_type ]
				continue
			else:
				assert x_length_last == x_length
				assert len(x_length_types) == 1 # only allow 2
				x_length_types.append(x_length_type)
			continue

		if x_length_last is not None:
			assert x_length_last == elem["NAME"]
		
		output_header_element(out, elem, t, iface, x_length_types)
		x_length_last = None
		x_length_types = []
		
	out(f'''
}} {typedef_tostring_properties(t)};

template <> struct ndr_traits_t<{tname}> {{
	using has_buffers = std::{"true" if len(buffers) else "false"}_type;
	using ndr_type = x_ndr_type_struct;

	x_ndr_off_t ndr_scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	if len(buffers): out(f'''
	x_ndr_off_t ndr_buffers(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_buffers({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	out(f'''
	void ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};


''')


def elem_get_switch_is(elem):
	switch_is = elem_get_property(elem, 'switch_is')
	if switch_is is None:
		return "X_NDR_SWITCH_NONE"
	else:
		assert isinstance(switch_is, str)
		# TODO
		return f'__val.{switch_is}'

def output_ndrcxx_struct_scalars(out, func, alignment, union_fields, t, iface, idl, idl_tbl):
	elems = typedef_get_elements(t)

	out(f'''
	X_NDR_HEADER_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);
''')
	for elem in elems:
		if elem_get_property(elem, 'x_size') is not None:
			out(f'''
	x_ndr_off_t __base = __bpos;
''')
			break

	for eidx, elem in enumerate(elems):
		ndr_flags = elem_get_ndr_flags(elem)
		elem_type, elem_name = elem["TYPE"], elem["NAME"]
		switch_is = elem_get_switch_is(elem)

		if elem_get_pointers(elem):
			pointer_type = elem_get_pointer_type(elem, iface)
			if pointer_type == "relative":
				out(f'''
	X_NDR_SAVE_POS(uint32, __ndr, __bpos, __epos, {ndr_flags});
''')
			elif pointer_type == "unique":
				out(f'''
	X_NDR_SCALARS_UNIQUE_PTR(__val.{elem["NAME"]}, __ndr, __bpos, __epos, {ndr_flags});
''')
			else:
				assert False
			continue
				
		if elem_has_property(elem, 'x_elem_size'):
			if func == 'pull': out(f'''
	{elem_type} __tmp_{elem_name};
	X_NDR_SCALARS(ndr_traits<{elem_type}>(), __tmp_{elem_name}, __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE);''')
			else: out(f'''
	x_ndr_off_t __tmp_{elem_name} = __bpos;
	X_NDR_SKIP({elem["TYPE"]}, __ndr, __bpos, __epos, {ndr_flags});''')
			continue

		me = elem_is_property_of(elem, t, 'size_is')
		if me:
			if func == 'pull': out(f'''
	{elem_type} __tmp_{elem_name};
	X_NDR_SCALARS_SIMPLE(__tmp_{elem_name}, __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE);''')
			else: out(f'''
	{elem_type} __tmp_{elem_name} = get_size({me["NAME"]});
	X_NDR_SCALARS_SIMPLE(__tmp_{elem_name}, __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE);''')
			continue

		if elem_get_property(elem, 'x_size') is not None:
			if func == 'pull': out(f'''
        {elem_type} {elem_name};
	X_NDR_SCALARS_SIMPLE({elem_name}, __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE);
	__epos = X_NDR_CHECK_POS(__base + {elem_name}, __bpos, __epos);''')
			else: out(f'''
	x_ndr_off_t __pos_{elem_name} = __bpos;
	X_NDR_SCALARS_SIMPLE({elem_type}(), __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE);''')
			continue

		elem_size = elem_is_property_of(elem, t, "x_elem_size")
		epos = '__epos'
		if elem_size:
			if func == "pull":
				epos = f'X_NDR_CHECK_POS(__bpos + __tmp_{elem_size["NAME"]}, __bpos, __epos)'
			else: out(f'''
	x_ndr_off_t __tmp_pos_{elem_name} == __bpos;''')
		value = elem_get_property(elem, 'value')
		if value is not None:
			if func == 'push':
				out(f'''
	{field_type(elem)} {elem_name}{{{value}}};''')
			elif func == 'pull':
				out(f'''
	{field_type(elem)} {elem_name};''')
			
		if elem_get_property(elem, 'x_ignored') is not None:
			assert value is None
			out(f'''
	{field_type(elem)} {elem_name};
''')

		melem = elem_is_array_len_of(elem, t)
		if melem is not None:
			prop_range = get_property(elem, "range")
			if prop_range is not None:
				prop_range = prop_range.split(',')
				assert len(prop_range) == 2
				prop_range = [ int(x, 0) for x in prop_range ]
			if func == "push":
				if prop_range:
					out(f'''
	X_NDR_CHECK_RANGE(__val.{melem["NAME"]}.size(), {prop_range[0]}, {prop_range[1]});
''')
				out(f'''
	X_NDR_SCALARS_SIMPLE({elem["TYPE"]}(__val.{melem["NAME"]}.size()), __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});
''')
			elif func == "pull":
				out(f'''
	{elem["TYPE"]} {elem_name};
	X_NDR_SCALARS_SIMPLE({elem_name}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});
''')
				if prop_range: out(f'''
	X_NDR_CHECK_RANGE({elem_name}, {prop_range[0]}, {prop_range[1]});
	__val.{melem["NAME"]}.resize({elem["NAME"]});
''')
		elif func == "pull" and 'ARRAY_LEN' in elem:
			out(f'''
	X_NDR_SCALARS_SIMPLE(__val.{elem_name}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});''')
		elif False and 'ARRAY_LEN' in elem and get_property(elem, "charset") is None:
			out(f'''
	ret += X_NDR_DO(ndr, {elem['NAME']}, {extra_flags}, {switch_is});
''')
		else:
			if func == "pull" and elem_is_switch(elem, union_fields):
				out(f'''
	X_NDR_SWITCH({etname}, {elem['NAME']}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});
''')
			else:
				elem_size_is = elem_get_property(elem, "size_is")
				if elem_size_is and func == "pull":
					out(f'''
	X_NDR_ARRAY(__val.{elem['NAME']}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is}, __tmp_{elem_size_is});''')
				else:
					out(f'''
	X_NDR_SCALARS_SIMPLE(__val.{elem['NAME']}, __ndr, __bpos, {epos}, {ndr_flags}, {switch_is});''')

		if elem_size and func == "push":
			out(f'''
	X_NDR_SCALARS_SIMPLE(__val.{elem_size["TYPE"]}(__bpos - __tmp_pos_{elem_name}), __ndr, __bpos, __epos, {elem_get_ndr_flags(elem_size)}, X_NDR_SWITCH_NONE);''')

	out(f'''
	X_NDR_TRAILER_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);
''')

	for idx, elem in enumerate(elems):
		if not elem_has_property(elem, 'x_size'):
			continue
		assert elem['TYPE'] in ['uint16', 'uint32']
		if func == 'push':
			out(f'''
	X_NDR_SCALARS_SIMPLE({elem['TYPE']}(__bpos - __base), __ndr, __pos_{elem["NAME"]}, __epos, {elem_get_ndr_flags(elem)}, X_NDR_SWITCH_NONE);
''')

def output_ndrcxx_struct_buffers(out, func, alignment, union_fields, buffers, t, iface, idl, idl_tbl):
	for elem in typedef_get_elements(t):
		if elem_is_property_of(elem, t, "size_is", "length_is"):
			out(f'''
	x_ndr_off_t __pos_{elem["NAME"]} = __ndr.load_pos();
''')
			continue

		if elem_has_buffers(elem, idl_tbl):
			# TODO should pointer, length also apply the flag?
			ndr_flags = elem_get_ndr_flags(elem)
			if not elem_get_pointers(elem):
				out(f'''
	X_NDR_BUFFERS_SIMPLE(__val.{elem["NAME"]}, __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE);
''')
				continue

			pointer_type = elem_get_pointer_type(elem, iface)
			if pointer_type == "relative":
				out(f'''
	x_ndr_off_t __pos_{elem["NAME"]} = __ndr.load_pos();
	X_NDR_BUFFERS_RELATIVE_PTR_SIMPLE(__val.{elem["NAME"]}, __ndr, __bpos, __epos, {ndr_flags}, X_NDR_SWITCH_NONE, uint32, __pos_{elem["NAME"]});
''')
			elif pointer_type == "unique":
				size_is = elem_get_property(elem, "size_is")
				length_is = elem_get_property(elem, "length_is")

				if length_is is not None:
					assert size_is is not None
					out(f'''
	X_NDR_BUFFERS_UNIQUE_PTR_LENGTH_IS_2(__val.{elem["NAME"]}, __ndr, __bpos, __epos, {ndr_flags});
''')
				elif size_is is not None:
					out(f'''
	X_NDR_BUFFERS_UNIQUE_PTR_SIZE_IS_1(__val.{elem["NAME"]}, __ndr, __bpos, __epos, {ndr_flags});
''')
				elif elem_get_property(elem, "string"):
					out(f'''
	X_NDR_BUFFERS_UNIQUE_PTR_LENGTH_0(__val.{elem["NAME"]}, __ndr, __bpos, __epos, {ndr_flags});
''')
				else:
					out(f'''
	X_NDR_BUFFERS_UNIQUE_PTR(__val.{elem["NAME"]}, __ndr, __bpos, __epos, {ndr_flags});
''')

def output_ndrcxx_STRUCT(out, t, iface, idl, idl_tbl):
	ndr_name = t["NAME"]
	flag = typedef_get_property(t, 'flag')
	alignment = typedef_get_align(t, idl_tbl)
	union_fields = typedef_get_nontrivial_union_fields(t, idl, idl_tbl)
	if any([len(u) > 0 for _, u in union_fields]):
		output_struct_functions(idl, ndr_name, union_fields, out)

	out(f'''

/***** Generated function for {ndr_name} *****/

''')

	buffers = typedef_get_buffers(t, idl_tbl)
	if not typedef_has_property(t, "nopush"):
		out(f'''
x_ndr_off_t ndr_traits_t<{ndr_name}>::ndr_scalars(const {ndr_name} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
		output_ndrcxx_struct_scalars(out, 'push', alignment, union_fields, t, iface, idl, idl_tbl)
		out(f'''
	return __bpos;
}}

''')

		if len(buffers):
			out(f'''
x_ndr_off_t ndr_traits_t<{ndr_name}>::ndr_buffers(const {ndr_name} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
			output_ndrcxx_struct_buffers(out, 'push', alignment, union_fields, buffers, t, iface, idl, idl_tbl)
			out(f'''
	return __bpos;
}}

''')

	if not typedef_has_property(t, "nopull"):
		out(f'''
x_ndr_off_t ndr_traits_t<{ndr_name}>::ndr_scalars({ndr_name} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
		output_ndrcxx_struct_scalars(out, 'pull', alignment, union_fields, t, iface, idl, idl_tbl)
		out(f'''
	return __bpos;
}}

''')
		if len(buffers):
			out(f'''
x_ndr_off_t ndr_traits_t<{ndr_name}>::ndr_buffers({ndr_name} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			output_ndrcxx_struct_buffers(out, 'pull', alignment, union_fields, buffers, t, iface, idl, idl_tbl)
			out(f'''
	return __bpos;
}}

''')

	if not typedef_has_property(t, "noprint"):
		out(f'''
void ndr_traits_t<{ndr_name}>::ostr(const {ndr_name} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const
{{''')
		if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
		out(f'''
	__ndr << enter;''');
		for elem in typedef_get_elements(t):
			if elem_has_property(elem, 'x_length', 'x_elem_size', 'x_size', 'x_offset', 'value', 'x_ignored', 'noprint'):
				continue
			if elem_is_array_len_of(elem, t) or elem_is_property_of(elem, t, "size_is", "length_is", "array_len"):
				continue
			ndr_flags = elem_get_ndr_flags(elem)
			switch_is = elem_get_switch_is(elem)
			out(f'''
	X_NDR_OSTR_NEXT(__val.{elem["NAME"]}, __ndr, {ndr_flags}, {switch_is});''')
		out(f'''
	__ndr << leave;
}}

''')


def output_header_UNION(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	buffers = typedef_get_buffers(t, idl_tbl)
	out(f'''

union {tname}
{{
''')
	if not typedef_is_trivial(idl_tbl, t):
		out(f'''
	{tname}() {{ }}
	~{tname}() {{ }}
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, const {tname} &__other);
	void __uninit(x_ndr_switch_t __level);
''')
	# union member may has same name
	fields = { }
	for elem in typedef_get_elements(t):
		elem_check_properties(elem, F_UNION)
		fname = elem['NAME']
		if fname == '':
			continue
		try:
			prev = fields[fname]
			assert prev['TYPE'] == elem['TYPE']
		except KeyError:
			output_header_element(out, elem, t, iface, [])
			fields[fname] = { 'TYPE': elem['TYPE'] } 
	out(f'''
}} {typedef_tostring_properties(t)};

template <> struct ndr_traits_t<{tname}> {{
	using has_buffers = std::{"true_type" if len(buffers) else "false_type"};
	using ndr_type = x_ndr_type_union;
	x_ndr_off_t ndr_scalars(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_scalars({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	if len(buffers): out(f'''
	x_ndr_off_t ndr_buffers(const {tname} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t ndr_buffers({tname} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
	out(f'''
	void ostr(const {tname} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};
''')

def output_ndrcxx_union_element(idl_tbl, idl, t, name, func, out):
	alignment = typedef_get_align(t, idl_tbl)
	out(f'''
	X_NDR_UNION_ALIGN({alignment}, __ndr, __bpos, __epos, __flags);
	switch (__level) {{
''')
	for elem in typedef_get_elements(t):
		etname = elem['TYPE']
		out(f'''
		{elem_get_case_str(elem)}: {{''')
		if elem['NAME'] != '': out(f'''
			X_NDR_SCALARS_SIMPLE(__val.{elem['NAME']}, __ndr, __bpos, __epos, __flags, X_NDR_SWITCH_NONE);''')
		out(f'''
		}} break;
''')
	out('''
	}
''')

def output_ndrcxx_UNION(out, t, iface, idl, idl_tbl):
	ndr_name = t["NAME"]
	tdata = t['DATA']
	if not typedef_is_trivial(idl_tbl, t):
		out(f'''

void {ndr_name}::__init(x_ndr_switch_t __level)
{{
	switch (__level) {{''')
		for elem in typedef_get_elements(t):
			case_str = elem_get_case_str(elem)
			if len(elem["NAME"]) > 0:
				in_case_str = f' construct({elem["NAME"]});'
			else:
				in_case_str = ''
			out(f'''
		{case_str}:{in_case_str} break;''')
		out(f'''
	}}
}}

void {ndr_name}::__init(x_ndr_switch_t __level, const {ndr_name} &other)
{{
	switch (__level) {{''')
		for elem in typedef_get_elements(t):
			case_str = elem_get_case_str(elem)
			if len(elem["NAME"]) > 0:
				in_case_str = f' construct({elem["NAME"]}, other.{elem["NAME"]});'
			else:
				in_case_str = ''
			out(f'''
		{case_str}:{in_case_str} break;''')
		out(f'''
	}}
}}

void {ndr_name}::__uninit(x_ndr_switch_t __level)
{{
	switch (__level) {{''')
		for elem in typedef_get_elements(t):
			case_str = elem_get_case_str(elem)
			if len(elem["NAME"]) > 0:
				in_case_str = f' destruct({elem["NAME"]});'
			else:
				in_case_str = ''
			out(f'''
		{case_str}:{in_case_str} break;''')
		out(f'''
	}}
}}
''')

	flags = typedef_get_property(t, 'flags')
	if not typedef_get_property(t, "nopush"):
		out(f'''

x_ndr_off_t ndr_traits_t<{ndr_name}>::ndr_scalars(const {ndr_name} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		if flags is not None:
			out(f'''
	x_ndr_set_flags(__flags, {flags});
''')
		output_ndrcxx_union_element(idl_tbl, idl, t, ndr_name, "push", out)
		out(f'''
	return __bpos;
}}

''')
	if not typedef_get_property(t, "nopull"):
		out(f'''
x_ndr_off_t ndr_traits_t<{ndr_name}>::ndr_scalars({ndr_name} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		if flags is not None:
			out(f'''
	x_ndr_set_flags(__flags, {flags});
''')
		output_ndrcxx_union_element(idl_tbl, idl, t, ndr_name, "pull", out)
		out(f'''
	return __bpos;
}}

''')
	if not has_property(tdata, "noprint"): # TODO
		out(f'''
void ndr_traits_t<{ndr_name}>::ostr(const {ndr_name} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const
{{''')
		if flags is not None: out(f'''
	x_ndr_set_flags(__flags, {flags});''')
		out(f'''
	switch (__level) {{
''')
		for elem in tdata['ELEMENTS']:
			etname = elem['TYPE']
			out(f'''
		{elem_get_case_str(elem)}: {{''')
			if elem['NAME'] != '': out(f'''
			X_NDR_OSTR(__val.{elem["NAME"]}, __ndr, __flags, X_NDR_SWITCH_NONE);''')
			out(f'''
		}} break;
''')
		out(f'''
	}}
}}

''')


def map_enum_type(t):
	assert t['DATA']['TYPE'] == "ENUM"

	# for typedef enum { } we need to check $enum->{PARENT}
	if typedef_has_property(t, "enum8bit"):
		return "uint8", "uint8"
	elif typedef_has_property(t, "enum16bit"):
		return "uint16", "uint16"
	elif typedef_has_property(t, "v1_enum"):
		return "uint32", "uint32"
	else:
		warn(f'at {t["FILE"]}:{t["LINE"]} unknown enum properties {t["DATA"].get("PROPERTIES", None)}')
		# should be uint16? TODO
		return "uint16", "uint1632"

def output_header_ENUM(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	elements = typedef_get_elements(t)
	etype, fname = map_enum_type(t)
	out(f'''

enum {tname} : {etype} {{
''')
	for elem in elements:
		out(f'''
	{elem},
''')
		#out(re.sub(r'^(.*)=(.*)$', r'\1=\2,', elem))
	out(f'''
}}{typedef_tostring_properties(t)};

X_NDR_DECLARE_TRAITS_ENUM({tname}, {etype}, {len(elements)}, x_ndr_type_enum)

''')

def output_ndrcxx_ENUM(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	etype, fname = map_enum_type(t)
	tdata = t['DATA']
	if not "ELEMENTS" in tdata:
		return
	out(f'''
const std::array<std::pair<{etype}, const char *>, {len(tdata["ELEMENTS"])}> ndr_traits_t<{tname}>::value_name_map = {{ {{
''')
	for elem in tdata["ELEMENTS"]:
		ev = elem.split('=')[0]
		out(f'''
	{{ {ev}, "{ev}" }},
''')
	out('''
} };


''')

def map_bitmap_type(t):
	assert t['DATA']['TYPE'] == "BITMAP"

	if typedef_has_property(t, "bitmap8bit"):
		return "uint8", "uint8"
	elif typedef_has_property(t, "bitmap16bit"):
		return "uint16", "uint16"
	elif typedef_has_property(t, "bitmap32bit"):
		return "uint32", "uint32"
	elif typedef_has_property(t, "bitmap64bit"):
		return "uint64", "uint64"
	else:
		warn(f'at {t["FILE"]}:{t["LINE"]} {t["NAME"]} unknown bits')
		return "uint32", "uint32"

def output_header_BITMAP(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	etype, fname = map_bitmap_type(t)
	elements = typedef_get_elements(t)
	out(f'''

enum {tname} : {etype} {{
''')
	for elem in elements:
		statement = re.sub(r'^([^ ]+) *\( *([^ ]+) *\)$', r'\1=\2,', elem)
		out(f'''
	{statement}
''')
	out(f'''
}}{typedef_tostring_properties(t)};

X_NDR_DECLARE_TRAITS_ENUM({tname}, {etype}, {len(elements)}, x_ndr_type_bitmap)

''')

def output_ndrcxx_BITMAP(out, t, iface, idl, idl_tbl):
	tname = t["NAME"]
	etype, fname = map_bitmap_type(t)
	elements = typedef_get_elements(t)
	out(f'''
const std::array<std::pair<{etype}, const char *>, {len(elements)}> ndr_traits_t<{tname}>::value_name_map = {{ {{''')
	for elem in elements:
		ev = re.sub(r'^([^ ]+) *\( *([^ ]+) *\)$', r'\1', elem)
		out(f'''
	{{ {ev}, "{ev}" }},
''')
	out('''
} };


''')


def output_header_INTERFACE(out, iface, idl, idl_tbl):

	for t in iface['DATA']:
		if t['TYPE'] == 'TYPEDEF':
			realtype = typedef_get_realtype(t)
			if realtype == 'STRUCT':
				output_header_STRUCT(out, t, iface, idl, idl_tbl)
			elif realtype == 'UNION':
				output_header_UNION(out, t, iface, idl, idl_tbl)
			elif realtype == 'ENUM':
				output_header_ENUM(out, t, iface, idl, idl_tbl)
			elif realtype == 'BITMAP':
				output_header_BITMAP(out, t, iface, idl, idl_tbl)
			else:
				error(f'''Unknown typedef "{realtype}" at {t["FILE"]}:{t["LINE"]}''')
				assert False
		elif t['TYPE'] == 'CONST':
			dtype = t['DTYPE']
			assert const_get_pointers(t) == 0
			out(f'''
const {dtype}{'*' if t['POINTERS'] == 1 else ''} {t['NAME']} = {t['VALUE']};
''')
		elif t["TYPE"] in [ "FUNCTION" ]:
			pass
			#output_header_FUNCTION(out, idl, t);
		else:
			error(f'''Unknown type "{t['TYPE']}" at {t['FILE']}:{t['LINE']}''')
			assert False


def output_ndrcxx_INTERFACE(out, iface, idl, idl_tbl):
	helper = get_property(iface, "helper")
	if helper is not None:
		out(f'''
#include {helper}
''')
	out(f'''

namespace idl {{

''')
	for t in iface['DATA']:
		if t['TYPE'] == 'TYPEDEF':
			"""
			if t['NAME'] in known_structs:
				continue
			"""
			realtype = typedef_get_realtype(t)
			if realtype == 'STRUCT':
				output_ndrcxx_STRUCT(out, t, iface, idl, idl_tbl)
			elif realtype == 'UNION':
				output_ndrcxx_UNION(out, t, iface, idl, idl_tbl)
			elif realtype == 'ENUM':
				output_ndrcxx_ENUM(out, t, iface, idl, idl_tbl)
			elif realtype == 'BITMAP':
				output_ndrcxx_BITMAP(out, t, iface, idl, idl_tbl)
			else:
				assert False
		elif t['TYPE'] in [ "FUNCTION" ]:
			pass
			# TODO output_ndrcxx_FUNCTION(out, idl, t)
		elif t['TYPE'] in [ "CONST", "FUNCTION" ]:
			pass
		else:
			assert False

	out(f'''

// }}
}}
''')

def output_header_IMPORT(out, o):
	for path in o['PATHS']:
		import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
		out(f'#include "include/librpc/{import_name}.hxx"')
	out()

def process_header(out, name, idl, idl_tbl, outdir):
	ifacename = None
	for o in idl:
		if o['TYPE'] == "INTERFACE":
			ifacename = o['NAME']
			break

	out(f'''
/* header auto-generated by gen-rpc */
#ifndef __GEN_RPC__HEADER_{ifacename}
#define __GEN_RPC__HEADER_{ifacename}
#include "include/librpc/ndr_smb.hxx"

''')

	for o in idl:
		if o['TYPE'] == "IMPORT": output_header_IMPORT(out, o)
		if o['TYPE'] == "INCLUDE": output_header_INCLUDE(out, o)

	out(f'''
namespace idl {{
''')

	for o in idl:
		if o['TYPE'] == "CPP_QUOTE": output_header_QUOTE(out, o)
		if o['TYPE'] == "INTERFACE": output_header_INTERFACE(out, o, idl, idl_tbl)
			
	out(f'''

}} /* namespace idl */

#endif /* __GEN_RPC__HEADER_{ifacename} */

''')


def process_ndrcxx(out, name, idl, idl_tbl, outdir):
	out(f'''
/* ndr parser auto-generated by pidl */
	
#include "include/librpc/{name}.hxx"

''')

	for o in idl:
		if o['TYPE'] == "INTERFACE": output_ndrcxx_INTERFACE(out, o, idl, idl_tbl)



def process_depend(out, name, idl, idl_tbl, outdir):
	for o in idl:
		if o['TYPE'] != "IMPORT":
			continue
		for path in o['PATHS']:
			import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
			out(f'''
{outdir}/{name}.idl.hxx: {outdir}/{import_name}.json
{outdir}/{name}.idl.ndr.cxx: include/librpc/{import_name}.hxx
{outdir}/{name}.idl.ndr.o: include/librpc/ndr.hxx
{outdir}/{name}.idl.ndr.o: include/librpc/ndr_smb.hxx
''')

def load_idl_with_import(infp):
	imports = []
	idl = json.load(infp)
	for o in idl:
		if o['TYPE'] != "IMPORT":
			continue
		for path in o['PATHS']:
			import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
			imports.append(import_name)
	return idl, imports

def load_all(infp, name, path, recur):
	idl_tbl = {}
	idl, imports = load_idl_with_import(infp)
	idl_tbl[name] = idl

	while recur and imports:
		name = imports.pop()
		if name in idl_tbl:
			continue
		filename = os.path.join(path, '.'.join([name, "json"]))
		with open(filename, 'r') as fp:
			new_idl, new_imports = load_idl_with_import(fp)
			idl_tbl[name] = new_idl
			imports += new_imports
	return idl, idl_tbl

def process(infp, name, args):
	idl, idl_tbl = load_all(infp, name, args.outputdir, args.header or args.ndrcxx)

	def output(func, ext):
		if name is None:
			outfp = sys.stdout
		else:
			tmpfix = "tmp"
			filename = os.path.join(args.outputdir, '.'.join([name, ext, tmpfix]))
			outfp = open(filename, 'w')

		try:
			out = OStream(outfp)
			func(out, name, idl, idl_tbl, args.outputdir)
		except:
			if name is not None:
				outfp.close()
				os.remove(filename)
			raise
		if name is not None:
			os.rename(filename, os.path.join(args.outputdir, '.'.join([name, ext])))
	
	if args.depend: output(process_depend, 'd')
	if args.header: output(process_header, 'idl.hxx')
	if args.ndrcxx: output(process_ndrcxx, 'idl.ndr.cxx')
	if args.python: output(process_python, 'py.cxx')
			
	
def main():
	parser = argparse.ArgumentParser()
	parser.add_argument("-d", "--debug", action="store_true", help="output debug info")
	parser.add_argument("--depend", action="store_true", help="output dependency")
	parser.add_argument("--header", action="store_true", help="output header")
	parser.add_argument("--ndrcxx", action="store_true", help="output ndr")
	parser.add_argument("--python", action="store_true", help="output ndr")
	parser.add_argument("--outputdir", default=".", help="output directory")
	parser.add_argument("input", nargs='*', help="Input IDL json files")

	args = parser.parse_args()
	args.outputdir = args.outputdir.rstrip('/')
	if args.debug:
		global DBG
		print(args, file=sys.stderr)
		DBG = _dbg_stderr

	if len(args.input) == 0:
		process(sys.stdin, None, args)
	else:
		for f in args.input:
			with open(f, 'r') as fp:
				name = os.path.splitext(os.path.basename(f))[0]
				process(fp, name, args)

	return 0

if __name__ == "__main__": sys.exit(main())

