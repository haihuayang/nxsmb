#!/usr/bin/env python3

from __future__ import print_function
import os, sys
from io import StringIO
import re, argparse, json

# is_trivial false requires construct for union
# TODO
# [size_is(count) uint32 field[*]
# ref pointer

class OStream(object):
	def __init__(self, fp):
		self.fp = fp
	def write(self, s):
		self.fp.write(s)
	def __call__(self, s=''):
		try:
			if s[0] == '\n':
				s = s[1:]
		except:
			pass

		self.fp.write(s)
		try:
			if s[-1] == '\n':
				return
		except:
			pass
		self.fp.write('\n')

class LazyToStr(object):
	def __init__(self, func, *args):
		self.func, self.args = func, args
	def __str__(self):
		return '{0}'.format(self.func(*self.args))

def _dbg_none(*args):
	pass

def _dbg_stderr(*args):
	print("DBG:", *args, file=sys.stderr)

DBG = _dbg_none

def warn(msg):
	print("Warning:", msg, file = sys.stderr)

def error(msg):
	print("Error:", msg, file = sys.stderr)


def get_property(jsobj, prop, default = None):
	try:
		return jsobj['PROPERTIES'][prop]
	except KeyError:
		return default

def has_property(jsobj, prop):
	v = get_property(jsobj, prop)
	if v is None:
		return False
	assert v == '1'
	return True

def get_elements(jsobj):
	try:
		return jsobj['ELEMENTS']
	except:
		return []

def typedef_get_elements(jsobj):
	return get_elements(jsobj['DATA'])

def tostring_properties__(data):
	if 'PROPERTIES' in data:
		ret = []
		for key, val in data['PROPERTIES'].items():
			if val != '1':
				ret.append(f'{key}({val})')
			else:
				ret.append(key)
		return '/* [' + ', '.join(ret) + '] */'
	else:
		return ''

def elem_tostring_properties(e):
	return tostring_properties__(e)

def typedef_tostring_properties(t):
	return tostring_properties__(t['DATA'])

def function_tostring_properties(t):
	return tostring_properties__(t)

def has_any_property(elem, *args):
	try:
		prop = elem['PROPERTIES']
	except:
		return False
	for arg in args:
		if arg in prop:
			return True
	return False

elem_has_property = has_any_property

def elem_is_property_of(elem, elems, *args):
	for me in elems:
		for prop in args:
			try:
				if elem["NAME"] == elem_get_property(me, prop):
					return me
			except:
				pass
	return None

def elem_get_array_len(elem):
	try:
		array_len = elem['ARRAY_LEN']
		if len(array_len) == 0:
			return None
		assert len(array_len) == 1
		return array_len[0]
	except KeyError:
		return None

def elem_get_property(t, prop, default = None):
	return get_property(t, prop, default)

def elem_is_expr_property_of(elem, elems, *args):
	ename = elem["NAME"]
	for me in elems:
		for prop in args:
			value = elem_get_property(me, prop)
			if value is None:
				continue
			if any([ename == operand for operand in re.split(r'[^0-9a-zA-Z_.]+', value)]):
				return me
	return None


F_STRUCT = 0x1
F_UNION  = 0x2
F_FUNCTION = 0x4
know_properties = {
	'case': F_UNION,
	'default': F_UNION,
	'flag': F_STRUCT | F_UNION,
	'range': F_STRUCT | F_FUNCTION,
	'value': F_STRUCT | F_UNION,
	'charset': F_STRUCT | F_UNION | F_FUNCTION,
	'switch_is': F_STRUCT | F_FUNCTION,
	'switch_type': F_STRUCT,
	'size_is': F_STRUCT | F_FUNCTION,
	'in': F_FUNCTION, # TODO
	'out': F_FUNCTION, # TODO
	'unique': F_STRUCT | F_FUNCTION, # TODO
	'length_is': F_STRUCT | F_FUNCTION, # TODO
	'noprint': F_STRUCT | F_UNION, # TODO
	#'ignore': F_STRUCT | F_UNION, # TODO
	'x_ignored': F_STRUCT,
	'string': F_STRUCT | F_UNION | F_FUNCTION, # TODO
	'compression': F_STRUCT | F_UNION, # TODO
	'subcontext': F_STRUCT | F_UNION, # TODO rewrite
	'subcontext_size': F_STRUCT | F_UNION, # TODO rewrite
	'relative': F_STRUCT | F_UNION, # TODO rewrite
	'relative_short': F_STRUCT | F_UNION, # TODO rewrite
	'ref': F_FUNCTION, # TODO rewrite
	#'x_offset': F_STRUCT,
	'x_skip': F_STRUCT,
	'x_size': F_STRUCT,
	'x_ndr_size': F_STRUCT,
	#'x_with_size': F_STRUCT,
	'x_relative': F_STRUCT,
	'x_group_start': F_STRUCT,
	'x_group_end': F_STRUCT,
	'x_pull_value': F_STRUCT,
	'x_push_value': F_STRUCT,
}


known_simple_types = (
	# name, align, is_trival, has_buffers
	('EMPTY', 0, True, False),
	('void', 0, True, False),
	('char', 1, True, False),
	('int8', 1, True, False),
	('uint8', 1, True, False),
	('int16', 2, True, False),
	('uint16', 2, True, False),
	('int1632', 3, True, False),
	('uint1632', 3, True, False),
	('int', 4, True, False), # int32
	('int32', 4, True, False),
	('long', 4, True, False), # uint32
	('DWORD', 4, True, False),
	('WORD', 2, True, False),
	('uint32', 4, True, False),
	('mode_t', 4, True, False), # uint32
	('boolean8', 1, True, False),
	('boolean32', 4, True, False), # uint32
	('int3264', 5, True, False),
	('uint3264', 5, True, False),
	('uint64', 8, True, False),
	('double', 8, True, False),
	('pointer', 8, True, False),
	('dlong', 4, True, False),
	('udlong', 4, True, False),
	('udlongr', 4, True, False),
	('hyper', 4, True, False),
	('NTSTATUS', 4, True, False),
	('NTTIME', 4, True, False),
	('time_t', 4, True, False),
	('ipv4address', 4, True, False),
	('ipv6address', 4, True, False), #16?
	('WERROR', 4, True, False),
	('DATA_BLOB', 4, False, False),
        ('u16string', 2, False, False),
        ('u8string', 1, False, False),
)

alias_types = {
	# alias, type_name, traits_type, align
        'NTTIME_hyper': ['NTTIME', 'ndr_traits_NTTIME_hyper', 8],
	'dom_sid2': [ 'dom_sid', 'ndr_traits_dom_sid2', None],
	'u16string_remain': [ 'u16string', 'ndr_traits_u16string_remain', 1],
	'nstring': [ 'u16string', 'ndr_traits_nstring', 2],
	'astring': [ 'u8string', 'ndr_traits_astring', 1],
}


class FieldTypeBase(object):
	def has_buffers(self):
		raise NotImplementedError
	def dereferenced(self):
		return False
	def is_union(self):
		return False
	def both(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		ret = [f'auto __tmp_pos_index_{order} = {ndr_arg}.pos_index;']
		ret += self.scalars_step0(order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is)
		ret += self.scalars_pre(order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is)
		ret += self.scalars_body(order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is)
		ret += self.scalars_post(order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is)
		if self.has_buffers():
			ret += [f'{ndr_arg}.pos_index = __tmp_pos_index_{order};']
			ret += self.buffers_pre(order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is)
			ret += self.buffers_body(order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is)
			ret += self.buffers_post(order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is)
			ret += [f'{ndr_arg}.pos_index = __tmp_pos_index_{order};',
				f'//{ndr_arg}.pos_array.resize(__tmp_pos_index_{order});']
		else:
			ret += [f'assert({ndr_arg}.pos_index == __tmp_pos_index_{order});']
		return ret
	def scalars_step0(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return []
	def scalars_pre(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return []
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		raise NotImplementedError
	def scalars_post(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return []
	def buffers_pre(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return []
	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		raise NotImplementedError
	def buffers_post(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return []

class FieldTypeSimple(FieldTypeBase):
	def __init__(self, jsobj, idltype, dereferenced):
		self.jsobj, self.idltype = jsobj, idltype
		self.name = jsobj['NAME']
		self.dereferenced_ = dereferenced
		DBG(f'FieldTypeSimple name={self.name}, idltype={self.idltype}')
	def get_idltype(self):
		return self.idltype
	def is_union(self):
		return isinstance(self.idltype, IdlTypeUnion)
	def get_ctype(self):
		return self.idltype.get_ctype()
	def has_buffers(self):
		return self.idltype.has_buffers()
	def is_trivial(self):
		return self.idltype.is_trivial()
	def dereferenced(self):
		return self.dereferenced_
	def get_ndr_traits(self):
		return self.idltype.get_ndr_traits()
	def get_property(self, prop, default = None):
		return get_property(self.jsobj, prop, default)
	'''
	def get_ndr_flags(self, flag_arg = '__flags'):
		flag = self.get_property('flag')
		if flag is None:
			return flag_arg
		else:
			return f'x_ndr_set_flags({flag_arg}, {flag})'
	'''
	def get_alignment(self):
		return self.idltype.get_alignment()
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, {name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']

	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_BUFFERS_SIMPLE({self.get_ndr_traits()}, {name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']

	def ostr(self, order, name, ndr_flags, switch_is):
		return [f'X_NDR_OSTR_SIMPLE({self.get_ndr_traits()}, {name}, __ndr, {ndr_flags}, {switch_is});']

	def __str__(self):
		return str(self.idltype)


class FieldTypeDerived(FieldTypeBase):
	def __init__(self, jsobj, idltype, dereferenced):
		assert isinstance(idltype, IdlTypePrimary)
		assert not idltype.has_buffers()
		self.jsobj, self.idltype = jsobj, idltype
		self.dereferenced_ = dereferenced

	def is_trivial(self):
		return True

	def has_buffers(self):
		return False

	def get_alignment(self):
		return self.idltype.get_alignment()

	def get_ctype(self):
		return self.idltype.get_ctype()

	def get_ndr_traits(self):
		return self.idltype.get_ndr_traits()

	def ostr(self, order, name, ndr_flags, switch_is):
		return []

class FieldTypeXSize(FieldTypeDerived):
	def scalars_pre(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_XSIZE_PRE_{func}({self.get_ctype()}, {order}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_XSIZE_{func}({self.get_ctype()}, {order}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def scalars_post(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_XSIZE_POST_{func}({self.get_ctype()}, {order}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		#return [f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, (__bpos - __base), {ndr_arg}, __pos_{order}, {epos_arg}, {ndr_flags}, {switch_is});''']
	def str(self):
		return "XSize(%s)" % self.get_ctype()

class FieldTypeSlave(FieldTypeDerived):
	def __init__(self, jsobj, idltype, dereferenced, master_field):
		super().__init__(jsobj, idltype, dereferenced)
		self.master_field = master_field

class FieldTypeVectorLen(FieldTypeSlave):
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_VECTOR_LEN_{func}({self.get_ctype()}, {self.master_field.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def __str__(self):
		return "VectorLen(%s)" % self.get_ctype()

class FieldTypeXNdrSize(FieldTypeSlave):
	def set_size_field(self, field):
		self.ndr_size_field = field
		self.has_buffers = field.has_buffers
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if func == 'PUSH':
			return [ f'x_ndr_off_t __pos_{self.name} = {bpos_arg};',
				f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, {self.get_ctype()}(), {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, X_NDR_SWITCH_NONE);' ]
		else:
			return [ f'{self.get_ctype()} __tmp_{self.name};',
				f'X_NDR_SCALARS_SIMPLE({self.get_ndr_traits()}, __tmp_{self.name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, X_NDR_SWITCH_NONE);' ]

	def __str__(self):
		return "XNdrSize(%s)" % self.idltype

class FieldTypeSubctxSize(FieldTypeSlave):
	def has_buffers(self):
		return self.master_field.has_buffers()
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if self.has_buffers():
			return [f'X_NDR_SAVE_POS({self.get_ctype()}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		else:
			return [f'x_ndr_off_t __pos_{order} = {bpos_arg};',
				f'X_NDR_SKIP({self.get_ctype()}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'x_ndr_off_t __pos_{order} = {ndr_arg}.load_pos();']

class FieldTypeSizeIs(FieldTypeSlave):
	def has_buffers(self):
		return self.master_field.has_buffers()
	def scalars_pre(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if self.has_buffers():
			return []
		else:
			return [f'{self.get_ctype()} __tmp_sizeis_{order} = 0;']
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if self.has_buffers():
			return [f'X_NDR_SAVE_POS({self.get_ctype()}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		else:
			return [ f'x_ndr_off_t __pos_{order} = {bpos_arg};']
	def scalars_post(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if self.has_buffers():
			return []
		else:
			return [ f'X_NDR_SIZE_IS_POST_{func}(__tmp_sizeis_{order}, __pos_{order}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def buffers_pre(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'{self.get_ctype()} __tmp_sizeis_{order};']
	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [ f'x_ndr_off_t __pos_{order} = {ndr_arg}.load_pos();']
	def buffers_post(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [ f'X_NDR_SIZE_IS_POST_{func}(__tmp_sizeis_{order}, __pos_{order}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def __str__(self):
		return 'SizeIs'

FieldTypeLengthIs = FieldTypeSizeIs

class FieldTypeSubctxBase(FieldTypeBase):
	def __init__(self, inner):
		self.inner = inner
	def get_idltype(self):
		return self.inner.get_idltype()
	def is_union(self):
		return self.inner.is_union()
	def has_buffers(self):
		return False
	def is_trivial(self):
		return self.inner.is_trivial()
	def get_ctype(self):
		return self.inner.get_ctype()
	def ostr(self, order, name, ndr_flags, switch_is):
		return self.inner.ostr(order, name, ndr_flags, switch_is)
	
class FieldTypeSubctxLevel(FieldTypeSubctxBase):
	def __init__(self, inner, level, size_field):
		super().__init__(inner)
		assert level in [ 0, 2, 4]
		self.level = level
		self.size_field = size_field
	def get_alignment(self):
		return self.inner.get_alignment()
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if self.level == 4:
			size_type = 'uint32'
		elif self.level == 2:
			size_type = 'uint16'
		else:
			assert self.level == 0
			size_type = None

		ret = []
		if self.level == 0:
			assert not self.size_field is None
			ret += [f'X_NDR_SUBCTX_LEVEL0_SIZE_START_{func}({self.size_field.get_ctype()}, __pos_{self.size_field.order}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		elif self.size_field is None:
			ret += [f'X_NDR_SUBCTX_LEVEL_NOSIZE_START_{func}({size_type}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		else:
			ret += [f'X_NDR_SUBCTX_LEVEL_SIZE_START_{func}({self.size_field.get_ctype()}, __pos_{self.size_field.order}, {size_type}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		ret += [f'X_NDR_SUBCTXLEVEL_START_{func}(__sub_ndr, {ndr_arg}, {bpos_arg}, {epos_arg}) {{']
		ret = append_stmts(ret, 
			self.inner.both(order, func, name, '__sub_ndr', bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [f'}} X_NDR_SUBCTXLEVEL_END_{func}(__sub_ndr, {ndr_arg}, {bpos_arg}, {epos_arg});']
		if self.level == 0:
			ret += [f'X_NDR_SUBCTX_LEVEL0_SIZE_END_{func}({self.size_field.get_ctype()}, __pos_{self.size_field.order}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		elif self.size_field is None:
			ret += [f'X_NDR_SUBCTX_LEVEL_NOSIZE_END_{func}({size_type}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		else:
			ret += [f'X_NDR_SUBCTX_LEVEL_SIZE_END_{func}({self.size_field.get_ctype()}, __pos_{self.size_field.order}, {size_type}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
			
		return ret

	def __str__(self):
		return 'SubctxLevel(%d,%s)' % (self.level, self.inner)


class FieldTypeSubctxFFFFFC01(FieldTypeSubctxBase):
	def get_alignment(self):
		return 1
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return append_stmts([f'X_NDR_SUBCTXFFFFFC01_START_{func}(__sub_ndr, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}) {{'],
			self.inner.both(order, func, name, '__sub_ndr', bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [
			f'}} X_NDR_SUBCTXFFFFFC01_END_{func}(__sub_ndr, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});' ]
	def __str__(self):
		return 'SubctxFFFFFC01(%s)' % self.inner

class FieldTypeIdlString(FieldTypeBase):
	def __init__(self, jsobj, idltype, dereferenced):
		self.idltype = idltype 
		self.jsobj = jsobj
		self.dereferenced_ = dereferenced

		#if self.ndr_traits is None:
		#	self.ndr_traits = f'ndr_traits_t<{string_type}>'
	def get_idltype(self):
		return self.idltype
	def is_union(self):
		return False
	def get_ctype(self):
		return self.idltype.get_ctype()

	def is_trivial(self):
		return False

	def has_buffers(self):
		return False

	def get_alignment(self):
		return self.idltype.get_alignment()

	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SCALARS_IDLSTRING({name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']

	def ostr(self, order, name, ndr_flags, switch_is):
		return [f'X_NDR_OSTR_IDLSTRING({name}, __ndr, {ndr_flags}, {switch_is});']

	def __str__(self):
		return "IdlString(%s)" % self.get_ctype()

class FieldTypeArray(FieldTypeBase):
	def __init__(self, inner, array_size):
		self.inner, self.array_size = inner, array_size
	def has_buffers(self):
		return self.inner.has_buffers()
	def is_trivial(self):
		return self.inner.is_trivial()
	def get_ctype(self):
		ctype = self.inner.get_ctype()
		return f'std::array<{ctype}, {self.array_size}>'
	def get_alignment(self):
		return self.inner.get_alignment()
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return append_stmts([ f'for (auto &__tmp_{order}: {name}) {{' ],
			self.inner.scalars_body(order, func, f'__tmp_{order}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [ '}' ]
	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return append_stmts([ f'for (auto &__tmp_{order}: {name}) {{' ],
			self.inner.buffers_body(order, func, f'__tmp_{order}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [ '}' ]
	def ostr(self, order, name, ndr_flags, switch_is):
		if self.inner.get_ctype() == 'uint8':
			return [ f'X_ASSERT({switch_is} == X_NDR_SWITCH_NONE);',
				f'__ndr << "size=" << ({name}).size() << " ";',
				f'for (size_t i = 0; i < ({name}).size(); ++i) {{;',
				f'\tchar __tmp_out[8];',
				f'\tsnprintf(__tmp_out, 8, "%02x", ({name})[i]);',
				f'\t__ndr << __tmp_out;',
				'}']
		return append_stmts([ f'X_ASSERT({switch_is} == X_NDR_SWITCH_NONE);',
			f'__ndr << "size=" << ({name}).size();',
			'__ndr << enter;',
			f'for (size_t i = 0; i < ({name}).size(); ++i) {{;',
			'\t__ndr << "#" << i << ": ";'],
			self.inner.ostr(order, f'({name})[i]', ndr_flags, switch_is),
			'\t') + [
			f'\t__ndr << next;',
			'}',
			'__ndr << leave;']
	def __str__(self):
		return f'{self.inner}[self.array_size]'

class FieldTypeVector(FieldTypeBase):
	def __init__(self, inner):
		self.inner = inner
	def is_trivial(self):
		return False
	def get_ctype(self):
		ctype = self.inner.get_ctype()
		return f'std::vector<{ctype}>'
	def has_buffers(self):
		return self.inner.has_buffers()
	def get_alignment(self):
		return self.inner.get_alignment()
	def ostr(self, order, name, ndr_flags, switch_is):
		return append_stmts([ f'X_ASSERT({switch_is} == X_NDR_SWITCH_NONE);',
			f'__ndr << "size=" << ({name}).size();',
			'__ndr << enter;',
			f'for (size_t i = 0; i < ({name}).size(); ++i) {{;',
			'\t__ndr << "#" << i << ": ";'],
			self.inner.ostr(order, f'({name})[i]', ndr_flags, switch_is),
			'\t') + [
			f'\t__ndr << next;',
			'}',
			'__ndr << leave;']

class FieldTypeUnboundVector(FieldTypeVector):
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if func == 'PUSH':
			return append_stmts([ f'for (auto &__tmp_{order}: {name}) {{' ],
				self.inner.scalars_body({order}, func, f'__tmp_{order}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [ '}' ]
		else:
			return append_stmts([f'while ({bpos_arg} < {epos_arg}) {{',
					f'\t{self.inner.get_ctype()} __tmp_{order};'],
				self.inner.scalars_body(order, func, f'__tmp_{order}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [
					f'\t{name}.push_back(__tmp_{order});',
					'}' ]
	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		assert False, "Not supported"
	def __str__(self):
		return '%s[]' % self.inner

class FieldTypeSimpleVector(FieldTypeVector):
	def __init__(self, inner, array_len_field):
		super().__init__(inner)
		self.array_len_field = array_len_field
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return append_stmts([ f'for (auto &__tmp_{order}: {name}) {{' ],
			self.inner.scalars_body(order, func, f'__tmp_{order}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [ '}' ]
	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return append_stmts([ f'for (auto &__tmp_{order}: {name}) {{' ],
			self.inner.buffers_body(order, func, f'__tmp_{order}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [ '}' ]
	def __str__(self):
		return '%s[%s]' % (self.inner, self.array_len_field.name)

class FieldTypeSizeIsVector(FieldTypeVector):
	def __init__(self, inner, size_is_field):
		super().__init__(inner)
		assert isinstance(size_is_field, Field) or size_is_field is None
		self.size_is_field = size_is_field
	def scalars_step0(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [ f'X_NDR_SCALARS_SIZE_IS_VECTOR_STEP0_{func}({name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		ret = []
		if self.size_is_field:
			ret.append(f'X_NDR_SCALARS_SIZE_IS_VECTOR_{func}(__tmp_sizeis_{self.size_is_field.order}, {name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});')
		ret.append(f'for (auto &__tmp_iter_{order}: {name}) {{')
		return append_stmts(ret,
			self.inner.scalars_body(order, func, f'__tmp_iter_{order}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [ '}' ]
	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return append_stmts([ f'for (auto &__tmp_iter_{order}: {name}) {{' ],
			self.inner.buffers_body(order, func, f'__tmp_iter_{order}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [ '}' ]
	def __str__(self):
		return "SizeIsVector(%s,%s)" % (self.inner, self.size_is_field)

class FieldTypeLengthIsVector(FieldTypeVector):
	def __init__(self, inner, size_is_field, length_is_field):
		super().__init__(inner)
		assert isinstance(length_is_field, Field)
		self.size_is_field = size_is_field
		self.length_is_field = length_is_field
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if isinstance(self.size_is_field, Field):
			ret = [f'X_NDR_SCALARS_LENGTH_IS_VECTOR_2_{func}(__tmp_sizeis_{self.size_is_field.order}, __tmp_sizeis_{self.length_is_field.order}, {name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		else:
			ret = [f'X_NDR_SCALARS_LENGTH_IS_VECTOR_1_{func}({self.size_is_field}, __tmpsizeis_{self.length_is_field.order}, {name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
		ret.append(f'for (auto &__tmp_iter_{order}: {name}) {{')
		return append_stmts(ret,
			self.inner.scalars_body(order, func, f'__tmp_iter_{order}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [ '}' ]
	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return append_stmts([ f'for (auto &__tmp_iter_{order}: {name}) {{' ],
				self.inner.buffers_body(order, func, f'__tmp_iter_{order}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is), '\t') + [ '}' ]
	def __str__(self):
		return "LengthIsVector(%s,%s,%s)" % (self.inner, self.size_is_field, self.length_is_field)

class FieldTypePtr(FieldTypeBase):
	def __init__(self, inner):
		self.inner = inner
	def get_idltype(self):
		return self.inner.get_idltype()
	def is_union(self):
		return self.inner.is_union()
	def has_buffers(self):
		return True
	def is_trivial(self):
		return False
	def get_ctype(self):
		ctype = self.inner.get_ctype()
		return f'std::shared_ptr<{ctype}>'
	def get_alignment(self):
		return 5
	def ostr(self, order, name, ndr_flags, switch_is):
		ret = [f'if (!{name}) {{',
			f'\t__ndr << "NULL";',
			'} else {']
		for s in self.inner.ostr(order, f'*{name}', ndr_flags, switch_is):
			ret.append(f'\t{s}')
		ret.append('}')
		return ret

class FieldTypeUniquePtr(FieldTypePtr):
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SCALARS_UNIQUE_PTR({name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		inner_stmts = self.inner.both(order, func, f'*{name}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is)
		return  append_stmts([ f'if ({name}) {{' ], inner_stmts, '\t') + ['}']
	def __str__(self):
		return "Unique(%s)" % self.inner

class FieldTypeRelativePtr(FieldTypePtr):
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		return [f'X_NDR_SAVE_POS(uint32, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags});']
	def buffers_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		inner_stmts = self.inner.both(order, func, f'*{name}', ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is)
		
		return append_stmts([ f'X_NDR_BUFFERS_RELATIVE_PTR_START_{func}({name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is}); {{'],
			inner_stmts, '\t') + [
			f'}} X_NDR_BUFFERS_RELATIVE_PTR_END_{func}({name}, {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});' ]
	def __str__(self):
		return "Relative(%s)" % self.inner

class FieldTypeValue(FieldTypeDerived):
	def __init__(self, jsobj, idltype, dereferenced, value, array_len):
		super().__init__(jsobj, idltype, dereferenced)
		self.value, self.array_len = value, array_len
	def scalars_body(self, order, func, name, ndr_arg, bpos_arg, epos_arg, ndr_flags, switch_is):
		if self.array_len is not None:
			ctype = f'std::array<{self.get_ctype()}, {self.array_len}>'
			return [f'X_NDR_SCALARS_ARRAY_VALUE({self.get_ndr_traits()}, ({ctype}{{{self.value}}}), {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
		else:
			ctype = self.get_ctype()
			return [f'X_NDR_SCALARS_VALUE({self.get_ndr_traits()}, ({ctype}{{{self.value}}}), {ndr_arg}, {bpos_arg}, {epos_arg}, {ndr_flags}, {switch_is});']
	def __str__(self):
		return "Value(%s)" % self.value

def load_idl_with_import(infp):
	imports = []
	idl = json.load(infp)
	for o in idl:
		if o['TYPE'] != "IMPORT":
			continue
		for path in o['PATHS']:
			import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
			imports.append(import_name)
	return idl, imports

def load_all(infp, name, path, recur):
	idl_tbl = {}
	idl, imports = load_idl_with_import(infp)
	idl_tbl[name] = idl

	while recur and imports:
		name = imports.pop()
		if name in idl_tbl:
			continue
		filename = os.path.join(path, '.'.join([name, "json"]))
		with open(filename, 'r') as fp:
			new_idl, new_imports = load_idl_with_import(fp)
			idl_tbl[name] = new_idl
			imports += new_imports
	return idl, idl_tbl

class Globals:
	idltype_table = { }
	elem_table = { }

	@classmethod
	def load_idl(self, infp, name, path, recur):
		idl_, idl_table = load_all(infp, name, path, recur)
		for _, idl in idl_table.items():
			for o in idl:
				if o['TYPE'] != "INTERFACE":
					continue
				for t in o['DATA']:
					ttype = t['TYPE']
					if ttype in [ "TYPEDEF", "CONST" ]:
						name = t['NAME']
						assert not name in self.elem_table
						self.elem_table[t['NAME']] = (ttype, t, o)
		return idl_

	@classmethod
	def find_elem(self, name, ttype):
		try:
			ttype_, elem, iface = self.elem_table[name]
		except KeyError:
			raise "Cannot find type '%s'" % name
		assert ttype == ttype_
		return elem, iface

	@classmethod
	def find_typedef(self, name):
		return self.find_elem(name, 'TYPEDEF')

	@classmethod
	def find_const(self, name):
		return self.find_elem(name, 'CONST')


def get_array_len(elem):
	try:
		array_len = elem['ARRAY_LEN']
		if len(array_len) == 0:
			return None
		assert len(array_len) == 1
		return array_len[0]
	except KeyError:
		return None

def elem_is_array_len_of(elem, elems):
	for elem2 in elems:
		array_len = get_array_len(elem2)
		if elem['NAME'] == array_len:
			return elem2
	return None

def elem_get_case_str(elem):
	case_value = get_property(elem, 'case')
	if case_value is not None:
		return f'case {case_value}'
	else:
		assert has_property(elem, 'default')
		return 'default'

def append_stmts(orig_stmts, new_stmts, indent):
	if orig_stmts is None:
		ret = []
	else:
		ret = orig_stmts[:]
	return ret + [ f'{indent}{s}' for s in new_stmts ]

ARG_FLAG_IN = 1
ARG_FLAG_OUT = 2
class Field(object):
	def __init__(self, elem, order, idltype):
		self.elem, self.order, self.field_type = elem, order, None
		self.name = elem['NAME']
		self.nontrivial_unions = []

		self.arg_flags = 0
		# check if there is no unknown PROPERTIES
		if 'PROPERTIES' in elem:
			if isinstance(idltype, IdlTypeStruct):
				idltype_flag = F_STRUCT
			elif isinstance(idltype, IdlTypeUnion):
				idltype_flag = F_UNION
			elif isinstance(idltype, IdlTypeFunction):
				idltype_flag = F_FUNCTION
			else:
				assert False
			for name, value in elem['PROPERTIES'].items():
				try:
					flags = know_properties[name]
					if (idltype_flag & flags) == 0:
						error(f'at {elem["FILE"]}:{elem["LINE"]} Property {name} not support {type(idltype)}')
						assert False
				except KeyError:
					error(f"Unknown property {name}.")
					assert False
				if name == 'in':
					assert value == '1'
					self.arg_flags |= ARG_FLAG_IN
				if name == 'out':
					assert value == '1'
					self.arg_flags |= ARG_FLAG_OUT

	def set_idltype(self, idltype):
		self.idltype = idltype
		self.ndr_flags = self.get_ndr_flags()
		self.switch_is = self.get_switch_is()
	def field_type_is(self, t):
		return isinstance(self.field_type, t)
	def has_buffers(self):
		return self.field_type.has_buffers()
	def is_nontrivial_union(self):
		return self.field_type.is_union() and not self.is_trivial()
	def is_trivial(self):
		return self.field_type.is_trivial()
	def get_ctype(self):
		return self.field_type.get_ctype()
	def dereferenced(self):
		return self.field_type.dereferenced()
	def get_properties_string__(self):
		return elem_tostring_properties(self.elem)
	def declare(self):
		ctype = self.field_type.get_ctype()
		declare = f'{ctype} {self.name};'
		if isinstance(self.field_type, FieldTypeDerived):
			declare = f'/* {declare} */'
		properties_string = elem_tostring_properties(self.elem)
		if properties_string:
			declare = ' '.join([declare, properties_string])
		return declare;
	def get_alignment(self):
		return self.field_type.get_alignment()

	def scalars_step0(self, func):
		ret = self.field_type.scalars_step0(self.order, func, f'__val.{self.name}', '__ndr', '__bpos', '__epos', self.ndr_flags, self.switch_is)
		assert isinstance(ret, list)
		return ret
	def scalars_pre(self, func):
		ret = self.field_type.scalars_pre(self.order, func, f'__val.{self.name}', '__ndr', '__bpos', '__epos', self.ndr_flags, self.switch_is)
		assert isinstance(ret, list)
		return ret
	def scalars_body(self, func):
		if func == 'PULL' and self.nontrivial_unions:
			val_arg = f'__tmp_{self.order}'
		else:
			val_arg = f'__val.{self.name}'
		ret = self.field_type.scalars_body(self.order, func, val_arg, '__ndr', '__bpos', '__epos', self.ndr_flags, self.switch_is)
		assert isinstance(ret, list)
		if func == 'PULL' and self.nontrivial_unions:
			ret = [f'auto __tmp_{self.order} = __val.{self.name};'] + ret + [f'__val.set_{self.name}(__tmp_{self.order});']
		return ret
	def scalars_post(self, func):
		return self.field_type.scalars_post(self.order, func, f'__val.{self.name}', '__ndr', '__bpos', '__epos', self.ndr_flags, self.switch_is)
	def buffers_pre(self, func):
		ret = self.field_type.buffers_pre(self.order, func, f'__val.{self.name}', '__ndr', '__bpos', '__epos', self.ndr_flags, self.switch_is)
		assert isinstance(ret, list)
		return ret
	def buffers_body(self, func):
		ret = self.field_type.buffers_body(self.order, func, f'__val.{self.name}', '__ndr', '__bpos', '__epos', self.ndr_flags, self.switch_is)
		assert isinstance(ret, list)
		return ret
	def buffers_post(self, func):
		ret = self.field_type.buffers_post(self.order, func, f'__val.{self.name}', '__ndr', '__bpos', '__epos', self.ndr_flags, self.switch_is)
		assert isinstance(ret, list)
		return ret
	def ostr(self):
		return self.field_type.ostr(self.order, f'__val.{self.name}', self.ndr_flags, self.switch_is)

	def get_property(self, prop, default = None):
		return get_property(self.elem, prop, default)
	def get_switch_is(self):
		switch_is = self.get_property('switch_is')
		if switch_is is None:
			return 'X_NDR_SWITCH_NONE'
		else:
			ro = re.compile('[A-Za-z_][A-Za-z0-9_]*')
			pos, comps = 0, []
			while True:
				m = ro.search(switch_is, pos)
				if not m:
					break
				start, end = m.span()
				prefix = ''
				if start != pos:
					prefix = switch_is[pos:start]
				op_name = switch_is[start:end]
				for f in self.idltype.fields:
					if f.name == op_name:
						if pos == 0 and f.dereferenced() and prefix.strip() == '*':
							prefix = ''
						#op_name = '__val.' + op_name
						comps.append('__val.')
						break
				if prefix:
					comps.append(prefix)
				comps.append(op_name)
				pos = end
			comps.append(switch_is[pos:])
			return ''.join(comps)
	def get_ndr_flags(self, flag_arg = '__flags'):
		flag = self.get_property('flag')
		if flag is None:
			return flag_arg
		else:
			return f'x_ndr_set_flags({flag_arg}, {flag})'

	def __str__(self):
		return "%d,%s,%s" % (self.order, self.name, self.field_type)

class IdlTypeBase(object):
	def __init__(self, name):
		self.name_ = name
	def get_ctype(self):
		return self.name_
	def __str__(self):
		return f'{self.NAME}({self.name_})'

class IdlTypePrimary(IdlTypeBase):
	NAME = "Primary"
	def __init__(self, name, alignment, is_trivial, has_buffers):
		super().__init__(name)
		self.alignment, self.trivial, self.has_buffers_ = alignment, is_trivial, has_buffers
	def get_alignment(self):
		return self.alignment
	def is_trivial(self):
		return self.trivial
	def has_buffers(self):
		return self.has_buffers_
	def get_ndr_traits(self):
		return f'ndr_traits_t<{self.name_}>'

class IdlTypeAlias(IdlTypeBase):
	NAME = "Alias"
	def __init__(self, name, realtype, alignment, ndr_traits):
		super().__init__(name)
		self.realtype, self.alignment, self.ndr_traits = realtype, alignment, ndr_traits
	def get_ctype(self):
		return self.realtype.get_ctype()
	def is_trivial(self):
		return self.realtype.is_trivial()
	def get_alignment(self):
		return self.realtype.get_alignment() if self.alignment is None else self.alignment
	def has_buffers(self):
		return self.realtype.has_buffers()
	def get_ndr_traits(self):
		return self.ndr_traits if self.ndr_traits else self.realtype.get_ndr_traits()

class TypedefBase(IdlTypeBase):
	def __init__(self, name, jsobj):
		super().__init__(name)
		self.jsobj = jsobj
	def has_property(self, prop):
		return has_property(self.jsobj['DATA'], prop);
	def get_property(self, prop, default = None):
		return get_property(self.jsobj['DATA'], prop, default)
	def get_ndr_traits(self):
		return f'ndr_traits_t<{self.name_}>'
	def tostring_properties(self):
		return tostring_properties__(self.jsobj['DATA'])

class IdlTypeEnum(TypedefBase):
	NAME = "ENUM"
	def __init__(self, name, jsobj):
		super().__init__(name, jsobj)
		self.elements = typedef_get_elements(jsobj)

		# for typedef enum { } we need to check $enum->{PARENT}
		if self.has_property("enum8bit"):
			self.etype, self.alignment = "uint8", 1
		elif self.has_property("enum16bit"):
			self.etype, self.alignment = "uint16", 2
		elif self.has_property("v1_enum"):
			self.etype, self.alignment = "uint32", 4
		else:
			warn(f'at {jsobj["FILE"]}:{jsobj["LINE"]} unknown enum properties {jsobj["DATA"].get("PROPERTIES", None)}')
			# should be uint16? TODO
			self.etype, self.alignment = "uint16", 3

	def is_trivial(self):
		return True
	def get_alignment(self):
		return self.alignment
	def has_buffers(self):
		return False
	def header(self, out):
		out(f'''

enum {self.get_ctype()} : {self.etype} {{
''')
		for elem in self.elements:
			out(f'''
	{elem},
''')
		out(f'''
}}{self.tostring_properties()};

X_NDR_DECLARE_TRAITS_ENUM({self.get_ctype()}, {self.etype}, {len(self.elements)}, x_ndr_type_enum)

''')

	def ndrcxx(self, out):
		#if not "ELEMENTS" in tdata:
		#	return
		out(f'''
const std::array<std::pair<{self.etype}, const char *>, {len(self.elements)}> ndr_traits_t<{self.get_ctype()}>::value_name_map = {{ {{
''')
		for elem in self.elements:
			ev = elem.split('=')[0]
			out(f'''
	{{ {ev}, "{ev}" }},
''')
		out('''
} };


''')

	
class IdlTypeBitmap(TypedefBase):
	NAME = "BITMAP"
	def __init__(self, name, jsobj):
		super().__init__(name, jsobj)
		self.elements = typedef_get_elements(jsobj)

		if self.has_property("bitmap8bit"):
			self.etype, self.alignment = "uint8", 1
		elif self.has_property("bitmap16bit"):
			self.etype, self.alignment = "uint16", 2
		elif self.has_property("bitmap32bit"):
			self.etype, self.alignment = "uint32", 4
		elif self.has_property("bitmap64bit"):
			self.etype, self.alignment = "uint64", 8
		else:
			warn(f'at {jsobj["FILE"]}:{jsobj["LINE"]} {jsobj["NAME"]} unknown bits')
			self.etype, self.alignment = "uint32", 4

	def is_trivial(self):
		return True
	def get_alignment(self):
		return self.alignment
	def has_buffers(self):
		return False
	def header(self, out):
		out(f'''

enum {self.get_ctype()} : {self.etype} {{
''')
		for elem in self.elements:
			stmt = re.sub(r'^([^ ]+) *\( *([^ ]+) *\)$', r'\1=\2,', elem)
			out(f'''
	{stmt}
''')
		out(f'''
}}{self.tostring_properties()};

X_NDR_DECLARE_TRAITS_ENUM({self.get_ctype()}, {self.etype}, {len(self.elements)}, x_ndr_type_bitmap)

''')

	def ndrcxx(self, out):
		out(f'''
const std::array<std::pair<{self.etype}, const char *>, {len(self.elements)}> ndr_traits_t<{self.get_ctype()}>::value_name_map = {{ {{''')
		for elem in self.elements:
			ev = re.sub(r'^([^ ]+) *\( *([^ ]+) *\)$', r'\1', elem)
			out(f'''
	{{ {ev}, "{ev}" }},
''')
		out('''
} };


''')


def elem_get_pointer_info(elem, iface, in_function):
	try:
		v = elem['POINTERS']
	except KeyError:
		v = 0

	if v == 0:
		return 0, None, False

	if in_function:
		assert not has_any_property(elem, 'relative')
		if has_any_property(elem, 'unique'):
			assert v == 1
			return v, 'unique', False
		v -= 1
		assert v < 2
		return v, 'unique', True
	else:
		for t in [ "unique", "relative" ]:
			try:
				tv = elem["PROPERTIES"][t]
			except:
				continue
			assert tv == "1"
			break
		else:
			try:
				t = iface['pointer_default']
			except:
				t = "unique"
		assert v < 3
		return v, t, False

def find_field(fields, elem):
	if isinstance(elem, str):
		name = elem
	else:
		name = elem['NAME']
	for f in fields:
		if f.name == name:
			return f
	raise KeyError("Cannot find field '%s'" % name)

def int_or_field(fields, expr):
	try:
		return int(expr)
	except: pass
	for operand in re.split(r'[^0-9a-zA-Z_.]+', expr):
		try:
			return find_field(fields, operand)
		except KeyError: pass
	raise KeyError("Cannot find field for expr '%s'" % expr)

def make_field_type(field, idltype, elems, iface, in_function):
	elem = field.elem

	pointer_count, pointer_type, pointer_deref = elem_get_pointer_info(elem, iface, in_function)

	field_idltype = idltype_get_by_name(elem['TYPE'])

	DBG("make_field_type", field.name, pointer_count, pointer_type, pointer_deref)
	assert pointer_count < 3

	if elem_has_property(elem, 'x_size'):
		assert pointer_count == 0
		assert not pointer_deref
		return FieldTypeXSize(elem, field_idltype, pointer_deref)

	master_elem = elem_is_property_of(elem, elems, 'subcontext_size')
	if master_elem:
		assert not pointer_deref
		assert pointer_count == 0
		return FieldTypeSubctxSize(elem, field_idltype, pointer_deref, find_field(idltype.fields, master_elem))

	array_len_name = elem_get_array_len(elem)
	value = elem_get_property(elem, 'value')
	if value:
		assert pointer_count == 0
		assert not pointer_deref
		if array_len_name:
			array_len_name = int(array_len_name)
		return FieldTypeValue(elem, field_idltype, pointer_deref, value, array_len_name)

	master_elem = elem_get_property(elem, 'x_ndr_size')
	if master_elem:
		assert pointer_count == 0
		assert not pointer_deref
		return FieldTypeXNdrSize(elem, field_idltype, pointer_deref, find_field(idltype.fields, master_elem))

	master_elem = elem_is_array_len_of(elem, elems)
	if master_elem:
		assert pointer_count == 0
		assert not pointer_deref
		return FieldTypeVectorLen(elem, field_idltype, pointer_deref, find_field(idltype.fields, master_elem))

	size_is_of = elem_is_expr_property_of(elem, elems, "size_is")
	if size_is_of:
		assert pointer_count == 0
		master_field = find_field(idltype.fields, size_is_of)
		if master_field.arg_flags != field.arg_flags:
			return FieldTypeSimple(elem, field_idltype, pointer_deref)
		return FieldTypeSizeIs(elem, field_idltype, pointer_deref, master_field)

	length_is_of = elem_is_expr_property_of(elem, elems, "length_is")
	if length_is_of:
		assert pointer_count == 0
		master_field = find_field(idltype.fields, length_is_of)
		if master_field.arg_flags != field.arg_flags:
			return FieldTypeSimple(elem, field_idltype, pointer_deref)
		return FieldTypeLengthIs(elem, field_idltype, pointer_deref, master_field)

	charset = elem_get_property(elem, "charset")
	size_is = elem_get_property(elem, "size_is")
	length_is = elem_get_property(elem, "length_is")
	if charset == "UTF16":
		assert elem['TYPE'] == 'uint16'
		field_idltype = idltype_get_by_name("u16string")
	elif charset == "DOS":
		assert elem['TYPE'] == 'uint8'
		field_idltype = idltype_get_by_name("u8string")
	else:
		assert charset is None
	if charset:
		assert not size_is_of
		assert not length_is_of
		if array_len_name == '*' and pointer_count == 0:
			array_len_name = None
		# TODO string with length_is or size_is is different to vector,
		# need to manually implement push/pull
		length_is = None
		size_is = None
	if elem_get_property(elem, "string"):
		assert charset == "UTF16"
		field_type = FieldTypeIdlString(elem, field_idltype, pointer_deref)
	else:
		field_type = FieldTypeSimple(elem, field_idltype, pointer_deref)

	if length_is:
		assert size_is
		field_type = FieldTypeLengthIsVector(field_type,
				int_or_field(idltype.fields, size_is),
				int_or_field(idltype.fields, length_is))
	elif size_is:
		slave_field = int_or_field(idltype.fields, size_is)
		if isinstance(slave_field, Field) and slave_field.arg_flags != field.arg_flags:
			slave_field = None
		field_type = FieldTypeSizeIsVector(field_type, slave_field)
	elif array_len_name is not None:
		assert pointer_count == 0
		try:
			array_len = int(array_len_name)
		except:
			try:
				Globals.find_const(array_len_name)
				array_len = array_len_name
			except:
				array_len = None
		if not array_len is None:
			field_type = FieldTypeArray(field_type, array_len)
		elif array_len_name == '*' and not has_any_property(elem, "size_is", "length_is"):
			field_type = FieldTypeUnboundVector(field_type)
		else:
			field_type = FieldTypeSimpleVector(field_type, find_field(idltype.fields, array_len_name))

	subcontext = elem_get_property(elem, 'subcontext')
	if subcontext is not None:
		subcontext_level = int(subcontext, 0)
		if subcontext_level in [0, 2, 4]:
			subcontext_size = elem_get_property(elem, "subcontext_size")
			field_type = FieldTypeSubctxLevel(field_type, subcontext_level,
					None if subcontext_size is None else find_field(idltype.fields, subcontext_size))
		elif subcontext_level == 0xFFFFFC01:
			field_type = FieldTypeSubctxFFFFFC01(field_type)
		else:
			assert False

	for _ in range(pointer_count):
		assert pointer_type in [ "relative", "unique" ]
		if pointer_type == "relative":
			field_type = FieldTypeRelativePtr(field_type)
		else:
			field_type = FieldTypeUniquePtr(field_type)
	return field_type

def make_fields(idltype, name, elems, iface, in_function):
	idltype.fields = [ Field(elem, order, idltype) for order, elem in enumerate(elems) ]
	
	for field in idltype.fields:
		field.field_type = make_field_type(field, idltype, elems, iface, in_function)

	for field in idltype.fields:
		field.set_idltype(idltype)
		if field.is_nontrivial_union():
			switch_is = field.get_property('switch_is')
			switch_is = switch_is.split('&')[0] # TODO
			for f in idltype.fields:
				if f.name == switch_is:
					f.nontrivial_unions.append(field)
					break
			else:
				assert False

	def dbg_output_fields(fields):
		return '\n\t'.join([ str(x) for x in fields ])
	DBG('%s fields:\n\t%s' % (name, LazyToStr(dbg_output_fields, idltype.fields)))

def get_first_case(union):
	for field in union.fields:
		case = field.get_property("case")
		if case is not None:
			return case, field

def output_struct_functions(self, out):
	def union_field_iter(union_fields):
		for uf in union_fields:
			switch_is = uf.get_property("switch_is")
			yield uf, switch_is, uf.field_type_is(FieldTypePtr)
	
	def default_ctor_initializer(fields):
		for field in fields:
			if len(field.nontrivial_unions) == 0:
				continue
			first_case, _ = get_first_case(field.nontrivial_unions[0].field_type.get_idltype())
			yield f'{field.name}(({field.get_ctype()}){first_case})'

	def move_copy_ctor_initializer(fields):
		for field in fields:
			if field.field_type_is(FieldTypeDerived) or field.is_nontrivial_union():
				continue
			yield f'{field.name}(__other.{field.name})'
				
	def output_special(signature, init_iter, body_func):
		out(f'''
{signature}''')
		if init_iter:
			sep = ':'
			for stmt in init_iter(self.fields):
				out(f'''
	{sep} {stmt}''')
				sep = ','
		out('{')
		for field in self.fields:
			if len(field.nontrivial_unions) == 0:
				continue
			for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
				out(f'''
	{body_func(uf, switch_is, is_pointer)}''')
		out('''
}

''')

	has_nontrivial_unions, all_nontrivial_unions_are_ptr = False, True
	for field in self.fields:
		if field.nontrivial_unions:
			has_nontrivial_unions = True
			for nf in field.nontrivial_unions:
				if not nf.field_type_is(FieldTypePtr):
					all_nontrivial_unions_are_ptr = False

	output_special(f'{self.get_ctype()}::{self.get_ctype()}()',
		default_ctor_initializer,
		lambda uf, switch_is, is_pointer:
			f'x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}));')
	output_special(f'{self.get_ctype()}::~{self.get_ctype()}()', None,
		lambda uf, switch_is, is_pointer:
			f'x_ndr_union_field_uninit({uf.name}, x_ndr_switch_t({switch_is}));')

	if not all_nontrivial_unions_are_ptr:
		output_special(f'{self.get_ctype()}::{self.get_ctype()}({self.get_ctype()} &&__other)',
			move_copy_ctor_initializer,
			lambda uf, switch_is, is_pointer:
				f'x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}), std::move(__other.{uf.name}));')
		output_special(f'{self.get_ctype()}::{self.get_ctype()}(const {self.get_ctype()} &__other)',
			move_copy_ctor_initializer,
			lambda uf, switch_is, is_pointer:
				f'x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}), __other.{uf.name});')

	for field in self.fields:
		if len(field.nontrivial_unions) == 0:
			continue
		out(f'''
void {self.get_ctype()}::set_{field.name}({field.get_ctype()} v)
{{''')
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_uninit({uf.name}, x_ndr_switch_t({switch_is}));''')
		out(f'''
	{field.name} = v;''')
		for uf, switch_is, is_pointer in union_field_iter(field.nontrivial_unions):
			out(f'''
	x_ndr_union_field_init({uf.name}, x_ndr_switch_t({switch_is}));''')
		out('''
}

''')

class IdlTypeStruct(TypedefBase):
	NAME = "STRUCT"
	def __init__(self, name, jsobj, iface):
		super().__init__(name, jsobj)
		make_fields(self, name, typedef_get_elements(jsobj), iface, False)
	def is_trivial(self):
		return all([f.is_trivial() for f in self.fields])
	def has_buffers(self):
		return any([f.has_buffers() for f in self.fields])
	def get_alignment(self):
		return max(1, 1, *[field.get_alignment() for field in self.fields])
	def header(self, out):
		has_nontrivial_unions, all_nontrivial_unions_are_ptr = False, True
		for field in self.fields:
			if field.nontrivial_unions:
				has_nontrivial_unions = True
				for nf in field.nontrivial_unions:
					if not nf.field_type_is(FieldTypePtr):
						all_nontrivial_unions_are_ptr = False

		out(f'''

struct {self.get_ctype()} {{
''')
		if any([len(f.nontrivial_unions) > 0 for f in self.fields]):
			out(f'''
	{self.get_ctype()}();
	~{self.get_ctype()}();
	{self.get_ctype()}({self.get_ctype()}&& other){" = default" if all_nontrivial_unions_are_ptr else ""};
	{self.get_ctype()}(const {self.get_ctype()}& other){" = default" if all_nontrivial_unions_are_ptr else ""};
	{self.get_ctype()} &operator=(const {self.get_ctype()}& other) = delete;
	{self.get_ctype()} &operator=({self.get_ctype()}&& other) = delete;
''')
			for switch_field in self.fields:
				if len(switch_field.nontrivial_unions) == 0:
					continue
				# TODO if elem_has_property(switch_field, 'value'):
				#	continue
				out(f'''
	void set_{switch_field.name}({switch_field.get_ctype()} v);
''')

		for field in self.fields:
			out(f'''
	{field.declare()}
''')
		out(f'''
}} {self.tostring_properties()};

template <> struct ndr_traits_t<{self.get_ctype()}> {{
	using ndr_base_type = {self.get_ctype()};
	using has_buffers = std::{"true" if self.has_buffers() else "false"}_type;
	using ndr_data_type = x_ndr_type_struct;

	x_ndr_off_t scalars(const {self.get_ctype()} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({self.get_ctype()} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
		if self.has_buffers():
			out(f'''
	x_ndr_off_t buffers(const {self.get_ctype()} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t buffers({self.get_ctype()} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
		out(f'''
	void ostr(const {self.get_ctype()} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};


''')


	def ndrcxx(self, out):
		out(f'''

/***** Generated function for {self.get_ctype()} *****/

''')

		if any([len(f.nontrivial_unions) > 0 for f in self.fields]):
			output_struct_functions(self, out)

		for func, constness in (("push", "const "), ("pull", "")):
			if self.has_property("no" + func):
				continue
			upfunc = func.upper()
			out(f'''
x_ndr_off_t ndr_traits_t<{self.get_ctype()}>::scalars({constness}{self.get_ctype()} &__val, x_ndr_{func}_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			flag = self.get_property('flag')
			if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
			for field in self.fields:
				for stmt in field.scalars_step0(upfunc):
					out(f'''
	{stmt}''')

			out(f'''
	X_NDR_HEADER_ALIGN({self.get_alignment()}, __ndr, __bpos, __epos, __flags);
''')
			for field in self.fields:
				for stmt in field.scalars_pre(upfunc):
					out(f'''
	{stmt}''')

			for field in self.fields:
				for stmt in field.scalars_body(upfunc):
					out(f'''
	{stmt}''')

			for field in self.fields:
				for stmt in field.scalars_post(upfunc):
					out(f'''
		{stmt}''')

			out(f'''
	X_NDR_TRAILER_ALIGN({self.get_alignment()}, __ndr, __bpos, __epos, __flags);
	return __bpos;
}}

''')

			if not self.has_buffers():
				continue
			out(f'''
x_ndr_off_t ndr_traits_t<{self.get_ctype()}>::buffers({constness}{self.get_ctype()} &__val, x_ndr_{func}_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			for field in self.fields:
				if field.has_buffers():
					for stmt in field.buffers_pre(upfunc):
						out(f'''
	{stmt}''')

			for field in self.fields:
				if field.has_buffers():
					for stmt in field.buffers_body(upfunc):
						out(f'''
	{stmt}''')

			for field in self.fields:
				if field.has_buffers():
					for stmt in field.buffers_post(upfunc):
						out(f'''
	{stmt}''')

			out(f'''
	return __bpos;
}}

''')

		if not self.has_property("noprint"):
			out(f'''
void ndr_traits_t<{self.get_ctype()}>::ostr(const {self.get_ctype()} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const
{{''')
			flag = self.get_property('flag')
			if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
			out(f'''
	__ndr << enter;''');
			for field in self.fields:
				stmts = field.ostr()
				if len(stmts): out(f'''
	__ndr << "{field.name}:";''')
				for stmt in stmts:
					out(f'''
	{stmt}''')
				if len(stmts): out(f'''
	__ndr << next;''')
			out(f'''
	__ndr << leave;
}}

''')


def get_case_str(field):
	case_value = field.get_property('case')
	if case_value is not None:
		return f'case {case_value}'
	else:
		assert field.get_property('default')
		return 'default'

def union_output_function(out, fields, signature, field_func):
	out(f'''
{signature}
{{
	switch (__level) {{''')
	for field in fields:
		if field.name != '':
			in_case_str = f' {field_func(field.name)}'
		else:
			in_case_str = ''
		out(f'''
		{get_case_str(field)}:{in_case_str} break;''')
	out('''
	}
}

''')

class IdlTypeUnion(TypedefBase):
	NAME = "UNION"
	def __init__(self, name, jsobj, iface):
		super().__init__(name, jsobj)
		self.jsobj = jsobj
		make_fields(self, name, typedef_get_elements(jsobj), iface, False)
	def is_trivial(self):
		return all([f.is_trivial() for f in self.fields])
	def has_buffers(self):
		return any([field.has_buffers() for field in self.fields])
	def get_alignment(self):
		return max([f.get_alignment() for f in self.fields])
	def header(self, out):
		out(f'''

union {self.get_ctype()}
{{
''')
		if not self.is_trivial():
			out(f'''
	{self.get_ctype()}() {{ }}
	~{self.get_ctype()}() {{ }}
	void __init(x_ndr_switch_t __level);
	void __init(x_ndr_switch_t __level, {self.get_ctype()} &&__other);
	void __init(x_ndr_switch_t __level, const {self.get_ctype()} &__other);
	void __uninit(x_ndr_switch_t __level);
''')
		# union member may has same name
		unique_fields = { }
		for field in self.fields:
			if field.name == '':
				continue
			unique_fields[field.name] = field
		for _, field in unique_fields.items():
			out(f'''
	{field.declare()}
''')

		out(f'''
}} {self.tostring_properties()};

template <> struct ndr_traits_t<{self.get_ctype()}> {{
	using ndr_base_type = {self.get_ctype()};
	using has_buffers = std::{"true_type" if self.has_buffers() else "false_type"};
	using ndr_data_type = x_ndr_type_union;

	x_ndr_off_t scalars(const {self.get_ctype()} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({self.get_ctype()} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
		if self.has_buffers(): out(f'''
	x_ndr_off_t buffers(const {self.get_ctype()} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t buffers({self.get_ctype()} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
''')
		out(f'''
	void ostr(const {self.get_ctype()} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const;
}};
''')

	def ndrcxx(self, out):
		if any([not field.is_trivial() for field in self.fields]):
			union_output_function(out, self.fields, f'void {self.get_ctype()}::__init(x_ndr_switch_t __level)',
				lambda n: f'construct({n});')
			union_output_function(out, self.fields, f'void {self.get_ctype()}::__init(x_ndr_switch_t __level, {self.get_ctype()} &&other)',
				lambda n: f'construct({n}, std::move(other.{n}));')
			union_output_function(out, self.fields, f'void {self.get_ctype()}::__init(x_ndr_switch_t __level, const {self.get_ctype()} &other)',
				lambda n: f'construct({n}, other.{n});')
			union_output_function(out, self.fields, f'void {self.get_ctype()}::__uninit(x_ndr_switch_t __level)',
				lambda n: f'destruct({n});')

		for func, constness in (("push", "const "), ("pull", "")):
			if self.has_property("no" + func):
				continue
			upfunc = func.upper()
			out(f'''
x_ndr_off_t ndr_traits_t<{self.get_ctype()}>::scalars({constness}{self.get_ctype()} &__val, x_ndr_{func}_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			flag = self.get_property('flag')
			if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
			out(f'''
	X_NDR_UNION_ALIGN({self.get_alignment()}, __ndr, __bpos, __epos, __flags);
	switch (__level) {{
''')
			for field in self.fields:
				stmts = None
				if field.name != '':
					stmts = field.scalars_step0(upfunc) + field.scalars_pre(upfunc) + field.scalars_body(upfunc) + field.scalars_post(upfunc)
				if stmts:
					out(f'''
		{get_case_str(field)}: {{''')
					for stmt in stmts:
						out(f'''
			{stmt}''')
					out(f'''
		}} break;
''')
			out('''
	}
	return __bpos;
}

''')
			if not self.has_buffers():
				continue
			out(f'''
x_ndr_off_t ndr_traits_t<{self.get_ctype()}>::buffers({constness}{self.get_ctype()} &__val, x_ndr_{func}_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
			flag = self.get_property('flag')
			if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
			out(f'''
	switch (__level) {{
''')
			for field in self.fields:
				stmts = None
				if field.name != '' and field.has_buffers():
					stmts = field.buffers_pre(upfunc) + field.buffers_body(upfunc) + field.buffers_post(upfunc)
				if stmts:
					out(f'''
		{get_case_str(field)}: {{''')
					for stmt in stmts:
						out(f'''
			{stmt}''')
					out(f'''
		}} break;
''')
			out('''
	}

	return __bpos;
}

''')
		if not self.has_property("noprint"):
			out(f'''
void ndr_traits_t<{self.get_ctype()}>::ostr(const {self.get_ctype()} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const
{{''')
			flag = self.get_property('flag')
			if flag is not None: out(f'''
	x_ndr_set_flags(__flags, {flag});''')
			out(f'''
	switch (__level) {{
''')
			for field in self.fields:
				if field.name == '':
					continue
				out(f'''
		{get_case_str(field)}: {{''')
				for stmt in field.ostr():
					out(f'''
			{stmt}''')
				out('''
		} break;''')
			out('''
	}
}

''')


class IdlTypeFunction(IdlTypeBase):
	def __init__(self, name, jsobj, iface):
		super().__init__(name)
		self.jsobj = jsobj
		make_fields(self, name, get_elements(jsobj), iface, True)
	def has_property(self, prop):
		return has_property(self.jsobj, prop);
	def get_property(self, prop, default = None):
		return get_property(self.jsobj['DATA'], prop, default)
	def tostring_properties(self):
		return tostring_properties__(self.jsobj)
	def header(self, out):
		has_nontrivial_unions, all_nontrivial_unions_are_ptr = False, True
		for field in self.fields:
			if field.nontrivial_unions:
				has_nontrivial_unions = True
				for nf in field.nontrivial_unions:
					if not nf.field_type_is(FieldTypePtr):
						all_nontrivial_unions_are_ptr = False

		out(f'''

struct {self.get_ctype()} {{
''')
		if any([len(f.nontrivial_unions) > 0 for f in self.fields]):
			out(f'''
	{self.get_ctype()}();
	~{self.get_ctype()}();
	{self.get_ctype()}({self.get_ctype()}&& other){" = default" if all_nontrivial_unions_are_ptr else ""};
	{self.get_ctype()}(const {self.get_ctype()}& other){" = default" if all_nontrivial_unions_are_ptr else ""};
	{self.get_ctype()} &operator=(const {self.get_ctype()}& other) = delete;
	{self.get_ctype()} &operator=({self.get_ctype()}&& other) = delete;
''')
			for switch_field in self.fields:
				if len(switch_field.nontrivial_unions) == 0:
					continue
				# TODO if elem_has_property(switch_field, 'value'):
				#	continue
				out(f'''
	void set_{switch_field.name}({switch_field.get_ctype()} v);
''')

		for field in self.fields:
			out(f'''
	{field.declare()}
''')
		out(f'''
	{self.jsobj['RETURN_TYPE']} __result;
}} {self.tostring_properties()};

template <> struct ndr_requ_traits_t<{self.get_ctype()}> {{
	using ndr_base_type = {self.get_ctype()};
	using has_buffers = std::false_type;
	using ndr_data_type = x_ndr_type_struct;

	x_ndr_off_t scalars(const {self.get_ctype()} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({self.get_ctype()} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
}};

template <> struct ndr_resp_traits_t<{self.get_ctype()}> {{
	using ndr_base_type = {self.get_ctype()};
	using has_buffers = std::false_type;
	using ndr_data_type = x_ndr_type_struct;

	x_ndr_off_t scalars(const {self.get_ctype()} &__val, x_ndr_push_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
	x_ndr_off_t scalars({self.get_ctype()} &__val, x_ndr_pull_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const;
}};

''')

	def ndrcxx__(self, out, in_out_name, in_out_flag, constness, func):
		upfunc = func.upper()
		out(f'''
x_ndr_off_t ndr_{in_out_name}_traits_t<{self.get_ctype()}>::scalars({constness}{self.get_ctype()} &__val, x_ndr_{func}_t &__ndr, x_ndr_off_t __bpos, x_ndr_off_t __epos, uint32_t __flags, x_ndr_switch_t __level) const
{{
''')
		for field in [ x for x in self.fields if x.arg_flags & in_out_flag ]:
			for stmt in field.scalars_pre(upfunc):
				out(f'''
	{stmt}''')
		for field in [ x for x in self.fields if (x.arg_flags & in_out_flag) and x.has_buffers() ]:
			for stmt in field.buffers_pre(upfunc):
				out(f'''
	{stmt}''')
		for field in [ x for x in self.fields if x.arg_flags & in_out_flag ]:
			for stmt in field.scalars_step0(upfunc) + \
					field.scalars_body(upfunc) + \
					field.scalars_post(upfunc):
				out(f'''
	{stmt}''')

		for field in [ x for x in self.fields if (x.arg_flags & in_out_flag) and x.has_buffers() ]:
			for stmt in field.buffers_body(upfunc):
				out(f'''
	{stmt}''')
		for field in [ x for x in self.fields if (x.arg_flags & in_out_flag) and x.has_buffers() ]:
			for stmt in field.buffers_post(upfunc):
				out(f'''
	{stmt}''')
		out(f'''
	return __bpos;
}}

''')
	def ndrcxx(self, out):
		out(f'''

/***** Generated function for {self.get_ctype()} *****/

''')
		if any([len(f.nontrivial_unions) > 0 for f in self.fields]):
			output_struct_functions(self, out)

		for func, constness in (("push", "const "), ("pull", "")):
			if not self.has_property("in_no" + func):
				self.ndrcxx__(out, "requ", ARG_FLAG_IN, constness, func)
			if not self.has_property("out_no" + func):
				self.ndrcxx__(out, "resp", ARG_FLAG_OUT, constness, func)

		if False and not self.has_property("noprint"):
			out(f'''
void ndr_traits_t<{self.get_ctype()}>::ostr(const {self.get_ctype()} &__val, x_ndr_ostr_t &__ndr, uint32_t __flags, x_ndr_switch_t __level) const
{{''')
			flag = self.get_property('flag')
			if flag is not None: out(f'''
	__flags = x_ndr_set_flags(__flags, {flag});
''')
			out(f'''
	__ndr << enter;''');
			for field in self.fields:
				stmts = field.ostr()
				if len(stmts): out(f'''
	__ndr << "{field.name}:";''')
				for stmt in stmts:
					out(f'''
	{stmt}''')
				if len(stmts): out(f'''
	__ndr << next;''')
			out(f'''
	__ndr << leave;
}}

''')


def idltype_create_by_jsobj(name, jsobj, iface):
	data_type = jsobj['DATA']['TYPE']
	if data_type == 'ENUM':
		idltype = IdlTypeEnum(name, jsobj)
	elif data_type == 'BITMAP':
		idltype = IdlTypeBitmap(name, jsobj)
	elif data_type == 'STRUCT':
		idltype = IdlTypeStruct(name, jsobj, iface)
	elif data_type == 'UNION':
		idltype = IdlTypeUnion(name, jsobj, iface)
	else:
		assert False, f"Unknown data_type '{data_type}'"

	DBG("Create idltype %s" % idltype)
	Globals.idltype_table[name] = idltype
	return idltype
	
def idltype_get_by_name(name):
	try:
		return Globals.idltype_table[name]
	except KeyError: pass

	if name in alias_types:
		base_type, ndr_traits, alignment = alias_types[name]
		idltype = idltype_get_by_name(base_type)
		return IdlTypeAlias(name, idltype, alignment, ndr_traits)

	jsobj, iface = Globals.find_typedef(name)
	return idltype_create_by_jsobj(name, jsobj, iface)

def idltype_get_by_jsobj(jsobj, iface):
	name = jsobj['NAME']
	try:
		return Globals.idltype_table[name]
	except KeyError: pass

	return idltype_create_by_jsobj(name, jsobj, iface)

def idltype_create_function(jsobj, iface):
	name = jsobj['NAME']
	assert name not in Globals.idltype_table
	idltype = IdlTypeFunction(name, jsobj, iface)
	Globals.idltype_table[name] = idltype
	return idltype

def const_get_pointers(elem):
	try:
		v = elem['POINTERS']
	except KeyError:
		return 0
	assert v == 0
	return v

def output_header_INTERFACE(out, iface, idl):
	for t in iface['DATA']:
		if t['TYPE'] == 'TYPEDEF':
			idltype = idltype_get_by_jsobj(t, iface)
			idltype.header(out)
		elif t['TYPE'] == 'CONST':
			dtype = t['DTYPE']
			assert const_get_pointers(t) == 0
			out(f'''
const {dtype}{'*' if t['POINTERS'] == 1 else ''} {t['NAME']} = {t['VALUE']};
''')
		elif t["TYPE"] in [ "FUNCTION" ]:
			idltype = idltype_create_function(t, iface)
			idltype.header(out)
		else:
			error(f'''Unknown type "{t['TYPE']}" at {t['FILE']}:{t['LINE']}''')
			assert False


def output_ndrcxx_INTERFACE(out, iface, idl):
	helper = get_property(iface, "helper")
	if helper is not None:
		out(f'''
#include {helper}
''')
	out(f'''

namespace idl {{

''')
	for t in iface['DATA']:
		if t['TYPE'] == 'TYPEDEF':
			idltype = idltype_get_by_jsobj(t, iface)
			idltype.ndrcxx(out)
		elif t['TYPE'] in [ "FUNCTION" ]:
			idltype = idltype_create_function(t, iface)
			idltype.ndrcxx(out)
		elif t['TYPE'] in [ "CONST", "FUNCTION" ]:
			pass
		else:
			assert False

	out(f'''

// }}
}}
''')

def output_header_IMPORT(out, o):
	for path in o['PATHS']:
		import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
		out(f'#include "include/librpc/{import_name}.hxx"')
	out()

def process_header(out, name, idl, outdir):
	ifacename = None
	for o in idl:
		if o['TYPE'] == "INTERFACE":
			ifacename = o['NAME']
			break

	out(f'''
/* header auto-generated by gen-rpc */
#ifndef __GEN_RPC__HEADER_{ifacename}
#define __GEN_RPC__HEADER_{ifacename}
#include "include/librpc/ndr_smb.hxx"

''')

	for o in idl:
		if o['TYPE'] == "IMPORT": output_header_IMPORT(out, o)
		if o['TYPE'] == "INCLUDE": output_header_INCLUDE(out, o)

	out(f'''
namespace idl {{
''')

	for o in idl:
		#if o['TYPE'] == "CPP_QUOTE": output_header_QUOTE(out, o)
		if o['TYPE'] == "INTERFACE": output_header_INTERFACE(out, o, idl)
			
	out(f'''

}} /* namespace idl */

#endif /* __GEN_RPC__HEADER_{ifacename} */

''')


def process_ndrcxx(out, name, idl, outdir):
	out(f'''
/* ndr parser auto-generated by pidl */
	
#include "include/librpc/{name}.hxx"

''')

	for o in idl:
		if o['TYPE'] == "INTERFACE": output_ndrcxx_INTERFACE(out, o, idl)



def process_depend(out, name, idl, outdir):
	for o in idl:
		if o['TYPE'] != "IMPORT":
			continue
		for path in o['PATHS']:
			import_name = re.sub('^"(.*)\.idl"$', r'\1', path)
			out(f'''
{outdir}/{name}.idl.hxx: {outdir}/{import_name}.json
{outdir}/{name}.idl.ndr.cxx: include/librpc/{import_name}.hxx
{outdir}/{name}.idl.ndr.o: include/librpc/ndr.hxx
{outdir}/{name}.idl.ndr.o: include/librpc/ndr_smb.hxx
''')

def process(infp, name, args):
	idl = Globals.load_idl(infp, name, args.outputdir, args.header or args.ndrcxx)

	def output(func, ext):
		if name is None:
			outfp = sys.stdout
		else:
			tmpfix = "tmp"
			filename = os.path.join(args.outputdir, '.'.join([name, ext, tmpfix]))
			outfp = open(filename, 'w')

		try:
			out = OStream(outfp)
			func(out, name, idl, args.outputdir)
		except:
			if name is not None:
				outfp.close()
				os.remove(filename)
			raise
		if name is not None:
			os.rename(filename, os.path.join(args.outputdir, '.'.join([name, ext])))
	
	if args.depend: output(process_depend, 'd')
	if args.header: output(process_header, 'idl.hxx')
	if args.ndrcxx: output(process_ndrcxx, 'idl.ndr.cxx')
	if args.python: output(process_python, 'py.cxx')
			
	
def main():
	parser = argparse.ArgumentParser()
	parser.add_argument("-d", "--debug", action="store_true", help="output debug info")
	parser.add_argument("--depend", action="store_true", help="output dependency")
	parser.add_argument("--header", action="store_true", help="output header")
	parser.add_argument("--ndrcxx", action="store_true", help="output ndr")
	parser.add_argument("--python", action="store_true", help="output ndr")
	parser.add_argument("--outputdir", default=".", help="output directory")
	parser.add_argument("input", nargs='*', help="Input IDL json files")

	args = parser.parse_args()
	args.outputdir = args.outputdir.rstrip('/')
	if args.debug:
		global DBG
		print(args, file=sys.stderr)
		DBG = _dbg_stderr

	for name, align, is_trivial, has_buffers in known_simple_types:
		Globals.idltype_table[name] = IdlTypePrimary(name, align, is_trivial, has_buffers)

	if len(args.input) == 0:
		process(sys.stdin, None, args)
	else:
		for f in args.input:
			with open(f, 'r') as fp:
				name = os.path.splitext(os.path.basename(f))[0]
				process(fp, name, args)

	return 0

if __name__ == "__main__": sys.exit(main())


